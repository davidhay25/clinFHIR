{"version":3,"file":"index.js","sources":["../../../../src/tracing/vercel-ai/index.ts"],"sourcesContent":["import type { Client } from '../../client';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_OP, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN } from '../../semanticAttributes';\nimport type { Event } from '../../types-hoist/event';\nimport type { Span, SpanAttributes, SpanAttributeValue, SpanJSON, SpanOrigin } from '../../types-hoist/span';\nimport { spanToJSON } from '../../utils/spanUtils';\nimport {\n  GEN_AI_USAGE_INPUT_TOKENS_CACHE_WRITE_ATTRIBUTE,\n  GEN_AI_USAGE_INPUT_TOKENS_CACHED_ATTRIBUTE,\n} from '../ai/gen-ai-attributes';\nimport { getTruncatedJsonString } from '../ai/utils';\nimport { toolCallSpanMap } from './constants';\nimport type { TokenSummary } from './types';\nimport { accumulateTokensForParent, applyAccumulatedTokens, convertAvailableToolsToJsonString } from './utils';\nimport type { ProviderMetadata } from './vercel-ai-attributes';\nimport {\n  AI_MODEL_ID_ATTRIBUTE,\n  AI_MODEL_PROVIDER_ATTRIBUTE,\n  AI_PROMPT_ATTRIBUTE,\n  AI_PROMPT_MESSAGES_ATTRIBUTE,\n  AI_PROMPT_TOOLS_ATTRIBUTE,\n  AI_RESPONSE_OBJECT_ATTRIBUTE,\n  AI_RESPONSE_PROVIDER_METADATA_ATTRIBUTE,\n  AI_RESPONSE_TEXT_ATTRIBUTE,\n  AI_RESPONSE_TOOL_CALLS_ATTRIBUTE,\n  AI_SCHEMA_ATTRIBUTE,\n  AI_TELEMETRY_FUNCTION_ID_ATTRIBUTE,\n  AI_TOOL_CALL_ARGS_ATTRIBUTE,\n  AI_TOOL_CALL_ID_ATTRIBUTE,\n  AI_TOOL_CALL_NAME_ATTRIBUTE,\n  AI_TOOL_CALL_RESULT_ATTRIBUTE,\n  AI_USAGE_CACHED_INPUT_TOKENS_ATTRIBUTE,\n  AI_USAGE_COMPLETION_TOKENS_ATTRIBUTE,\n  AI_USAGE_PROMPT_TOKENS_ATTRIBUTE,\n  GEN_AI_RESPONSE_MODEL_ATTRIBUTE,\n  GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE,\n  GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE,\n} from './vercel-ai-attributes';\n\nfunction addOriginToSpan(span: Span, origin: SpanOrigin): void {\n  span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, origin);\n}\n\n/**\n * Post-process spans emitted by the Vercel AI SDK.\n * This is supposed to be used in `client.on('spanStart', ...)\n */\nfunction onVercelAiSpanStart(span: Span): void {\n  const { data: attributes, description: name } = spanToJSON(span);\n\n  if (!name) {\n    return;\n  }\n\n  // Tool call spans\n  // https://ai-sdk.dev/docs/ai-sdk-core/telemetry#tool-call-spans\n  if (attributes[AI_TOOL_CALL_NAME_ATTRIBUTE] && attributes[AI_TOOL_CALL_ID_ATTRIBUTE] && name === 'ai.toolCall') {\n    processToolCallSpan(span, attributes);\n    return;\n  }\n\n  // The AI and Provider must be defined for generate, stream, and embed spans.\n  // The id of the model\n  const aiModelId = attributes[AI_MODEL_ID_ATTRIBUTE];\n  // the provider of the model\n  const aiModelProvider = attributes[AI_MODEL_PROVIDER_ATTRIBUTE];\n  if (typeof aiModelId !== 'string' || typeof aiModelProvider !== 'string' || !aiModelId || !aiModelProvider) {\n    return;\n  }\n\n  processGenerateSpan(span, name, attributes);\n}\n\nfunction vercelAiEventProcessor(event: Event): Event {\n  if (event.type === 'transaction' && event.spans) {\n    // Map to accumulate token data by parent span ID\n    const tokenAccumulator: Map<string, TokenSummary> = new Map();\n\n    // First pass: process all spans and accumulate token data\n    for (const span of event.spans) {\n      processEndedVercelAiSpan(span);\n\n      // Accumulate token data for parent spans\n      accumulateTokensForParent(span, tokenAccumulator);\n    }\n\n    // Second pass: apply accumulated token data to parent spans\n    for (const span of event.spans) {\n      if (span.op !== 'gen_ai.invoke_agent') {\n        continue;\n      }\n\n      applyAccumulatedTokens(span, tokenAccumulator);\n    }\n\n    // Also apply to root when it is the invoke_agent pipeline\n    const trace = event.contexts?.trace;\n    if (trace && trace.op === 'gen_ai.invoke_agent') {\n      applyAccumulatedTokens(trace, tokenAccumulator);\n    }\n  }\n\n  return event;\n}\n/**\n * Post-process spans emitted by the Vercel AI SDK.\n */\nfunction processEndedVercelAiSpan(span: SpanJSON): void {\n  const { data: attributes, origin } = span;\n\n  if (origin !== 'auto.vercelai.otel') {\n    return;\n  }\n\n  renameAttributeKey(attributes, AI_USAGE_COMPLETION_TOKENS_ATTRIBUTE, GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE);\n  renameAttributeKey(attributes, AI_USAGE_PROMPT_TOKENS_ATTRIBUTE, GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE);\n  renameAttributeKey(attributes, AI_USAGE_CACHED_INPUT_TOKENS_ATTRIBUTE, GEN_AI_USAGE_INPUT_TOKENS_CACHED_ATTRIBUTE);\n\n  if (\n    typeof attributes[GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE] === 'number' &&\n    typeof attributes[GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE] === 'number'\n  ) {\n    attributes['gen_ai.usage.total_tokens'] =\n      attributes[GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE] + attributes[GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE];\n  }\n\n  // Convert the available tools array to a JSON string\n  if (attributes[AI_PROMPT_TOOLS_ATTRIBUTE] && Array.isArray(attributes[AI_PROMPT_TOOLS_ATTRIBUTE])) {\n    attributes[AI_PROMPT_TOOLS_ATTRIBUTE] = convertAvailableToolsToJsonString(\n      attributes[AI_PROMPT_TOOLS_ATTRIBUTE] as unknown[],\n    );\n  }\n\n  // Rename AI SDK attributes to standardized gen_ai attributes\n  renameAttributeKey(attributes, AI_PROMPT_MESSAGES_ATTRIBUTE, 'gen_ai.request.messages');\n  renameAttributeKey(attributes, AI_RESPONSE_TEXT_ATTRIBUTE, 'gen_ai.response.text');\n  renameAttributeKey(attributes, AI_RESPONSE_TOOL_CALLS_ATTRIBUTE, 'gen_ai.response.tool_calls');\n  renameAttributeKey(attributes, AI_RESPONSE_OBJECT_ATTRIBUTE, 'gen_ai.response.object');\n  renameAttributeKey(attributes, AI_PROMPT_TOOLS_ATTRIBUTE, 'gen_ai.request.available_tools');\n\n  renameAttributeKey(attributes, AI_TOOL_CALL_ARGS_ATTRIBUTE, 'gen_ai.tool.input');\n  renameAttributeKey(attributes, AI_TOOL_CALL_RESULT_ATTRIBUTE, 'gen_ai.tool.output');\n\n  renameAttributeKey(attributes, AI_SCHEMA_ATTRIBUTE, 'gen_ai.request.schema');\n\n  addProviderMetadataToAttributes(attributes);\n\n  // Change attributes namespaced with `ai.X` to `vercel.ai.X`\n  for (const key of Object.keys(attributes)) {\n    if (key.startsWith('ai.')) {\n      renameAttributeKey(attributes, key, `vercel.${key}`);\n    }\n  }\n}\n\n/**\n * Renames an attribute key in the provided attributes object if the old key exists.\n * This function safely handles null and undefined values.\n */\nfunction renameAttributeKey(attributes: Record<string, unknown>, oldKey: string, newKey: string): void {\n  if (attributes[oldKey] != null) {\n    attributes[newKey] = attributes[oldKey];\n    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n    delete attributes[oldKey];\n  }\n}\n\nfunction processToolCallSpan(span: Span, attributes: SpanAttributes): void {\n  addOriginToSpan(span, 'auto.vercelai.otel');\n  span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.execute_tool');\n  renameAttributeKey(attributes, AI_TOOL_CALL_NAME_ATTRIBUTE, 'gen_ai.tool.name');\n  renameAttributeKey(attributes, AI_TOOL_CALL_ID_ATTRIBUTE, 'gen_ai.tool.call.id');\n\n  // Store the span in our global map using the tool call ID\n  // This allows us to capture tool errors and link them to the correct span\n  const toolCallId = attributes['gen_ai.tool.call.id'];\n\n  if (typeof toolCallId === 'string') {\n    toolCallSpanMap.set(toolCallId, span);\n  }\n\n  // https://opentelemetry.io/docs/specs/semconv/registry/attributes/gen-ai/#gen-ai-tool-type\n  if (!attributes['gen_ai.tool.type']) {\n    span.setAttribute('gen_ai.tool.type', 'function');\n  }\n  const toolName = attributes['gen_ai.tool.name'];\n  if (toolName) {\n    span.updateName(`execute_tool ${toolName}`);\n  }\n}\n\nfunction processGenerateSpan(span: Span, name: string, attributes: SpanAttributes): void {\n  addOriginToSpan(span, 'auto.vercelai.otel');\n\n  const nameWthoutAi = name.replace('ai.', '');\n  span.setAttribute('ai.pipeline.name', nameWthoutAi);\n  span.updateName(nameWthoutAi);\n\n  // If a telemetry name is set and the span represents a pipeline, use it as the operation name.\n  // This name can be set at the request level by adding `experimental_telemetry.functionId`.\n  const functionId = attributes[AI_TELEMETRY_FUNCTION_ID_ATTRIBUTE];\n  if (functionId && typeof functionId === 'string') {\n    span.updateName(`${nameWthoutAi} ${functionId}`);\n    span.setAttribute('gen_ai.function_id', functionId);\n  }\n\n  if (attributes[AI_PROMPT_ATTRIBUTE]) {\n    const truncatedPrompt = getTruncatedJsonString(attributes[AI_PROMPT_ATTRIBUTE] as string | string[]);\n    span.setAttribute('gen_ai.prompt', truncatedPrompt);\n  }\n  if (attributes[AI_MODEL_ID_ATTRIBUTE] && !attributes[GEN_AI_RESPONSE_MODEL_ATTRIBUTE]) {\n    span.setAttribute(GEN_AI_RESPONSE_MODEL_ATTRIBUTE, attributes[AI_MODEL_ID_ATTRIBUTE]);\n  }\n  span.setAttribute('ai.streaming', name.includes('stream'));\n\n  // Generate Spans\n  if (name === 'ai.generateText') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.invoke_agent');\n    return;\n  }\n\n  if (name === 'ai.generateText.doGenerate') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.generate_text');\n    span.updateName(`generate_text ${attributes[AI_MODEL_ID_ATTRIBUTE]}`);\n    return;\n  }\n\n  if (name === 'ai.streamText') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.invoke_agent');\n    return;\n  }\n\n  if (name === 'ai.streamText.doStream') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.stream_text');\n    span.updateName(`stream_text ${attributes[AI_MODEL_ID_ATTRIBUTE]}`);\n    return;\n  }\n\n  if (name === 'ai.generateObject') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.invoke_agent');\n    return;\n  }\n\n  if (name === 'ai.generateObject.doGenerate') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.generate_object');\n    span.updateName(`generate_object ${attributes[AI_MODEL_ID_ATTRIBUTE]}`);\n    return;\n  }\n\n  if (name === 'ai.streamObject') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.invoke_agent');\n    return;\n  }\n\n  if (name === 'ai.streamObject.doStream') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.stream_object');\n    span.updateName(`stream_object ${attributes[AI_MODEL_ID_ATTRIBUTE]}`);\n    return;\n  }\n\n  if (name === 'ai.embed') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.invoke_agent');\n    return;\n  }\n\n  if (name === 'ai.embed.doEmbed') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.embed');\n    span.updateName(`embed ${attributes[AI_MODEL_ID_ATTRIBUTE]}`);\n    return;\n  }\n\n  if (name === 'ai.embedMany') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.invoke_agent');\n    return;\n  }\n\n  if (name === 'ai.embedMany.doEmbed') {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.embed_many');\n    span.updateName(`embed_many ${attributes[AI_MODEL_ID_ATTRIBUTE]}`);\n    return;\n  }\n\n  if (name.startsWith('ai.stream')) {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'ai.run');\n    return;\n  }\n}\n\n/**\n * Add event processors to the given client to process Vercel AI spans.\n */\nexport function addVercelAiProcessors(client: Client): void {\n  client.on('spanStart', onVercelAiSpanStart);\n  // Note: We cannot do this on `spanEnd`, because the span cannot be mutated anymore at this point\n  client.addEventProcessor(Object.assign(vercelAiEventProcessor, { id: 'VercelAiEventProcessor' }));\n}\n\nfunction addProviderMetadataToAttributes(attributes: SpanAttributes): void {\n  const providerMetadata = attributes[AI_RESPONSE_PROVIDER_METADATA_ATTRIBUTE] as string | undefined;\n  if (providerMetadata) {\n    try {\n      const providerMetadataObject = JSON.parse(providerMetadata) as ProviderMetadata;\n      if (providerMetadataObject.openai) {\n        setAttributeIfDefined(\n          attributes,\n          GEN_AI_USAGE_INPUT_TOKENS_CACHED_ATTRIBUTE,\n          providerMetadataObject.openai.cachedPromptTokens,\n        );\n        setAttributeIfDefined(\n          attributes,\n          'gen_ai.usage.output_tokens.reasoning',\n          providerMetadataObject.openai.reasoningTokens,\n        );\n        setAttributeIfDefined(\n          attributes,\n          'gen_ai.usage.output_tokens.prediction_accepted',\n          providerMetadataObject.openai.acceptedPredictionTokens,\n        );\n        setAttributeIfDefined(\n          attributes,\n          'gen_ai.usage.output_tokens.prediction_rejected',\n          providerMetadataObject.openai.rejectedPredictionTokens,\n        );\n        setAttributeIfDefined(attributes, 'gen_ai.conversation.id', providerMetadataObject.openai.responseId);\n      }\n\n      if (providerMetadataObject.anthropic) {\n        const cachedInputTokens =\n          providerMetadataObject.anthropic.usage?.cache_read_input_tokens ??\n          providerMetadataObject.anthropic.cacheReadInputTokens;\n        setAttributeIfDefined(attributes, GEN_AI_USAGE_INPUT_TOKENS_CACHED_ATTRIBUTE, cachedInputTokens);\n\n        const cacheWriteInputTokens =\n          providerMetadataObject.anthropic.usage?.cache_creation_input_tokens ??\n          providerMetadataObject.anthropic.cacheCreationInputTokens;\n        setAttributeIfDefined(attributes, GEN_AI_USAGE_INPUT_TOKENS_CACHE_WRITE_ATTRIBUTE, cacheWriteInputTokens);\n      }\n\n      if (providerMetadataObject.bedrock?.usage) {\n        setAttributeIfDefined(\n          attributes,\n          GEN_AI_USAGE_INPUT_TOKENS_CACHED_ATTRIBUTE,\n          providerMetadataObject.bedrock.usage.cacheReadInputTokens,\n        );\n        setAttributeIfDefined(\n          attributes,\n          GEN_AI_USAGE_INPUT_TOKENS_CACHE_WRITE_ATTRIBUTE,\n          providerMetadataObject.bedrock.usage.cacheWriteInputTokens,\n        );\n      }\n\n      if (providerMetadataObject.deepseek) {\n        setAttributeIfDefined(\n          attributes,\n          GEN_AI_USAGE_INPUT_TOKENS_CACHED_ATTRIBUTE,\n          providerMetadataObject.deepseek.promptCacheHitTokens,\n        );\n        setAttributeIfDefined(\n          attributes,\n          'gen_ai.usage.input_tokens.cache_miss',\n          providerMetadataObject.deepseek.promptCacheMissTokens,\n        );\n      }\n    } catch {\n      // Ignore\n    }\n  }\n}\n\n/**\n * Sets an attribute only if the value is not null or undefined.\n */\nfunction setAttributeIfDefined(attributes: SpanAttributes, key: string, value: SpanAttributeValue | undefined): void {\n  if (value != null) {\n    attributes[key] = value;\n  }\n}\n"],"names":["SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","spanToJSON","AI_TOOL_CALL_NAME_ATTRIBUTE","AI_TOOL_CALL_ID_ATTRIBUTE","AI_MODEL_ID_ATTRIBUTE","AI_MODEL_PROVIDER_ATTRIBUTE","accumulateTokensForParent","applyAccumulatedTokens","AI_USAGE_COMPLETION_TOKENS_ATTRIBUTE","GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE","AI_USAGE_PROMPT_TOKENS_ATTRIBUTE","GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE","AI_USAGE_CACHED_INPUT_TOKENS_ATTRIBUTE","GEN_AI_USAGE_INPUT_TOKENS_CACHED_ATTRIBUTE","AI_PROMPT_TOOLS_ATTRIBUTE","convertAvailableToolsToJsonString","AI_PROMPT_MESSAGES_ATTRIBUTE","AI_RESPONSE_TEXT_ATTRIBUTE","AI_RESPONSE_TOOL_CALLS_ATTRIBUTE","AI_RESPONSE_OBJECT_ATTRIBUTE","AI_TOOL_CALL_ARGS_ATTRIBUTE","AI_TOOL_CALL_RESULT_ATTRIBUTE","AI_SCHEMA_ATTRIBUTE","SEMANTIC_ATTRIBUTE_SENTRY_OP","toolCallSpanMap","AI_TELEMETRY_FUNCTION_ID_ATTRIBUTE","AI_PROMPT_ATTRIBUTE","getTruncatedJsonString","GEN_AI_RESPONSE_MODEL_ATTRIBUTE","AI_RESPONSE_PROVIDER_METADATA_ATTRIBUTE","GEN_AI_USAGE_INPUT_TOKENS_CACHE_WRITE_ATTRIBUTE"],"mappings":"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"}