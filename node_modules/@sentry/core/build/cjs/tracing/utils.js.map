{"version":3,"file":"utils.js","sources":["../../../src/tracing/utils.ts"],"sourcesContent":["import type { Scope } from '../scope';\nimport type { Span } from '../types-hoist/span';\nimport { addNonEnumerableProperty } from '../utils/object';\nimport { GLOBAL_OBJ } from '../utils/worldwide';\n\nconst SCOPE_ON_START_SPAN_FIELD = '_sentryScope';\nconst ISOLATION_SCOPE_ON_START_SPAN_FIELD = '_sentryIsolationScope';\n\ntype ScopeWeakRef = { deref(): Scope | undefined } | Scope;\n\ntype SpanWithScopes = Span & {\n  [SCOPE_ON_START_SPAN_FIELD]?: Scope;\n  [ISOLATION_SCOPE_ON_START_SPAN_FIELD]?: ScopeWeakRef;\n};\n\n/** Wrap a scope with a WeakRef if available, falling back to a direct scope. */\nfunction wrapScopeWithWeakRef(scope: Scope): ScopeWeakRef {\n  try {\n    // @ts-expect-error - WeakRef is not available in all environments\n    const WeakRefClass = GLOBAL_OBJ.WeakRef;\n    if (typeof WeakRefClass === 'function') {\n      return new WeakRefClass(scope);\n    }\n  } catch {\n    // WeakRef not available or failed to create\n    // We'll fall back to a direct scope\n  }\n\n  return scope;\n}\n\n/** Try to unwrap a scope from a potential WeakRef wrapper. */\nfunction unwrapScopeFromWeakRef(scopeRef: ScopeWeakRef | undefined): Scope | undefined {\n  if (!scopeRef) {\n    return undefined;\n  }\n\n  if (typeof scopeRef === 'object' && 'deref' in scopeRef && typeof scopeRef.deref === 'function') {\n    try {\n      return scopeRef.deref();\n    } catch {\n      return undefined;\n    }\n  }\n\n  // Fallback to a direct scope\n  return scopeRef as Scope;\n}\n\n/** Store the scope & isolation scope for a span, which can the be used when it is finished. */\nexport function setCapturedScopesOnSpan(span: Span | undefined, scope: Scope, isolationScope: Scope): void {\n  if (span) {\n    addNonEnumerableProperty(span, ISOLATION_SCOPE_ON_START_SPAN_FIELD, wrapScopeWithWeakRef(isolationScope));\n    // We don't wrap the scope with a WeakRef here because webkit aggressively garbage collects\n    // and scopes are not held in memory for long periods of time.\n    addNonEnumerableProperty(span, SCOPE_ON_START_SPAN_FIELD, scope);\n  }\n}\n\n/**\n * Grabs the scope and isolation scope off a span that were active when the span was started.\n * If WeakRef was used and scopes have been garbage collected, returns undefined for those scopes.\n */\nexport function getCapturedScopesOnSpan(span: Span): { scope?: Scope; isolationScope?: Scope } {\n  const spanWithScopes = span as SpanWithScopes;\n\n  return {\n    scope: spanWithScopes[SCOPE_ON_START_SPAN_FIELD],\n    isolationScope: unwrapScopeFromWeakRef(spanWithScopes[ISOLATION_SCOPE_ON_START_SPAN_FIELD]),\n  };\n}\n"],"names":["GLOBAL_OBJ","addNonEnumerableProperty"],"mappings":";;;;;AAKA,MAAM,yBAAA,GAA4B,cAAc;AAChD,MAAM,mCAAA,GAAsC,uBAAuB;;AASnE;AACA,SAAS,oBAAoB,CAAC,KAAK,EAAuB;AAC1D,EAAE,IAAI;AACN;AACA,IAAI,MAAM,YAAA,GAAeA,oBAAU,CAAC,OAAO;AAC3C,IAAI,IAAI,OAAO,YAAA,KAAiB,UAAU,EAAE;AAC5C,MAAM,OAAO,IAAI,YAAY,CAAC,KAAK,CAAC;AACpC,IAAI;AACJ,EAAE,EAAE,MAAM;AACV;AACA;AACA,EAAE;;AAEF,EAAE,OAAO,KAAK;AACd;;AAEA;AACA,SAAS,sBAAsB,CAAC,QAAQ,EAA+C;AACvF,EAAE,IAAI,CAAC,QAAQ,EAAE;AACjB,IAAI,OAAO,SAAS;AACpB,EAAE;;AAEF,EAAE,IAAI,OAAO,QAAA,KAAa,YAAY,OAAA,IAAW,QAAA,IAAY,OAAO,QAAQ,CAAC,KAAA,KAAU,UAAU,EAAE;AACnG,IAAI,IAAI;AACR,MAAM,OAAO,QAAQ,CAAC,KAAK,EAAE;AAC7B,IAAI,EAAE,MAAM;AACZ,MAAM,OAAO,SAAS;AACtB,IAAI;AACJ,EAAE;;AAEF;AACA,EAAE,OAAO,QAAA;AACT;;AAEA;AACO,SAAS,uBAAuB,CAAC,IAAI,EAAoB,KAAK,EAAS,cAAc,EAAe;AAC3G,EAAE,IAAI,IAAI,EAAE;AACZ,IAAIC,+BAAwB,CAAC,IAAI,EAAE,mCAAmC,EAAE,oBAAoB,CAAC,cAAc,CAAC,CAAC;AAC7G;AACA;AACA,IAAIA,+BAAwB,CAAC,IAAI,EAAE,yBAAyB,EAAE,KAAK,CAAC;AACpE,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACO,SAAS,uBAAuB,CAAC,IAAI,EAAmD;AAC/F,EAAE,MAAM,cAAA,GAAiB,IAAA;;AAEzB,EAAE,OAAO;AACT,IAAI,KAAK,EAAE,cAAc,CAAC,yBAAyB,CAAC;AACpD,IAAI,cAAc,EAAE,sBAAsB,CAAC,cAAc,CAAC,mCAAmC,CAAC,CAAC;AAC/F,GAAG;AACH;;;;;"}