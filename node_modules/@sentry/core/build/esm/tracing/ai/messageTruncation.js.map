{"version":3,"file":"messageTruncation.js","sources":["../../../../src/tracing/ai/messageTruncation.ts"],"sourcesContent":["/**\n * Default maximum size in bytes for GenAI messages.\n * Messages exceeding this limit will be truncated.\n */\nexport const DEFAULT_GEN_AI_MESSAGES_BYTE_LIMIT = 20000;\n\n/**\n * Message format used by OpenAI and Anthropic APIs.\n */\ntype ContentMessage = {\n  [key: string]: unknown;\n  content: string;\n};\n\n/**\n * Message format used by Google GenAI API.\n * Parts can be strings or objects with a text property.\n */\ntype PartsMessage = {\n  [key: string]: unknown;\n  parts: Array<string | { text: string }>;\n};\n\n/**\n * A part in a Google GenAI message that contains text.\n */\ntype TextPart = string | { text: string };\n\n/**\n * Calculate the UTF-8 byte length of a string.\n */\nconst utf8Bytes = (text: string): number => {\n  return new TextEncoder().encode(text).length;\n};\n\n/**\n * Calculate the UTF-8 byte length of a value's JSON representation.\n */\nconst jsonBytes = (value: unknown): number => {\n  return utf8Bytes(JSON.stringify(value));\n};\n\n/**\n * Truncate a string to fit within maxBytes when encoded as UTF-8.\n * Uses binary search for efficiency with multi-byte characters.\n *\n * @param text - The string to truncate\n * @param maxBytes - Maximum byte length (UTF-8 encoded)\n * @returns Truncated string that fits within maxBytes\n */\nfunction truncateTextByBytes(text: string, maxBytes: number): string {\n  if (utf8Bytes(text) <= maxBytes) {\n    return text;\n  }\n\n  let low = 0;\n  let high = text.length;\n  let bestFit = '';\n\n  while (low <= high) {\n    const mid = Math.floor((low + high) / 2);\n    const candidate = text.slice(0, mid);\n    const byteSize = utf8Bytes(candidate);\n\n    if (byteSize <= maxBytes) {\n      bestFit = candidate;\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n\n  return bestFit;\n}\n\n/**\n * Extract text content from a Google GenAI message part.\n * Parts are either plain strings or objects with a text property.\n *\n * @returns The text content\n */\nfunction getPartText(part: TextPart): string {\n  if (typeof part === 'string') {\n    return part;\n  }\n  return part.text;\n}\n\n/**\n * Create a new part with updated text content while preserving the original structure.\n *\n * @param part - Original part (string or object)\n * @param text - New text content\n * @returns New part with updated text\n */\nfunction withPartText(part: TextPart, text: string): TextPart {\n  if (typeof part === 'string') {\n    return text;\n  }\n  return { ...part, text };\n}\n\n/**\n * Check if a message has the OpenAI/Anthropic content format.\n */\nfunction isContentMessage(message: unknown): message is ContentMessage {\n  return (\n    message !== null &&\n    typeof message === 'object' &&\n    'content' in message &&\n    typeof (message as ContentMessage).content === 'string'\n  );\n}\n\n/**\n * Check if a message has the Google GenAI parts format.\n */\nfunction isPartsMessage(message: unknown): message is PartsMessage {\n  return (\n    message !== null &&\n    typeof message === 'object' &&\n    'parts' in message &&\n    Array.isArray((message as PartsMessage).parts) &&\n    (message as PartsMessage).parts.length > 0\n  );\n}\n\n/**\n * Truncate a message with `content: string` format (OpenAI/Anthropic).\n *\n * @param message - Message with content property\n * @param maxBytes - Maximum byte limit\n * @returns Array with truncated message, or empty array if it doesn't fit\n */\nfunction truncateContentMessage(message: ContentMessage, maxBytes: number): unknown[] {\n  // Calculate overhead (message structure without content)\n  const emptyMessage = { ...message, content: '' };\n  const overhead = jsonBytes(emptyMessage);\n  const availableForContent = maxBytes - overhead;\n\n  if (availableForContent <= 0) {\n    return [];\n  }\n\n  const truncatedContent = truncateTextByBytes(message.content, availableForContent);\n  return [{ ...message, content: truncatedContent }];\n}\n\n/**\n * Truncate a message with `parts: [...]` format (Google GenAI).\n * Keeps as many complete parts as possible, only truncating the first part if needed.\n *\n * @param message - Message with parts array\n * @param maxBytes - Maximum byte limit\n * @returns Array with truncated message, or empty array if it doesn't fit\n */\nfunction truncatePartsMessage(message: PartsMessage, maxBytes: number): unknown[] {\n  const { parts } = message;\n\n  // Calculate overhead by creating empty text parts\n  const emptyParts = parts.map(part => withPartText(part, ''));\n  const overhead = jsonBytes({ ...message, parts: emptyParts });\n  let remainingBytes = maxBytes - overhead;\n\n  if (remainingBytes <= 0) {\n    return [];\n  }\n\n  // Include parts until we run out of space\n  const includedParts: TextPart[] = [];\n\n  for (const part of parts) {\n    const text = getPartText(part);\n    const textSize = utf8Bytes(text);\n\n    if (textSize <= remainingBytes) {\n      // Part fits: include it as-is\n      includedParts.push(part);\n      remainingBytes -= textSize;\n    } else if (includedParts.length === 0) {\n      // First part doesn't fit: truncate it\n      const truncated = truncateTextByBytes(text, remainingBytes);\n      if (truncated) {\n        includedParts.push(withPartText(part, truncated));\n      }\n      break;\n    } else {\n      // Subsequent part doesn't fit: stop here\n      break;\n    }\n  }\n\n  return includedParts.length > 0 ? [{ ...message, parts: includedParts }] : [];\n}\n\n/**\n * Truncate a single message to fit within maxBytes.\n *\n * Supports two message formats:\n * - OpenAI/Anthropic: `{ ..., content: string }`\n * - Google GenAI: `{ ..., parts: Array<string | {text: string} | non-text> }`\n *\n * @param message - The message to truncate\n * @param maxBytes - Maximum byte limit for the message\n * @returns Array containing the truncated message, or empty array if truncation fails\n */\nfunction truncateSingleMessage(message: unknown, maxBytes: number): unknown[] {\n  if (!message || typeof message !== 'object') {\n    return [];\n  }\n\n  if (isContentMessage(message)) {\n    return truncateContentMessage(message, maxBytes);\n  }\n\n  if (isPartsMessage(message)) {\n    return truncatePartsMessage(message, maxBytes);\n  }\n\n  // Unknown message format: cannot truncate safely\n  return [];\n}\n\n/**\n * Truncate an array of messages to fit within a byte limit.\n *\n * Strategy:\n * - Keeps the newest messages (from the end of the array)\n * - Uses O(n) algorithm: precompute sizes once, then find largest suffix under budget\n * - If no complete messages fit, attempts to truncate the newest single message\n *\n * @param messages - Array of messages to truncate\n * @param maxBytes - Maximum total byte limit for all messages\n * @returns Truncated array of messages\n *\n * @example\n * ```ts\n * const messages = [msg1, msg2, msg3, msg4]; // newest is msg4\n * const truncated = truncateMessagesByBytes(messages, 10000);\n * // Returns [msg3, msg4] if they fit, or [msg4] if only it fits, etc.\n * ```\n */\nexport function truncateMessagesByBytes(messages: unknown[], maxBytes: number): unknown[] {\n  // Early return for empty or invalid input\n  if (!Array.isArray(messages) || messages.length === 0) {\n    return messages;\n  }\n\n  // Fast path: if all messages fit, return as-is\n  const totalBytes = jsonBytes(messages);\n  if (totalBytes <= maxBytes) {\n    return messages;\n  }\n\n  // Precompute each message's JSON size once for efficiency\n  const messageSizes = messages.map(jsonBytes);\n\n  // Find the largest suffix (newest messages) that fits within the budget\n  let bytesUsed = 0;\n  let startIndex = messages.length; // Index where the kept suffix starts\n\n  for (let i = messages.length - 1; i >= 0; i--) {\n    const messageSize = messageSizes[i];\n\n    if (messageSize && bytesUsed + messageSize > maxBytes) {\n      // Adding this message would exceed the budget\n      break;\n    }\n\n    if (messageSize) {\n      bytesUsed += messageSize;\n    }\n    startIndex = i;\n  }\n\n  // If no complete messages fit, try truncating just the newest message\n  if (startIndex === messages.length) {\n    const newestMessage = messages[messages.length - 1];\n    return truncateSingleMessage(newestMessage, maxBytes);\n  }\n\n  // Return the suffix that fits\n  return messages.slice(startIndex);\n}\n\n/**\n * Truncate GenAI messages using the default byte limit.\n *\n * Convenience wrapper around `truncateMessagesByBytes` with the default limit.\n *\n * @param messages - Array of messages to truncate\n * @returns Truncated array of messages\n */\nexport function truncateGenAiMessages(messages: unknown[]): unknown[] {\n  return truncateMessagesByBytes(messages, DEFAULT_GEN_AI_MESSAGES_BYTE_LIMIT);\n}\n\n/**\n * Truncate GenAI string input using the default byte limit.\n *\n * @param input - The string to truncate\n * @returns Truncated string\n */\nexport function truncateGenAiStringInput(input: string): string {\n  return truncateTextByBytes(input, DEFAULT_GEN_AI_MESSAGES_BYTE_LIMIT);\n}\n"],"names":[],"mappings":"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"}