"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const yaml_1 = __importDefault(require("yaml"));
const FSHLogger_1 = require("../utils/FSHLogger");
const parseCodeLexeme_1 = require("./parseCodeLexeme");
const MINIMAL_CONFIG_PROPERTIES = ['canonical', 'fhirVersion'];
// Properties that are only relevant when an IG is going to be generated from output, and have no informational purpose
const MINIMAL_IG_ONLY_PROPERTIES = ['id', 'name', 'status', 'copyrightYear', 'releaseLabel'];
const IG_ONLY_PROPERTIES = [
    'contained',
    'extension',
    'modifierExtension',
    'groups',
    'resources',
    'pages',
    'parameters',
    'template',
    'templates',
    'menu',
    'copyrightyear',
    'copyrightYear',
    'releaseLabel',
    'releaselabel'
];
/**
 * Imports the YAML Configuration format (as a YAML string or already parsed JSON) and returns
 * the normalized FSH Configuration object.
 * @param {YAMLConfiguration | string} yaml - the YAML config as a string or JSON document
 * @param {string} file - the path to the configuration file (used for logging source info)
 * @returns {Configuration} - the FSH configuration representing the parsed config
 */
function importConfiguration(yaml, file) {
    var _a, _b, _c, _d, _e, _f;
    if (typeof yaml === 'string') {
        let parsed;
        try {
            parsed = yaml_1.default.parse(yaml);
        }
        catch (e) {
            FSHLogger_1.logger.error(`Error parsing configuration: ${e.message}.`, { file });
            throw new Error('Invalid configuration YAML');
        }
        if (typeof parsed !== 'object' || parsed === null) {
            FSHLogger_1.logger.error('Configuration is not a valid YAML object.', { file });
            throw new Error('Invalid configuration YAML');
        }
        return importConfiguration(parsed, file);
    }
    // There are a few properties that are absolutely required if we are to have *any* success at all
    const minimalProperties = yaml.FSHOnly
        ? MINIMAL_CONFIG_PROPERTIES
        : [...MINIMAL_CONFIG_PROPERTIES, ...MINIMAL_IG_ONLY_PROPERTIES];
    const missingProperties = minimalProperties.filter((p) => yaml[p] == null || (Array.isArray(yaml[p]) && yaml[p].length === 0));
    // the copyrightYear and releaseLabel properties permit alternate spellings as all lowercase,
    // so if only those are missing, check for the lowercase version before logging an error.
    if (missingProperties.includes('copyrightYear') && yaml.copyrightyear) {
        missingProperties.splice(missingProperties.indexOf('copyrightYear'), 1);
    }
    if (missingProperties.includes('releaseLabel') && yaml.releaselabel) {
        missingProperties.splice(missingProperties.indexOf('releaseLabel'), 1);
    }
    if (missingProperties.length > 0) {
        FSHLogger_1.logger.error(`SUSHI minimally requires the following configuration properties to ${yaml.FSHOnly ? 'start processing FSH' : 'generate an IG'}: ` +
            minimalProperties.join(', ') +
            '.', { file });
        throw new Error('Minimal config not met');
    }
    const config = {
        filePath: file,
        canonical: yaml.canonical,
        id: yaml.id,
        meta: parseMeta(yaml.meta, file),
        implicitRules: yaml.implicitRules,
        language: parseSimpleCode(yaml.language, 'language', file),
        text: parseText(yaml.text, file),
        contained: yaml.contained,
        extension: yaml.extension,
        modifierExtension: yaml.modifierExtension,
        url: (_a = yaml.url) !== null && _a !== void 0 ? _a : `${yaml.canonical}/ImplementationGuide/${yaml.id}`,
        version: normalizeToString(yaml.version),
        name: required(yaml.name, 'name', file),
        title: yaml.title,
        status: parseCodeWithRequiredValues(required(yaml.status, 'status', file), ['draft', 'active', 'retired', 'unknown'], 'status', file),
        experimental: yaml.experimental,
        date: normalizeToString(yaml.date),
        publisher: (_c = (_b = normalizeToArray(yaml.publisher)) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.name,
        contact: parseContact(yaml, file),
        description: yaml.description,
        useContext: parseUsageContext(yaml.useContext, file),
        jurisdiction: parseJurisdiction(yaml.jurisdiction, file),
        copyright: yaml.copyright,
        packageId: (_d = yaml.packageId) !== null && _d !== void 0 ? _d : yaml.id,
        license: parseSimpleCode(yaml.license, 'license', file),
        fhirVersion: (_e = normalizeToArray(yaml.fhirVersion)) === null || _e === void 0 ? void 0 : _e.map(v => parseSimpleCode(v, 'fhirVersion', file)),
        dependencies: parseDependencies(yaml.dependencies),
        global: parseGlobal(yaml.global),
        groups: parseGroups(yaml.groups),
        resources: parseResources(yaml.resources, file),
        pages: parsePages(yaml.pages, file),
        parameters: parseParameters(yaml, yaml.FSHOnly, file),
        templates: parseTemplates(yaml.templates, file),
        template: yaml.template,
        menu: parseMenu(yaml.menu),
        history: parseHistory(yaml, file),
        indexPageContent: yaml.indexPageContent,
        FSHOnly: (_f = yaml.FSHOnly) !== null && _f !== void 0 ? _f : false
    };
    // Remove all undefined variables (mainly helpful for test assertions)
    removeUndefinedValues(config);
    if (yaml.FSHOnly) {
        // If no IG is being generated, emit warning when IG specific properties are used in config
        const unusedProperties = Object.keys(yaml).filter((p) => IG_ONLY_PROPERTIES.includes(p));
        if (unusedProperties.length > 0) {
            FSHLogger_1.logger.warn(`The FSHOnly property is set to true, so no output specific to IG creation will be generated. The following properties are unused and only relevant for IG creation: ${unusedProperties.join(', ')}.`, { file });
        }
    }
    return config;
}
exports.importConfiguration = importConfiguration;
function required(value, property, file) {
    if (value == null || (Array.isArray(value) && value.length === 0)) {
        FSHLogger_1.logger.error(`Configuration missing required property: ${property}`, { file });
    }
    return value;
}
function normalizeToString(yamlValue) {
    if (yamlValue == null) {
        return;
    }
    return `${yamlValue}`;
}
function normalizeToArray(yamlValue) {
    if (yamlValue == null) {
        return;
    }
    return Array.isArray(yamlValue) ? yamlValue : [yamlValue];
}
function parseSimpleCode(yamlCode, property, file) {
    var _a;
    return (yamlCode === null || yamlCode === void 0 ? void 0 : yamlCode.startsWith('#')) ? (_a = parseFshCode(yamlCode, property, file)) === null || _a === void 0 ? void 0 : _a.code : yamlCode;
}
function parseFshCode(yamlCode, property, file) {
    // If it has a display, we need to split it out and handle it separately
    const m = yamlCode.match(/^(.*\S)(\s+"(([^"]|\\")*)")$/);
    if (m) {
        const concept = parseCodeLexeme_1.parseCodeLexeme(m[1]);
        concept.display = m[3].replace(/\\"/g, '"');
        return concept;
    }
    const concept = parseCodeLexeme_1.parseCodeLexeme(yamlCode);
    if (concept.system == null && concept.code === '') {
        FSHLogger_1.logger.error(`Invalid code format for ${property}: ${yamlCode}`, { file });
        // don't return an invalid code
        return;
    }
    return concept;
}
function parseCodingArray(codings, property, file) {
    if (codings == null) {
        return;
    }
    const result = codings === null || codings === void 0 ? void 0 : codings.map(c => parseCoding(c, property, file)).filter(c => c != null);
    if (result.length === 0 && codings.length > 0) {
        // in the case that all inputs were invalid, return undefined instead of empty array
        return;
    }
    return result;
}
function parseCoding(coding, property, file) {
    var _a;
    if (coding == null) {
        return;
    }
    if (typeof coding === 'string') {
        return (_a = parseFshCode(coding, property, file)) === null || _a === void 0 ? void 0 : _a.toFHIRCoding();
    }
    // It's a coding object
    const fixed = Object.assign(Object.assign({}, coding), { version: normalizeToString(coding.version), code: parseSimpleCode(coding.code, property, file) });
    return removeUndefinedValues(fixed);
}
function parseCodeableConceptArray(concepts, property, file) {
    if (concepts == null) {
        return;
    }
    const result = concepts === null || concepts === void 0 ? void 0 : concepts.map(c => parseCodeableConcept(c, property, file)).filter(c => c != null);
    if (result.length === 0 && concepts.length > 0) {
        // in the case that all inputs were invalid, return undefined instead of empty array
        return;
    }
    return result;
}
function parseCodeableConcept(concept, property, file) {
    if (concept == null) {
        return;
    }
    if (typeof concept === 'string') {
        const coding = parseCoding(concept, property, file);
        if (coding == null) {
            // return undefined instead of an empty concept
            return;
        }
        return {
            coding: [coding]
        };
    }
    // It's a CodeableConcept object
    const fixed = Object.assign(Object.assign({}, concept), { coding: parseCodingArray(concept.coding, property, file) });
    return removeUndefinedValues(fixed);
}
function parseCodeWithRequiredValues(yamlCode, allowedValues, property, file) {
    if (yamlCode == null) {
        return;
    }
    const code = parseSimpleCode(yamlCode, property, file);
    const match = allowedValues.find(c => c === code);
    if (match) {
        return match;
    }
    FSHLogger_1.logger.error(`Invalid ${property} value: '${code}'. Must be one of: ${allowedValues
        .map(c => `'${c}'`)
        .join(',')}.`, {
        file
    });
}
function parseQuantity(yamlQuantity, property, file) {
    if (yamlQuantity == null) {
        return;
    }
    if (typeof yamlQuantity === 'string') {
        const m = yamlQuantity.match(/^(\d*(\.\d+)?)(\s+'([^']+)')?$/);
        if (m == null) {
            FSHLogger_1.logger.error(`Invalid ${property} value: ${yamlQuantity}`, { file });
            return;
        }
        const quantity = {
            value: parseFloat(m[1])
        };
        if (m[4] && m[4].length > 0) {
            quantity.system = 'http://unitsofmeasure.org';
            quantity.code = m[4];
        }
        return quantity;
    }
    const quantity = Object.assign(Object.assign({}, yamlQuantity), { code: parseSimpleCode(yamlQuantity.code, `${property}.code`, file), comparator: parseCodeWithRequiredValues(yamlQuantity.comparator, ['<', '<=', '>=', '>'], `${property}.comparator`, file) });
    removeUndefinedValues(quantity);
    return quantity;
}
function parseRange(yamlRange, property, file) {
    if (yamlRange == null) {
        return;
    }
    const range = Object.assign(Object.assign({}, yamlRange), { low: parseQuantity(yamlRange.low, `${property}.low`, file), high: parseQuantity(yamlRange.high, `${property}.high`, file) });
    removeUndefinedValues(range);
    return range;
}
function parseReference(yamlReference, property, file) {
    if (yamlReference == null) {
        return;
    }
    const reference = Object.assign(Object.assign({}, yamlReference), { identifier: parseIdentifier(yamlReference.identifier, `${property}.identifier`, file) });
    removeUndefinedValues(reference);
    return reference;
}
function parseIdentifier(yamlIdentifier, property, file) {
    if (yamlIdentifier == null) {
        return;
    }
    const identifier = Object.assign(Object.assign({}, yamlIdentifier), { use: parseCodeWithRequiredValues(yamlIdentifier.use, ['usual', 'official', 'temp', 'secondary', 'old'], `${property}.use`, file), type: parseCodeableConcept(yamlIdentifier.type, `${property}.type`, file), assigner: parseReference(yamlIdentifier.assigner, `${property}.assigner`, file) });
    removeUndefinedValues(identifier);
    return identifier;
}
function parseMeta(yamlMeta, file) {
    if (yamlMeta == null) {
        return;
    }
    const fixed = Object.assign(Object.assign({}, yamlMeta), { security: parseCodingArray(yamlMeta.security, 'meta.security', file), tag: parseCodingArray(yamlMeta.tag, 'meta.tag', file) });
    return removeUndefinedValues(fixed);
}
function parseText(yamlText, file) {
    if (yamlText == null) {
        return;
    }
    const fixed = Object.assign(Object.assign({}, yamlText), { status: parseCodeWithRequiredValues(yamlText.status, ['generated', 'extensions', 'additional', 'empty'], 'text.status', file) });
    return removeUndefinedValues(fixed);
}
function parseContact(yamlConfig, file) {
    const contacts = [];
    const publishers = normalizeToArray(yamlConfig.publisher);
    if (publishers) {
        publishers.forEach((p, i) => {
            const contact = { name: p.name };
            if (p.url || p.email) {
                contact.telecom = [];
                if (p.url) {
                    contact.telecom.push({ system: 'url', value: p.url });
                }
                if (p.email) {
                    contact.telecom.push({ system: 'email', value: p.email });
                }
            }
            else if (i === 0) {
                // This was the first publisher and there was no additional contact detail, so skip it
                return;
            }
            contacts.push(contact);
        });
    }
    if (yamlConfig.contact) {
        contacts.push(...normalizeToArray(yamlConfig.contact).map(yamlContact => {
            const contact = Object.assign(Object.assign({}, yamlContact), { telecom: normalizeToArray(yamlContact.telecom).map(yamlTelecom => {
                    const contactPoint = Object.assign(Object.assign({}, yamlTelecom), { system: parseCodeWithRequiredValues(yamlTelecom.system, ['phone', 'fax', 'email', 'pager', 'url', 'sms', 'other'], 'contact.telecom.system', file), use: parseCodeWithRequiredValues(yamlTelecom.use, ['home', 'work', 'temp', 'old', 'mobile'], 'contact.telecom.use', file) });
                    removeUndefinedValues(contactPoint);
                    return contactPoint;
                }) });
            if (contact.telecom.length === 0) {
                delete contact.telecom;
            }
            return contact;
        }));
    }
    if (contacts.length === 0) {
        return;
    }
    return contacts;
}
function parseUsageContext(yamlUsageContext, file) {
    var _a;
    return (_a = normalizeToArray(yamlUsageContext)) === null || _a === void 0 ? void 0 : _a.map(yaml => {
        const usageContext = {
            code: parseCoding(required(yaml.code, 'useContext.code', file), 'useContext.code', file),
            valueCodeableConcept: parseCodeableConcept(yaml.valueCodeableConcept, 'useContext.valueCodeableConcept', file),
            valueQuantity: parseQuantity(yaml.valueQuantity, 'useContext.valueQuantity', file),
            valueRange: parseRange(yaml.valueRange, 'useContext.valueRange', file),
            valueReference: parseReference(yaml.valueReference, 'useContext.valueReference', file)
        };
        const valueFields = [
            'valueCodeableConcept',
            'valueQuantity',
            'valueRange',
            'valueReference'
        ].filter((v) => yaml[v] != null);
        if (valueFields.length === 0) {
            // at least one is required, so force the 'required' error
            required(undefined, 'useContext.value[x]', file);
        }
        else if (valueFields.length > 1) {
            // more than one value is not allowed since it is a value[x] choice
            FSHLogger_1.logger.error(`Only one useContext.value[x] is allowed but found multiple: ${valueFields.join(', ')}`, {
                file
            });
        }
        removeUndefinedValues(usageContext);
        return usageContext;
    });
}
function parseJurisdiction(yamlJurisdiction, file) {
    return parseCodeableConceptArray(normalizeToArray(yamlJurisdiction), 'jurisdiction', file);
}
function parseDependencies(yamlDependencies) {
    if (yamlDependencies == null) {
        return;
    }
    return Object.entries(yamlDependencies).map(([packageId, versionOrDetails]) => {
        if (typeof versionOrDetails === 'string' || typeof versionOrDetails === 'number') {
            return { packageId, version: `${versionOrDetails}` };
        }
        else if (versionOrDetails == null) {
            // this is an error condition, but we'll just make it an incomplete dependency and
            // handle the error later
            return { packageId };
        }
        // else it's the complex object
        return removeUndefinedValues({
            id: versionOrDetails.id,
            packageId,
            uri: versionOrDetails.uri,
            version: typeof versionOrDetails.version === 'string' || typeof versionOrDetails.version === 'number'
                ? `${versionOrDetails.version}`
                : undefined
        });
    });
}
function parseGlobal(yamlGlobal) {
    if (yamlGlobal == null) {
        return;
    }
    const global = [];
    for (const [type, profiles] of Object.entries(yamlGlobal)) {
        normalizeToArray(profiles).forEach(profile => global.push({ type, profile }));
    }
    return global;
}
function parseGroups(yamlGroups) {
    if (yamlGroups == null) {
        return;
    }
    return Object.entries(yamlGroups).map(([name, details]) => {
        return Object.assign({ name }, details);
    });
}
function parseResources(yamlResources, file) {
    if (yamlResources == null) {
        return;
    }
    return Object.entries(yamlResources).map(([reference, details]) => {
        var _a;
        if (details === 'omit' || details === '#omit') {
            return { reference: { reference }, omit: true };
        }
        return Object.assign(Object.assign({ reference: { reference } }, details), { fhirVersion: (_a = normalizeToArray(details.fhirVersion)) === null || _a === void 0 ? void 0 : _a.map(v => parseSimpleCode(v, `resource[${reference}].fhirVersion`, file)) });
    });
}
function parsePages(yamlPages, file) {
    if (yamlPages == null) {
        return;
    }
    return Object.entries(yamlPages).map(([nameUrl, details]) => {
        return parsePage(nameUrl, details, `pages[${nameUrl}]`, file);
    });
}
function parsePage(nameUrl, details, property, file) {
    const page = { nameUrl };
    if (details === null || details === void 0 ? void 0 : details.title) {
        page.title = details.title;
    }
    if (details === null || details === void 0 ? void 0 : details.generation) {
        page.generation = parseCodeWithRequiredValues(details.generation, ['html', 'markdown', 'xml', 'generated'], `${property}.generation`, file);
    }
    if (details != null) {
        Object.entries(details).forEach(([key, value]) => {
            if (key == 'title' || key == 'generation') {
                return;
            }
            if (page.page == null) {
                page.page = [];
            }
            page.page.push(parsePage(key, value, `${property}[${key}]`, file));
        });
    }
    return page;
}
function parseParameters(yamlConfig, FSHOnly, file) {
    var _a, _b, _c, _d;
    const parameters = [];
    // copyrightYear and releaseLabel are only required when generating an IG
    const copyrightYear = FSHOnly
        ? (_a = yamlConfig.copyrightYear) !== null && _a !== void 0 ? _a : yamlConfig.copyrightyear : required((_b = yamlConfig.copyrightYear) !== null && _b !== void 0 ? _b : yamlConfig.copyrightyear, 'copyrightYear', file);
    const releaseLabel = FSHOnly
        ? (_c = yamlConfig.releaseLabel) !== null && _c !== void 0 ? _c : yamlConfig.releaselabel : required((_d = yamlConfig.releaseLabel) !== null && _d !== void 0 ? _d : yamlConfig.releaselabel, 'releaseLabel', file);
    if (copyrightYear) {
        parameters.push({
            code: 'copyrightyear',
            value: copyrightYear.toString()
        });
    }
    if (releaseLabel) {
        parameters.push({
            code: 'releaselabel',
            value: releaseLabel
        });
    }
    if (yamlConfig.parameters) {
        for (const [code, values] of Object.entries(yamlConfig.parameters)) {
            normalizeToArray(values).forEach(value => parameters.push({ code, value: `${value}` }));
        }
    }
    else if (parameters.length === 0) {
        return; // return undefined rather than an empty []
    }
    return parameters;
}
function parseTemplates(yamlTemplates, file) {
    var _a;
    return (_a = normalizeToArray(yamlTemplates)) === null || _a === void 0 ? void 0 : _a.map(t => {
        const template = Object.assign(Object.assign({}, t), { code: parseSimpleCode(required(t.code, 'templates.code', file), 'templates.code', file), source: required(t.source, 'templates.source', file) });
        removeUndefinedValues(template);
        return template;
    });
}
function parseMenu(yamlMenu) {
    if (yamlMenu == null) {
        return;
    }
    return Object.entries(yamlMenu).map(([name, value]) => {
        const item = { name };
        if (typeof value === 'string') {
            // Set menu item attributes based on keywords
            if (value.includes('new-tab ')) {
                item.openInNewTab = true;
                value = value.replace('new-tab', '');
            }
            if (value.includes('external ')) {
                item.isExternal = true;
                value = value.replace('external', '');
            }
            // Trim off any white space left after using keywords. URL is remaining value.
            item.url = value.trim();
        }
        else {
            item.subMenu = parseMenu(value);
        }
        return item;
    });
}
function parseHistory(yamlConfig, file) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const yamlHistory = yamlConfig.history;
    if (yamlHistory == null) {
        return;
    }
    const history = {
        'package-id': (_b = (_a = yamlHistory['package-id']) !== null && _a !== void 0 ? _a : yamlConfig.packageId) !== null && _b !== void 0 ? _b : yamlConfig.id,
        canonical: (_c = yamlHistory.canonical) !== null && _c !== void 0 ? _c : yamlConfig.canonical,
        title: (_d = yamlHistory.title) !== null && _d !== void 0 ? _d : yamlConfig.title,
        introduction: (_e = yamlHistory.introduction) !== null && _e !== void 0 ? _e : yamlConfig.description,
        list: []
    };
    if (yamlHistory.current) {
        if (typeof yamlHistory.current === 'string') {
            history.list.push({
                version: 'current',
                desc: 'Continuous Integration Build (latest in version control)',
                path: yamlHistory.current,
                status: 'ci-build',
                current: true
            });
        }
        else {
            history.list.push({
                version: 'current',
                date: normalizeToString(yamlHistory.current.date),
                desc: (_f = yamlHistory.current.desc) !== null && _f !== void 0 ? _f : 'Continuous Integration Build (latest in version control)',
                path: required(yamlHistory.current.path, 'history[current].path', file),
                changes: yamlHistory.current.changes,
                status: parseCodeWithRequiredValues((_g = yamlHistory.current.status) !== null && _g !== void 0 ? _g : 'ci-build', allowedHistoryStatus, 'history[current].status', file),
                sequence: yamlHistory.current.sequence,
                fhirversion: yamlHistory.current.fhirversion,
                current: (_h = yamlHistory.current.current) !== null && _h !== void 0 ? _h : true
            });
        }
    }
    for (const [key, value] of Object.entries(yamlHistory)) {
        if (['package-id', 'canonical', 'title', 'introduction', 'current'].indexOf(key) !== -1) {
            continue;
        }
        const item = value;
        history.list.push({
            version: key,
            date: required(item.date, `history[${key}].date`, file),
            desc: required(item.desc, `history[${key}].desc`, file),
            path: required(item.path, `history[${key}].path`, file),
            changes: item.changes,
            status: parseCodeWithRequiredValues(required(item.status, `history[${key}].status`, file), allowedHistoryStatus, `history[${key}].status`, file),
            sequence: required(item.sequence, `history[${key}].sequence`, file),
            fhirversion: required(item.fhirversion, `history[${key}].fhirVersion`, file),
            current: item.current
        });
    }
    history.list.forEach(item => removeUndefinedValues(item));
    return history;
}
const allowedHistoryStatus = [
    'ci-build',
    'preview',
    'ballot',
    'trial-use',
    'update',
    'normative',
    'trial-use+normative'
];
function removeUndefinedValues(incoming) {
    Object.keys(incoming).forEach((k) => {
        // @ts-ignore Element implicitly has an 'any' type
        if (typeof incoming[k] === 'undefined') {
            // @ts-ignore Element implicitly has an 'any' type
            delete incoming[k];
        }
    });
    return incoming;
}
//# sourceMappingURL=importConfiguration.js.map