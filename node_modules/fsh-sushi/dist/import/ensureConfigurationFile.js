"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const ini_1 = __importDefault(require("ini"));
const fs_extra_1 = __importStar(require("fs-extra"));
const yaml_1 = require("yaml");
const types_1 = require("yaml/types");
const wordwrap_1 = __importDefault(require("wordwrap"));
const cloneDeep_1 = __importDefault(require("lodash/cloneDeep"));
const xml_js_1 = require("xml-js");
const FSHLogger_1 = require("../utils/FSHLogger");
const lodash_1 = require("lodash");
/**
 * A pair that automatically wraps the key in a node so we can attach a comment.
 * @see https://github.com/eemeli/yaml/issues/157
 */
class YAMLPair extends types_1.Pair {
    constructor(key, value) {
        super(yaml_1.createNode(key), value);
    }
    withCommentBefore(comment) {
        this.key.commentBefore = comment;
        return this;
    }
    withSpaceBefore() {
        this.spaceBefore = true;
        return this;
    }
}
/**
 * A commented out pair. Solution suggested by author of the yaml library.
 * @see https://github.com/eemeli/yaml/issues/159
 */
class CommentPair extends YAMLPair {
    toString(ctx, onComment, onChompKeep) {
        // @ts-ignore toString not properly types on Pair
        const str = super.toString(ctx, onComment, onChompKeep);
        return str.replace(new RegExp(`^(${ctx.indent})?`, 'gm'), '$&# ');
    }
}
/**
 * Checks for a sushi-config.yaml or sushi-config.yml file. If it finds one, it returns its path, otherwise it creates one
 * and then returns the new file's path.
 * @param root - the root path of the FSH Tank
 * @param allowFromScratch - create a config file from scratch even if package.json isn't found
 * @returns {string|undefined} path to the config file or undefined if it couldn't find or create one
 */
function ensureConfiguration(root, allowFromScratch = false) {
    const configPath = [
        path_1.default.join(root, 'sushi-config.yaml'),
        path_1.default.join(root, 'sushi-config.yml'),
        path_1.default.join(root, 'config.yaml'),
        path_1.default.join(root, 'config.yml')
    ].find(fs_extra_1.default.existsSync);
    if (configPath) {
        // The config already exists, so return it
        FSHLogger_1.logger.info(`Using configuration file: ${path_1.default.resolve(configPath)}`);
        if (!path_1.default.basename(configPath).match(/sushi/)) {
            FSHLogger_1.logger.warn(`Use of ${path_1.default.basename(configPath)} is deprecated and will be removed in a future release. Please rename configuration file to "sushi-config.yaml".`);
        }
        return configPath;
    }
    // The config doesn't exist, so generate one
    return generateConfiguration(root, allowFromScratch);
}
exports.ensureConfiguration = ensureConfiguration;
/**
 * Creates a new sushi-config.yaml file using available other configs (package.json, ig.ini, package-list.json, menu.xml)
 * @param root - the root path of the FSH Tank
 * @param allowFromScratch - create a config file from scratch even if package.json isn't found
 * @returns {string|undefined} path to the config file or undefined if it couldn't find or create one
 */
function generateConfiguration(root, allowFromScratch) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
    // Generate the config from available ig.ini, package.json, and package-list.json
    const igIni = getIgIni(root);
    const packageJSON = getPackageJSON(root);
    const packageList = getPackageList(root);
    // The config is "from scratch" if there is no package.json to base it on.
    // We know there wasn't a packageJSON if the returned packageJSON is the default one (by reference)
    const isFromScratch = packageJSON === DEFAULT_PACKAGE_JSON;
    if (isFromScratch && !allowFromScratch) {
        return;
    }
    // Create the new YAML document
    const configPath = path_1.default.join(root, 'sushi-config.yaml');
    const doc = new yaml_1.Document();
    const contents = new types_1.YAMLMap();
    // @ts-ignore See: https://github.com/eemeli/yaml/issues/156
    doc.contents = contents;
    // Set the comments for the document header.
    if (isFromScratch) {
        doc.commentBefore = getBoxComment('', 'ACTION REQUIRED: EDIT THIS FILE TO ENSURE IT ACCURATELY REFLECTS YOUR PROJECT!\n\n' +
            'This file is a placeholder, generated as a convenience to help you start your project. ');
    }
    else {
        doc.commentBefore = getBoxComment('', 'ACTION REQUIRED: REVIEW AND EDIT THIS FILE TO ENSURE IT ACCURATELY REFLECTS YOUR PROJECT!\n\n' +
            'This file was generated from your existing project files and will be used for SUSHI configuration ' +
            'from now on. You may delete your package.json as it is no longer needed.');
    }
    // id
    const id = (_a = packageJSON.name) !== null && _a !== void 0 ? _a : DEFAULT_PACKAGE_JSON.name;
    contents.add(new YAMLPair('id', id).withCommentBefore(getBoxComment(`ImplementationGuide-${id}.json`, 'The properties below are used to create the ImplementationGuide resource. For a list of supported ' +
        'properties, see: https://fshschool.org/sushi/configuration/')));
    // canonical
    const canonical = (_b = packageJSON.canonical) !== null && _b !== void 0 ? _b : DEFAULT_PACKAGE_JSON.canonical;
    contents.add(new YAMLPair('canonical', canonical));
    // version
    contents.add(new YAMLPair('version', (_d = (_c = packageJSON.version) !== null && _c !== void 0 ? _c : igIni.version) !== null && _d !== void 0 ? _d : DEFAULT_PACKAGE_JSON.version));
    // name (mimics old IG Exporter algorithm)
    const name = ((_f = (_e = packageJSON.title) !== null && _e !== void 0 ? _e : packageJSON.name) !== null && _f !== void 0 ? _f : DEFAULT_PACKAGE_JSON.title).replace(/[^A-Za-z0-9_]/g, '');
    contents.add(new YAMLPair('name', name));
    // title (mimics old IG Exporter algorithm)
    if (packageJSON.title || packageJSON.name) {
        contents.add(new YAMLPair('title', (_g = packageJSON.title) !== null && _g !== void 0 ? _g : packageJSON.name));
    }
    // status (mimics old IG Exporter value)
    contents.add(new YAMLPair('status', 'active'));
    // publisher
    const packageWithAuthor = packageJSON.author ? packageJSON : DEFAULT_PACKAGE_JSON;
    const maintainer = (_h = packageWithAuthor.maintainers) === null || _h === void 0 ? void 0 : _h.find(m => m.name === packageWithAuthor.author);
    if (maintainer) {
        const publisher = { name: packageWithAuthor.author };
        if (maintainer.url) {
            publisher.url = maintainer.url;
        }
        if (maintainer.email) {
            publisher.email = maintainer.email;
        }
        // only include the publisher if it didn't fall back to a default or if it's from scratch
        if (packageWithAuthor !== DEFAULT_PACKAGE_JSON || packageJSON === DEFAULT_PACKAGE_JSON) {
            contents.add(new YAMLPair('publisher', publisher));
        }
    }
    else {
        contents.add(new YAMLPair('publisher', packageWithAuthor.author));
    }
    // contact
    if ((_j = packageJSON.maintainers) === null || _j === void 0 ? void 0 : _j.length) {
        const contacts = packageJSON.maintainers
            .filter(m => !packageJSON.author || m.name !== packageJSON.author) // filter out publisher
            .map(m => {
            const contact = {};
            if (m.name) {
                contact.name = m.name;
            }
            if (m.url || m.email) {
                contact.telecom = [];
            }
            if (m.url) {
                contact.telecom.push({
                    system: 'url',
                    value: m.url
                });
            }
            if (m.email) {
                contact.telecom.push({
                    system: 'email',
                    value: m.email
                });
            }
            return contact;
        });
        if (contacts.length) {
            contents.add(new YAMLPair('contact', contacts));
        }
    }
    // description
    if (packageJSON.description) {
        contents.add(new YAMLPair('description', packageJSON.description));
    }
    // license
    if (packageJSON.license || igIni.license) {
        contents.add(new YAMLPair('license', (_k = packageJSON.license) !== null && _k !== void 0 ? _k : igIni.license));
    }
    // fhirVersion
    contents.add(new YAMLPair('fhirVersion', '4.0.1'));
    // dependencies
    const packageWithDeps = packageJSON.dependencies && ((_l = Object.keys(packageJSON.dependencies)) === null || _l === void 0 ? void 0 : _l.some(k => k !== 'hl7.fhir.r4.core'))
        ? packageJSON
        : DEFAULT_PACKAGE_JSON;
    const dependencies = cloneDeep_1.default(packageWithDeps.dependencies);
    delete dependencies['hl7.fhir.r4.core'];
    if (packageWithDeps !== DEFAULT_PACKAGE_JSON) {
        contents.add(new YAMLPair('dependencies', dependencies));
    }
    // parameters
    const params = { 'show-inherited-invariants': false }; // backwards-compatible to IG Exporter
    if (igIni['usage-stats-opt-out']) {
        params['usage-stats-opt-out'] = igIni['usage-stats-opt-out'];
    }
    contents.add(new YAMLPair('parameters', params));
    // copyrightYear
    contents.add(new YAMLPair('copyrightYear', (_m = igIni.copyrightyear) !== null && _m !== void 0 ? _m : DEFAULT_IG_INI.copyrightyear));
    // releaseLabel
    contents.add(new YAMLPair('releaseLabel', (_o = igIni.ballotstatus) !== null && _o !== void 0 ? _o : DEFAULT_IG_INI.ballotstatus));
    // The remaining properties are optional. If they exist (uncommented), they control other config files,
    // otherwise (when they are deleted or commented out), SUSHI will not generate them (but will copy them
    // if they exist in the predetermined locations).
    // Keep track of commented vs uncommented properties because we want to group the commented ones at
    // the end. This is partially for organizational purposes, but ACTUALLY because the YAML library has a
    // bug related to having commented out YAML in a block between two uncommented YAML blocks.  It's weird
    // but the unit tests activate the bug when we don't re-order like this.
    const setPairs = [];
    const commentedPairs = [];
    if (igIni !== DEFAULT_IG_INI) {
        commentedPairs.push(new CommentPair('template', (_p = igIni.template) !== null && _p !== void 0 ? _p : DEFAULT_IG_INI.template)
            .withCommentBefore(getBoxComment('ig.ini', 'To control the ig.ini using this config, uncomment and set the "template" property.'))
            .withSpaceBefore());
    }
    else {
        setPairs.push(new YAMLPair('template', (_q = igIni.template) !== null && _q !== void 0 ? _q : DEFAULT_IG_INI.template)
            .withCommentBefore(getBoxComment('ig.ini', 'To use a provided ig-data/ig.ini file, delete the "template" property below.'))
            .withSpaceBefore());
    }
    // menu
    const menuPath = path_1.default.join(root, 'ig-data', 'input', 'includes', 'menu.xml');
    if (fs_extra_1.default.existsSync(menuPath)) {
        const menuXML = fs_extra_1.default.readFileSync(menuPath, 'utf8');
        const menu = getMenuObjectFromMenuXML(menuXML);
        commentedPairs.push(new CommentPair('menu', menu !== null && menu !== void 0 ? menu : DEFAULT_MENU)
            .withCommentBefore(getBoxComment('menu.xml', 'To control the menu.xml using this config, uncomment and set the "menu" property.'))
            .withSpaceBefore());
    }
    else {
        setPairs.push(new YAMLPair('menu', DEFAULT_MENU)
            .withCommentBefore(getBoxComment('menu.xml', 'To use a provided ig-data/input/includes/menu.xml file, delete the "menu" property below.'))
            .withSpaceBefore());
    }
    // index
    // There are four possible locations for it (two filenames in two directories)
    const inputIndexMarkdownPageContentPath = path_1.default.join(root, 'ig-data', 'input', 'pagecontent', 'index.md');
    const inputIndexXMLPageContentPath = path_1.default.join(root, 'ig-data', 'input', 'pagecontent', 'index.xml');
    const inputIndexMarkdownPagesPath = path_1.default.join(root, 'ig-data', 'input', 'pages', 'index.md');
    const inputIndexXMLPagesPath = path_1.default.join(root, 'ig-data', 'input', 'pages', 'index.xml');
    if (!fs_extra_1.default.existsSync(inputIndexMarkdownPageContentPath) &&
        !fs_extra_1.default.existsSync(inputIndexXMLPageContentPath) &&
        !fs_extra_1.default.existsSync(inputIndexMarkdownPagesPath) &&
        !fs_extra_1.default.existsSync(inputIndexXMLPagesPath)) {
        // no index file found, create our default
        setPairs.push(new YAMLPair('indexPageContent', (_r = packageJSON.description) !== null && _r !== void 0 ? _r : '')
            .withCommentBefore(getBoxComment('index.md', `To use a provided ig-data${path_1.default.sep}input${path_1.default.sep}[pagecontent | pages]${path_1.default.sep}index.[md | xml], delete the "indexPageContent" property below.`))
            .withSpaceBefore());
    }
    else {
        // if an index file is provided, don't add anything to config
    }
    // history
    // @ts-ignore it's ok that we don't initialize it with current.  It will get current eventually.
    const yamlHistory = {};
    if (packageList['package-id'] != null && packageList['package-id'] !== packageJSON.name) {
        yamlHistory['package-id'] = packageList['package-id'];
    }
    if (packageList.canonical != null && packageList.canonical !== packageJSON.canonical) {
        yamlHistory.canonical = packageList.canonical;
    }
    if (packageList.title != null && packageList.title !== packageJSON.title) {
        yamlHistory.title = packageList.title;
    }
    if (packageList.introduction != null && packageList.introduction !== packageJSON.description) {
        yamlHistory.introduction = packageList.introduction;
    }
    yamlHistory.current = getCurrentFromPackageList(packageList, packageJSON);
    (_s = packageList.list) === null || _s === void 0 ? void 0 : _s.forEach(item => {
        if (item.version === 'current') {
            return;
        }
        const yamlItem = cloneDeep_1.default(item);
        delete yamlItem.version;
        yamlHistory[item.version] = yamlItem;
    });
    if (packageList !== DEFAULT_PACKAGE_LIST) {
        commentedPairs.push(new CommentPair('history', yamlHistory)
            .withCommentBefore(getBoxComment('package-list.json', 'To control the package-list.json using this config, uncomment and set the "history" property.'))
            .withSpaceBefore());
    }
    else {
        setPairs.push(new YAMLPair('history', yamlHistory)
            .withCommentBefore(getBoxComment('package-list.json', 'To use a provided ig-data/package-list.json file, delete the "history" property below.'))
            .withSpaceBefore());
    }
    // FSHOnly - in SUSHI 0.12.x, presence or absence of ig-data indicated if you wanted an IG or not.
    // But don't ever set FSHOnly when creating sushi-config.yaml "from scratch".
    if (!fs_extra_1.default.existsSync(path_1.default.join(root, 'ig-data')) && !isFromScratch) {
        setPairs.push(new YAMLPair('FSHOnly', true));
    }
    setPairs.forEach(p => contents.add(p));
    commentedPairs.forEach(p => contents.add(p));
    // Write out the new configuration file
    FSHLogger_1.logger.warn(`Generated new configuration file: ${path_1.default.resolve(configPath)}. Please review to ensure configuration is correct.`);
    fs_extra_1.default.writeFileSync(configPath, doc.toString(), 'utf8');
    return configPath;
}
const COMMENTLENGTH = 94; // excluding 6 chars for initial '# │ ' and closing ' │'
const wrap = wordwrap_1.default(1, COMMENTLENGTH);
/**
 * Wraps a comment in a box (for visual purposes)
 * @param title - the title to put at the top of the box
 * @param comment - the comment to put in the body of the box
 * @returns string - the comment in a box
 */
function getBoxComment(title, comment) {
    let boxComment = ` ╭─${lodash_1.pad(title, COMMENTLENGTH, '─')}─╮\n`;
    wrap(comment)
        .split(/\r?\n/)
        .forEach(line => {
        boxComment += ` │ ${lodash_1.padEnd(line, COMMENTLENGTH, ' ')} │\n`;
    });
    boxComment += ` ╰─${lodash_1.pad('', COMMENTLENGTH, '─')}─╯`;
    return boxComment;
}
// Helper functions for converting menu XML file
const itemInNewTab = (item) => { var _a; return (((_a = item.a._attributes) === null || _a === void 0 ? void 0 : _a.target) === '_blank' ? 'new-tab ' : ''); };
const itemIsExternal = (item) => { var _a, _b; return ((_b = (_a = item.a.img) === null || _a === void 0 ? void 0 : _a._attributes) === null || _b === void 0 ? void 0 : _b.src) === 'external.png' ? 'external ' : ''; };
/**
 * Convert a menu XML file into the required menu object format for the YAML configuration.
 * This assumes the menu XML format found in the sample-ig.  Other formats won't be parsed
 * correctly and should result in this function returning undefined.
 * @param menuXML - a string of menu XML
 * @returns {YAMLConfigurationMenu|undefined} the menu object or undefined if it couldn't be parsed
 */
function getMenuObjectFromMenuXML(menuXML) {
    const menu = {};
    // We're making some assumptions about the XML here, so wrap in try/catch to be safe
    try {
        const xml = xml_js_1.xml2js(menuXML, { compact: true });
        // Example xml result format:
        // {
        //   "ul": {
        //     "_attributes": { "xmlns": "http://www.w3.org/1999/xhtml", "class": "nav navbar-nav" },
        //     "li": [
        //       {
        //         "a": {
        //           "_attributes": { "href": "menu-item.html" },
        //           "_text": "Menu Item"
        //         }
        //       },
        //       {
        //         "_attributes": { "class": "dropdown" },
        //         "a": {
        //           "_attributes": { "data-toggle": "dropdown", "href": "#", "class": "dropdown-toggle" },
        //           "_text": "Sub Menu",
        //           "b": {
        //             "_attributes": { "class": "caret" }
        //           }
        //         },
        //         "ul": {
        //           "_attributes": { "class": "dropdown-menu" },
        //           "li": {
        //             "a": {
        //               "_attributes": { "href": "sub-menu-item.html" },
        //               "_text": "Sub-Menu Item"
        //             }
        //           }
        //         }
        //       }
        //     ]
        //   }
        // }
        if (xml.ul && xml.ul.li) {
            const items = Array.isArray(xml.ul.li) ? xml.ul.li : [xml.ul.li];
            items.forEach((li) => {
                var _a;
                if (li.a && !Array.isArray(li.a)) {
                    const name = li.a._text;
                    const link = (_a = li.a._attributes) === null || _a === void 0 ? void 0 : _a.href;
                    const menuLinkWithKeywords = `${itemInNewTab(li)}${itemIsExternal(li)}${link}`;
                    if (li.ul && li.ul.li) {
                        const subMenu = {};
                        const subItems = Array.isArray(li.ul.li) ? li.ul.li : [li.ul.li];
                        subItems.forEach((subLi) => {
                            var _a;
                            if (subLi.a && !Array.isArray(subLi.a)) {
                                const subName = subLi.a._text;
                                const subLink = (_a = subLi.a._attributes) === null || _a === void 0 ? void 0 : _a.href;
                                if (subLink && subLink !== '#') {
                                    subMenu[subName] = `${itemInNewTab(subLi)}${itemIsExternal(subLi)}${subLink}`;
                                }
                                // NOTE: if there is another sub-sub-menu, we drop it since publisher doesn't support it
                            }
                        });
                        if (Object.keys(subMenu).length > 0) {
                            menu[name] = subMenu;
                        }
                        else if (link && link !== '#') {
                            menu[name] = menuLinkWithKeywords;
                        }
                    }
                    else if (link && link !== '#') {
                        menu[name] = menuLinkWithKeywords;
                    }
                }
            });
        }
    }
    catch (e) {
        // Not so suprising since menu.xml might have a crazy format
        return;
    }
    if (Object.keys(menu).length > 0) {
        return menu;
    }
}
/**
 * Gets the value for current, preferring a simple path string when all other values match the default
 * @param packageList - the packageList object from package-list.json (or default)
 * @param packageJSON - the packageJSON object from package.json (or default)
 * @returns {string|YAMLConfigurationHistoryItem} - a string for the current path or an object w/ current details
 */
function getCurrentFromPackageList(packageList, packageJSON) {
    var _a;
    const plCurrent = packageList.list.find((item) => item.version === 'current');
    if (plCurrent == null) {
        return (_a = packageJSON.url) !== null && _a !== void 0 ? _a : DEFAULT_PACKAGE_LIST.list[0].path;
    }
    for (const key of Object.keys(plCurrent)) {
        if (key === 'version' ||
            key === 'path' ||
            (key === 'desc' && plCurrent.desc === DEFAULT_PACKAGE_LIST.list[0].desc) ||
            (key === 'status' && plCurrent.status === DEFAULT_PACKAGE_LIST.list[0].status) ||
            (key === 'current' && plCurrent.current === DEFAULT_PACKAGE_LIST.list[0].current)) {
            continue;
        }
        else {
            // return the full object since it contains non-default values besides path
            return plCurrent;
        }
    }
    // If we got this far, the only significant value is the path, so just return that
    return plCurrent.path;
}
/**
 * Gets the ig.ini representation or a default if none is found
 * @param root - the root path for the FSH Tank
 * @returns {object} - the ig.ini object representation
 */
function getIgIni(root) {
    const inputIniPath = path_1.default.join(root, 'ig-data', 'ig.ini');
    if (fs_extra_1.existsSync(inputIniPath)) {
        let inputIniContents = fs_extra_1.readFileSync(inputIniPath, 'utf8');
        // FHIR allows templates to have versions identified using #. E.g.,
        //   template = hl7.fhir.template#0.1.0
        // The ini library, however, treats # as a comment unless it is escaped. So if it exists, we need to escape it.
        inputIniContents = inputIniContents.replace(/^\s*template\s*=\s*[^#]*(#.+)?$/m, ($0, $1) => $1 ? $0.replace($1, `\\${$1}`) : $0);
        return ini_1.default.parse(inputIniContents).IG;
    }
    // No existing ig.ini, so return one with default values to populate an example config
    return DEFAULT_IG_INI;
}
/**
 * Gets the package.json representation or a default if none is found
 * @param root - the root path for the FSH Tank
 * @returns {PackageJSON} - the package.json object representation
 */
function getPackageJSON(root) {
    const packagePath = path_1.default.join(root, 'package.json');
    if (fs_extra_1.existsSync(packagePath)) {
        return fs_extra_1.default.readJSONSync(packagePath);
    }
    // No existing package.json, so return one with default values to populate an example config
    return DEFAULT_PACKAGE_JSON;
}
/**
 * Gets the package-list.json representation or a default if none is found
 * @param root - the root path for the FSH Tank
 * @returns {object} - the package-list.json object representation
 */
function getPackageList(root) {
    const packageListPath = path_1.default.join(root, 'ig-data', 'package-list.json');
    if (fs_extra_1.existsSync(packageListPath)) {
        return fs_extra_1.readJSONSync(packageListPath);
    }
    // No existing package-list.json, so return one with default values to populate an example config
    return DEFAULT_PACKAGE_LIST;
}
const DEFAULT_IG_INI = {
    template: 'fhir.base.template#current',
    copyrightyear: `${new Date().getFullYear()}+`,
    ballotstatus: 'CI Build'
};
const DEFAULT_PACKAGE_JSON = {
    name: 'example-ig',
    version: '0.0.1',
    title: 'Example IG',
    description: 'This is an example IG description. You should uncomment and replace it with your own.',
    canonical: 'http://example.org/fhir',
    author: 'Example Publisher',
    maintainers: [
        {
            name: 'Example Publisher',
            email: 'publisher@example.org',
            url: 'http://example.org/committee'
        }
    ],
    license: 'CC0-1.0',
    dependencies: {
        'hl7.fhir.r4.core': '4.0.1',
        'hl7.fhir.us.core': '3.1.0'
    }
};
const DEFAULT_MENU = {
    'IG Home': 'index.html',
    'Table of Contents': 'toc.html',
    'Artifact Index': 'artifacts.html',
    Support: {
        'FHIR Spec': 'new-tab external http://hl7.org/fhir/R4/index.html'
    }
};
const DEFAULT_PACKAGE_LIST = {
    list: [
        {
            version: 'current',
            desc: 'Continuous Integration Build (latest in version control)',
            path: 'http://build.fhir.org/ig/example/example-ig',
            status: 'ci-build',
            current: true
        },
        {
            version: DEFAULT_PACKAGE_JSON.version,
            fhirversion: '4.0.1',
            date: '2099-01-01',
            desc: 'Initial STU ballot (Mmm yyyy Ballot)',
            path: 'http://example.org/fhir/STU1',
            status: 'ballot',
            sequence: 'STU 1',
            current: true
        }
    ]
};
//# sourceMappingURL=ensureConfigurationFile.js.map