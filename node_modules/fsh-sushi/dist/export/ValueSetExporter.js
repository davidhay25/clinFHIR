"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValueSetExporter = void 0;
const fhirtypes_1 = require("../fhirtypes");
const fshtypes_1 = require("../fshtypes");
const FSHLogger_1 = require("../utils/FSHLogger");
const errors_1 = require("../errors");
const _1 = require(".");
const utils_1 = require("../utils");
const rules_1 = require("../fshtypes/rules");
const common_1 = require("../fhirtypes/common");
const valid_url_1 = require("valid-url");
const lodash_1 = require("lodash");
class ValueSetExporter {
    constructor(tank, pkg, fisher) {
        this.tank = tank;
        this.pkg = pkg;
        this.fisher = fisher;
    }
    setMetadata(valueSet, fshDefinition) {
        valueSet.setName(fshDefinition);
        valueSet.setId(fshDefinition);
        if (fshDefinition.title == '') {
            FSHLogger_1.logger.warn(`Value set ${fshDefinition.name} has a title field that should not be empty.`);
        }
        if (fshDefinition.description == '') {
            FSHLogger_1.logger.warn(`Value set ${fshDefinition.name} has a description field that should not be empty.`);
        }
        if (fshDefinition.title) {
            valueSet.title = fshDefinition.title;
        }
        if (fshDefinition.description) {
            valueSet.description = fshDefinition.description;
        }
        if (this.tank.config.FSHOnly) {
            valueSet.version = this.tank.config.version;
        }
        else {
            delete valueSet.version; // deleting to allow the IG Publisher default to take hold
        }
        valueSet.status = this.tank.config.status;
        valueSet.url = `${this.tank.config.canonical}/ValueSet/${valueSet.id}`;
    }
    setCompose(valueSet, components) {
        if (components.length > 0) {
            valueSet.compose = {
                include: [],
                exclude: []
            };
            components.forEach(component => {
                var _a, _b, _c, _d, _e;
                const composeElement = {};
                if (component.from.system) {
                    const systemParts = component.from.system.split('|');
                    const csMetadata = this.fisher.fishForMetadata(component.from.system, utils_1.Type.CodeSystem);
                    // if we found metadata, use it.
                    // if we didn't find any matching metadata, the code system might be defined directly on the valueset.
                    let isContainedSystem;
                    let systemIsInlineInstance = false;
                    let systemId;
                    if (csMetadata) {
                        composeElement.system = (_a = csMetadata.url) !== null && _a !== void 0 ? _a : systemParts[0];
                        isContainedSystem = (_b = valueSet.contained) === null || _b === void 0 ? void 0 : _b.some((resource) => {
                            return (resource === null || resource === void 0 ? void 0 : resource.id) === csMetadata.id && resource.resourceType === 'CodeSystem';
                        });
                        systemIsInlineInstance = csMetadata.instanceUsage === 'Inline';
                        systemId = csMetadata.id;
                    }
                    else {
                        const directSystem = (_c = valueSet.contained) === null || _c === void 0 ? void 0 : _c.find((resource) => {
                            return (((resource === null || resource === void 0 ? void 0 : resource.id) === component.from.system ||
                                (resource === null || resource === void 0 ? void 0 : resource.name) === component.from.system ||
                                (resource === null || resource === void 0 ? void 0 : resource.url) === component.from.system) &&
                                (resource === null || resource === void 0 ? void 0 : resource.resourceType) === 'CodeSystem');
                        });
                        if (directSystem) {
                            isContainedSystem = true;
                            composeElement.system = directSystem.url;
                            systemId = directSystem.id;
                        }
                        else {
                            isContainedSystem = false;
                            composeElement.system = systemParts[0];
                        }
                    }
                    // if the code system is also a contained resource, add the valueset-system extension
                    // this zulip thread contains a discussion of the issue and an example using this extension:
                    // https://chat.fhir.org/#narrow/stream/215610-shorthand/topic/Contained.20code.20system.20in.20the.20value.20set/near/424938537
                    // additionally, if it's not a contained resource, and the system we found is an inline instance, that's a problem
                    if (isContainedSystem) {
                        composeElement._system = {
                            extension: [
                                {
                                    url: 'http://hl7.org/fhir/StructureDefinition/valueset-system',
                                    valueCanonical: `#${systemId}`
                                }
                            ]
                        };
                    }
                    else if (systemIsInlineInstance) {
                        FSHLogger_1.logger.error(`Can not reference CodeSystem ${component.from.system}: this CodeSystem is an inline instance, but it is not present in the list of contained resources.`, component.sourceInfo);
                        return;
                    }
                    // if the rule specified a version, use that version.
                    composeElement.version = systemParts.slice(1).join('|') || undefined;
                    if (!(0, valid_url_1.isUri)(composeElement.system)) {
                        throw new errors_1.InvalidUriError(composeElement.system);
                    }
                }
                if (component.from.valueSets) {
                    composeElement.valueSet = component.from.valueSets.map(vs => {
                        var _a, _b;
                        return (_b = (_a = this.fisher.fishForMetadata(vs, utils_1.Type.ValueSet)) === null || _a === void 0 ? void 0 : _a.url) !== null && _b !== void 0 ? _b : vs;
                    });
                    composeElement.valueSet = composeElement.valueSet.filter(vs => {
                        if (vs == valueSet.url) {
                            FSHLogger_1.logger.error(`Value set with id ${valueSet.id} has component rule with self-referencing value set (by id, value set name, or url). Removing self-reference.`);
                        }
                        return vs != valueSet.url;
                    });
                    composeElement.valueSet.forEach(vs => {
                        // Canonical URI may include | to specify version: https://www.hl7.org/fhir/references.html#canonical
                        if (!(0, valid_url_1.isUri)(vs.split('|')[0])) {
                            throw new errors_1.InvalidUriError(vs);
                        }
                    });
                }
                if (component instanceof rules_1.ValueSetConceptComponentRule && component.concepts.length > 0) {
                    composeElement.concept = component.concepts.map(concept => {
                        const composeConcept = {
                            code: concept.code
                        };
                        if (concept.display) {
                            composeConcept.display = concept.display;
                        }
                        return composeConcept;
                    });
                    // if we can fish up the system in the tank, it's local, and we should check the listed concepts
                    const codeSystem = this.tank.fish(composeElement.system, utils_1.Type.CodeSystem);
                    if (codeSystem instanceof fshtypes_1.FshCodeSystem || codeSystem instanceof fshtypes_1.Instance) {
                        (0, common_1.listUndefinedLocalCodes)(codeSystem, composeElement.concept.map(concept => concept.code), this.tank, component);
                    }
                }
                else if (component instanceof rules_1.ValueSetFilterComponentRule &&
                    component.filters.length > 0) {
                    composeElement.filter = component.filters.map(filter => {
                        // if filter.value is a FshCode, perform the local code system check here as well
                        if (filter.value instanceof fshtypes_1.FshCode) {
                            const codeSystem = this.tank.fish(composeElement.system, utils_1.Type.CodeSystem);
                            if (codeSystem instanceof fshtypes_1.FshCodeSystem || codeSystem instanceof fshtypes_1.Instance) {
                                (0, common_1.listUndefinedLocalCodes)(codeSystem, [filter.value.code], this.tank, component);
                            }
                        }
                        return {
                            property: filter.property.toString(),
                            op: filter.operator.toString(),
                            value: this.filterValueToString(filter.value)
                        };
                    });
                }
                if (component.inclusion) {
                    if (((_d = composeElement.concept) === null || _d === void 0 ? void 0 : _d.length) > 0) {
                        // warn the user if they have already included a concept in this component
                        // concept, system, and version must all match to be considered equal
                        const matchingComposeElements = valueSet.compose.include.filter(compose => {
                            var _a;
                            return (compose.system === composeElement.system &&
                                compose.version === composeElement.version &&
                                ((_a = compose.concept) === null || _a === void 0 ? void 0 : _a.length) > 0);
                        });
                        const potentialMatches = (0, lodash_1.flatMap)(matchingComposeElements, compose => compose.concept).map(concept => concept.code);
                        composeElement.concept = composeElement.concept.filter((concept, idx, currentConcepts) => {
                            if (potentialMatches.includes(concept.code) ||
                                currentConcepts
                                    .slice(0, idx)
                                    .some(duplicateConcept => duplicateConcept.code === concept.code)) {
                                FSHLogger_1.logger.warn(`ValueSet ${valueSet.name} already includes ${composeElement.system}${composeElement.version ? `|${composeElement.version}` : ''}#${concept.code}`, component.sourceInfo);
                                return false;
                            }
                            return true;
                        });
                        if (composeElement.concept.length > 0) {
                            this.addConceptComposeElement(composeElement, valueSet.compose.include);
                        }
                    }
                    else {
                        if (((_e = composeElement.valueSet) === null || _e === void 0 ? void 0 : _e.length) !== 0 || composeElement.system != undefined) {
                            valueSet.compose.include.push(composeElement);
                        }
                    }
                }
                else {
                    this.addConceptComposeElement(composeElement, valueSet.compose.exclude);
                }
            });
            if (valueSet.compose.exclude.length == 0) {
                delete valueSet.compose.exclude;
            }
        }
    }
    addConceptComposeElement(freshElement, composeList) {
        var _a;
        if (((_a = freshElement.concept) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            const matchingFromIndex = composeList.findIndex(compose => {
                var _a, _b, _c;
                return (compose.system === freshElement.system &&
                    compose.version === freshElement.version &&
                    ((_a = compose.concept) === null || _a === void 0 ? void 0 : _a.length) > 0 &&
                    (0, lodash_1.xor)((_b = compose.valueSet) !== null && _b !== void 0 ? _b : [], (_c = freshElement.valueSet) !== null && _c !== void 0 ? _c : []).length === 0);
            });
            if (matchingFromIndex > -1) {
                composeList[matchingFromIndex].concept.push(...freshElement.concept);
            }
            else {
                composeList.push(freshElement);
            }
        }
        else {
            composeList.push(freshElement);
        }
    }
    setCaretRules(valueSet, rules, valueSetSD) {
        (0, utils_1.resolveSoftIndexing)(rules);
        const ruleMap = new Map();
        // in order to validate rules that set values on contained resources, we need to track information from rules
        // that define the types of those resources. those types could be defined by rules on the "resourceType" element,
        // or they could be defined by the existing resource that is being assigned.
        // the path is always empty for these rules, so we don't need to track or check those.
        const inlineResourcePaths = [];
        // first, collect the information we can from rules that set a resourceType
        // if instances are directly assigned, we'll get information from them when we fish up the instance.
        rules.forEach((r) => {
            if (r.caretPath.endsWith('.resourceType') && typeof r.value === 'string' && !r.isInstance) {
                inlineResourcePaths.push({
                    caretPath: (0, common_1.splitOnPathPeriods)(r.caretPath).slice(0, -1).join('.'),
                    instanceOf: r.value
                });
            }
        });
        const rulesWithInstances = rules
            .filter(rule => rule instanceof rules_1.CaretValueRule)
            .map(rule => {
            if (rule.isInstance) {
                const instanceExporter = new _1.InstanceExporter(this.tank, this.pkg, this.fisher);
                const instance = instanceExporter.fishForFHIR(rule.value);
                if (instance == null) {
                    FSHLogger_1.logger.error(`Cannot find definition for Instance: ${rule.value}. Skipping rule.`, rule.sourceInfo);
                    return null;
                }
                if (instance._instanceMeta.usage === 'Example') {
                    FSHLogger_1.logger.warn(`Contained instance "${rule.value}" is an example and probably should not be included in a conformance resource.`, rule.sourceInfo);
                }
                rule.value = instance;
                // since we found a resource, save its type in our list of inline resource paths.
                inlineResourcePaths.push({
                    caretPath: rule.caretPath,
                    instanceOf: instance.resourceType
                });
            }
            // the relevant inline resource paths for the current rule are rules with:
            // - a caret path that is an ancestor of the current rule's path
            // - and also, the current rule's caret path can not be this other rule's caret path followed by "resourceType".
            const matchingInlineResourcePaths = inlineResourcePaths.filter(i => {
                return (rule.caretPath.startsWith(`${i.caretPath}.`) &&
                    rule.caretPath !== `${i.caretPath}.resourceType`);
            });
            const inlineResourceTypes = [];
            // for each of those matches, we build up the inline resource types array.
            // this is a sparse array that is parallel to an array of the parts of the current rule's caret path.
            // this will usually only have one defined element, but may have more if a contained resource includes other assigned resources.
            // a typical case could be something like: a caret path of "contained.interpretation" which sets a value on a contained Observation,
            // and the resulting inline resource paths array being ["Observation"].
            // a case with multiple elements could be: a caret path of "contained.entry.resource.interpretation"
            // and the resulting inline resource paths array being ["Bundle", undefined, "Observation"]
            matchingInlineResourcePaths.forEach(match => {
                inlineResourceTypes[(0, common_1.splitOnPathPeriods)(match.caretPath).length - 1] = match.instanceOf;
            });
            try {
                const { pathParts } = valueSetSD.validateValueAtPath(rule.caretPath, rule.value, this.fisher, inlineResourceTypes);
                ruleMap.set((0, utils_1.assembleFSHPath)(pathParts).replace(/\[0+\]/g, ''), { pathParts });
                return { rule, inlineResourceTypes };
            }
            catch (originalErr) {
                // if an Instance has an id that looks like a number, bigint, or boolean,
                // we may have tried to assign that value instead of an Instance.
                // try to fish up an Instance with the rule's raw value.
                // if we find one, try assigning that instead.
                if (originalErr instanceof errors_1.MismatchedTypeError &&
                    ['number', 'bigint', 'boolean'].includes(typeof rule.value)) {
                    const instanceExporter = new _1.InstanceExporter(this.tank, this.pkg, this.fisher);
                    const { instance, pathParts } = (0, common_1.validateInstanceFromRawValue)(valueSet, rule, instanceExporter, this.fisher, originalErr, inlineResourceTypes);
                    if ((instance === null || instance === void 0 ? void 0 : instance._instanceMeta.usage) === 'Example') {
                        FSHLogger_1.logger.warn(`Contained instance "${rule.rawValue}" is an example and probably should not be included in a conformance resource.`, rule.sourceInfo);
                    }
                    rule.value = instance;
                    if (instance != null) {
                        // this rule ended up assigning an instance, so save its type in our list of inline resource paths.
                        inlineResourcePaths.push({
                            caretPath: rule.caretPath,
                            instanceOf: instance.resourceType
                        });
                    }
                    ruleMap.set((0, utils_1.assembleFSHPath)(pathParts).replace(/\[0+\]/g, ''), { pathParts });
                    return { rule, inlineResourceTypes };
                }
                else {
                    FSHLogger_1.logger.error(originalErr.message, rule.sourceInfo);
                    if (originalErr.stack) {
                        FSHLogger_1.logger.debug(originalErr.stack);
                    }
                    return null;
                }
            }
        })
            .filter(rule => rule);
        const knownSlices = (0, common_1.determineKnownSlices)(valueSetSD, ruleMap, this.fisher);
        (0, common_1.setImpliedPropertiesOnInstance)(valueSet, valueSetSD, [...ruleMap.keys()], inlineResourcePaths.map(i => i.caretPath), this.fisher, knownSlices);
        for (const { rule, inlineResourceTypes } of rulesWithInstances) {
            try {
                (0, common_1.setPropertyOnDefinitionInstance)(valueSet, rule.caretPath, rule.value, this.fisher, inlineResourceTypes);
            }
            catch (err) {
                FSHLogger_1.logger.error(err.message, rule.sourceInfo);
                if (err.stack) {
                    FSHLogger_1.logger.debug(err.stack);
                }
            }
        }
    }
    setConceptCaretRules(vs, rules, valueSetSD) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        (0, utils_1.resolveSoftIndexing)(rules);
        const ruleMap = new Map();
        for (const rule of rules) {
            const splitConcept = rule.pathArray[0].split('#');
            const system = splitConcept[0];
            const baseSystem = system === null || system === void 0 ? void 0 : system.split('|')[0];
            const version = system === null || system === void 0 ? void 0 : system.split('|')[1];
            const code = splitConcept.slice(1).join('#');
            const systemMeta = this.fisher.fishForMetadata(baseSystem, utils_1.Type.CodeSystem);
            let composeIndex = (_c = (_b = (_a = vs.compose) === null || _a === void 0 ? void 0 : _a.include) === null || _b === void 0 ? void 0 : _b.findIndex(composeElement => {
                return (((composeElement.system === baseSystem && composeElement.version === version) ||
                    (composeElement.system === (systemMeta === null || systemMeta === void 0 ? void 0 : systemMeta.url) && composeElement.version === version)) &&
                    composeElement.filter == null);
            })) !== null && _c !== void 0 ? _c : -1;
            let composeArray;
            let composeElement;
            let conceptIndex = -1;
            if (composeIndex !== -1) {
                composeArray = 'include';
                composeElement = vs.compose.include[composeIndex];
                conceptIndex = (_d = composeElement === null || composeElement === void 0 ? void 0 : composeElement.concept) === null || _d === void 0 ? void 0 : _d.findIndex(concept => {
                    return concept.code === code;
                });
            }
            if (conceptIndex === -1) {
                composeIndex =
                    (_g = (_f = (_e = vs.compose) === null || _e === void 0 ? void 0 : _e.exclude) === null || _f === void 0 ? void 0 : _f.findIndex(composeElement => {
                        return (((composeElement.system === baseSystem && composeElement.version === version) ||
                            (composeElement.system === (systemMeta === null || systemMeta === void 0 ? void 0 : systemMeta.url) &&
                                composeElement.version === version)) &&
                            composeElement.filter == null);
                    })) !== null && _g !== void 0 ? _g : -1;
                if (composeIndex !== -1) {
                    composeArray = 'exclude';
                    composeElement = vs.compose.exclude[composeIndex];
                    conceptIndex = (_h = composeElement === null || composeElement === void 0 ? void 0 : composeElement.concept) === null || _h === void 0 ? void 0 : _h.findIndex(concept => {
                        return concept.code === code;
                    });
                }
            }
            if (conceptIndex == null) {
                FSHLogger_1.logger.error(`Cannot process caret assignment rule for code ${system}#${code} because ` +
                    'this value set does not explicitly include or exclude this code in its ' +
                    'rules. To fix this error, add a rule that specifically includes or excludes ' +
                    'this code for the value set.');
                return;
            }
            if (conceptIndex !== -1) {
                if (rule.isInstance) {
                    const instanceExporter = new _1.InstanceExporter(this.tank, this.pkg, this.fisher);
                    const instance = instanceExporter.fishForFHIR(rule.value);
                    if (instance == null) {
                        FSHLogger_1.logger.error(`Cannot find definition for Instance: ${rule.value}. Skipping rule.`, rule.sourceInfo);
                        continue;
                    }
                    rule.value = instance;
                }
                const fullPath = `compose.${composeArray}[${composeIndex}].concept[${conceptIndex}].${rule.caretPath}`;
                try {
                    const { pathParts } = valueSetSD.validateValueAtPath(fullPath, rule.value, this.fisher);
                    ruleMap.set(fullPath, { pathParts, rule });
                }
                catch (e) {
                    FSHLogger_1.logger.error(e.message, rule.sourceInfo);
                    if (e.stack) {
                        FSHLogger_1.logger.debug(e.stack);
                    }
                }
            }
            else {
                FSHLogger_1.logger.error(`Could not find concept ${rule.pathArray[0]}, skipping rule.`, rule.sourceInfo);
            }
        }
        const knownSlices = (0, common_1.determineKnownSlices)(valueSetSD, ruleMap, this.fisher);
        (0, common_1.setImpliedPropertiesOnInstance)(vs, valueSetSD, [...ruleMap.keys()], [], this.fisher, knownSlices);
        for (const [path, { rule }] of ruleMap) {
            (0, common_1.setPropertyOnDefinitionInstance)(vs, path, rule.value, this.fisher);
        }
    }
    filterValueToString(value) {
        if (value instanceof RegExp) {
            return value.source;
        }
        else if (value instanceof fshtypes_1.FshCode) {
            return value.code;
        }
        else {
            return value.toString();
        }
    }
    applyInsertRules() {
        const valueSets = this.tank.getAllValueSets();
        for (const vs of valueSets) {
            (0, common_1.applyInsertRules)(vs, this.tank);
        }
    }
    export() {
        const valueSets = this.tank.getAllValueSets();
        for (const valueSet of valueSets) {
            try {
                this.exportValueSet(valueSet);
            }
            catch (e) {
                FSHLogger_1.logger.error(e.message, valueSet.sourceInfo);
                if (e.stack) {
                    FSHLogger_1.logger.debug(e.stack);
                }
            }
        }
        if (valueSets.length > 0) {
            FSHLogger_1.logger.info(`Converted ${valueSets.length} FHIR ValueSets.`);
        }
        return this.pkg;
    }
    exportValueSet(fshDefinition) {
        if (this.pkg.valueSets.some(vs => vs.name === fshDefinition.name)) {
            return;
        }
        const vs = new fhirtypes_1.ValueSet();
        const valueSetSD = vs.getOwnStructureDefinition(this.fisher);
        this.setMetadata(vs, fshDefinition);
        const [conceptCaretRules, otherCaretRules] = (0, lodash_1.partition)(fshDefinition.rules.filter(rule => rule instanceof rules_1.CaretValueRule), caretRule => {
            return caretRule.pathArray.length > 0;
        });
        this.setCaretRules(vs, otherCaretRules, valueSetSD);
        this.setCompose(vs, fshDefinition.rules.filter(rule => rule instanceof rules_1.ValueSetComponentRule));
        conceptCaretRules.forEach(rule => (rule.isCodeCaretRule = true));
        this.setConceptCaretRules(vs, conceptCaretRules, valueSetSD);
        if (vs.compose && vs.compose.include.length == 0) {
            throw new errors_1.ValueSetComposeError(fshDefinition.name);
        }
        // check for another value set with the same id
        // see https://www.hl7.org/fhir/resource.html#id
        if (this.pkg.valueSets.some(valueSet => vs.id === valueSet.id)) {
            FSHLogger_1.logger.error(`Multiple value sets with id ${vs.id}. Each value set must have a unique id.`, fshDefinition.sourceInfo);
        }
        (0, common_1.cleanResource)(vs, (prop) => ['_sliceName', '_primitive'].includes(prop));
        (0, common_1.checkForMultipleChoice)(fshDefinition, vs, valueSetSD);
        this.pkg.valueSets.push(vs);
        this.pkg.fshMap.set(vs.getFileName(), {
            ...fshDefinition.sourceInfo,
            fshName: fshDefinition.name,
            fshType: 'ValueSet'
        });
        return vs;
    }
}
exports.ValueSetExporter = ValueSetExporter;
//# sourceMappingURL=ValueSetExporter.js.map