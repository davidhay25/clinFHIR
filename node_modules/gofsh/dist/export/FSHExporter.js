"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FSHExporter = void 0;
const text_table_1 = __importDefault(require("text-table"));
const lodash_1 = require("lodash");
const os_1 = require("os");
const path_1 = __importDefault(require("path"));
const exportable_1 = require("../exportable");
const utils_1 = require("../utils");
const api_1 = require("../api");
const sanitize_filename_1 = __importDefault(require("sanitize-filename"));
class FSHExporter {
    constructor(fshPackage) {
        this.fshPackage = fshPackage;
    }
    export(style) {
        let files;
        switch (style) {
            case 'single-file':
                files = this.groupAsSingleFile();
                break;
            case 'group-by-fsh-type':
                files = this.groupByFSHType();
                break;
            case 'group-by-profile':
                files = this.groupByProfile();
                break;
            case 'file-per-definition':
                files = this.groupAsFilePerDefinition();
                break;
            default:
                if (style != null) {
                    utils_1.logger.warn(`Unrecognized output style "${style}". Defaulting to "by-category" style.`);
                }
                files = this.groupAsFilePerDefinition();
        }
        const writtenFiles = new Map();
        const index = [];
        files.forEach((exportables, file) => {
            const fileContent = this.writeExportableGroup(exportables);
            // Ignore empty files, and don't write them to index.txt
            if (!fileContent) {
                return;
            }
            writtenFiles.set(file, fileContent);
            exportables
                .filter(e => !(e instanceof exportable_1.ExportableAlias))
                .forEach((exportable) => {
                // The index will have the name, FSH type, and file of the entity
                index.push([
                    exportable.name,
                    exportable.constructor.name.replace('Exportable', ''),
                    file
                ]);
            });
        });
        // Alphabetically sort the index by the name of the entity
        index.sort((line1, line2) => (line1[0] > line2[0] ? 1 : -1));
        index.unshift(['Name', 'Type', 'File']);
        writtenFiles.set('index.txt', (0, text_table_1.default)(index));
        return writtenFiles;
    }
    apiExport(exportType) {
        if (exportType === 'string') {
            return this.writeExportableGroup([
                ...this.fshPackage.aliases,
                ...this.fshPackage.profiles,
                ...this.fshPackage.extensions,
                ...this.fshPackage.logicals,
                ...this.fshPackage.resources,
                ...this.fshPackage.codeSystems,
                ...this.fshPackage.valueSets,
                ...this.fshPackage.instances,
                ...this.fshPackage.invariants,
                ...this.fshPackage.mappings
            ]);
        }
        else if (exportType === 'map') {
            const fshMap = {
                aliases: '',
                invariants: new api_1.ResourceMap(),
                mappings: new api_1.ResourceMap(),
                profiles: new api_1.ResourceMap(),
                extensions: new api_1.ResourceMap(),
                logicals: new api_1.ResourceMap(),
                resources: new api_1.ResourceMap(),
                codeSystems: new api_1.ResourceMap(),
                valueSets: new api_1.ResourceMap(),
                instances: new api_1.ResourceMap()
            };
            fshMap.aliases = this.writeExportableGroup(this.fshPackage.aliases);
            for (const invariant of this.fshPackage.invariants) {
                fshMap.invariants.set(invariant.name, invariant.toFSH());
            }
            for (const mapping of this.fshPackage.mappings) {
                fshMap.mappings.set(mapping.name, mapping.toFSH());
            }
            for (const profile of this.fshPackage.profiles) {
                fshMap.profiles.set(profile.name, profile.toFSH());
            }
            for (const extension of this.fshPackage.extensions) {
                fshMap.extensions.set(extension.name, extension.toFSH());
            }
            for (const logical of this.fshPackage.logicals) {
                fshMap.logicals.set(logical.name, logical.toFSH());
            }
            for (const resource of this.fshPackage.resources) {
                fshMap.resources.set(resource.name, resource.toFSH());
            }
            for (const codeSystem of this.fshPackage.codeSystems) {
                fshMap.codeSystems.set(codeSystem.name, codeSystem.toFSH());
            }
            for (const valueSet of this.fshPackage.valueSets) {
                fshMap.valueSets.set(valueSet.name, valueSet.toFSH());
            }
            for (const instance of this.fshPackage.instances) {
                fshMap.instances.set(instance.name, instance.toFSH());
            }
            return fshMap;
        }
    }
    writeExportableGroup(exportables) {
        // Aliases are each their own "exportable", but should be joined together
        // by a single EOL, not double EOLs, and they should not be written in index.txt
        // so they are handled separately
        const [aliases, namedExportables] = (0, lodash_1.partition)(exportables, exportable => exportable instanceof exportable_1.ExportableAlias);
        return [
            aliases.map(a => a.toFSH()).join(os_1.EOL),
            namedExportables.map(e => e.toFSH()).join(`${os_1.EOL}${os_1.EOL}`)
        ]
            .join(`${os_1.EOL}${os_1.EOL}`)
            .trim();
    }
    groupAsSingleFile() {
        const results = [];
        results.push(...this.fshPackage.aliases);
        results.push(...this.fshPackage.profiles);
        results.push(...this.fshPackage.extensions);
        results.push(...this.fshPackage.logicals);
        results.push(...this.fshPackage.resources);
        results.push(...this.fshPackage.codeSystems);
        results.push(...this.fshPackage.valueSets);
        results.push(...this.fshPackage.instances);
        results.push(...this.fshPackage.invariants);
        results.push(...this.fshPackage.mappings);
        return new Map().set('resources.fsh', results);
    }
    groupAsFilePerDefinition() {
        const files = new Map();
        // Aliases, still get grouped into one file
        files.set('aliases.fsh', this.fshPackage.aliases);
        // Other definitions are each placed in an individual file
        for (const invariant of this.fshPackage.invariants) {
            const filename = path_1.default.join('invariants', `${this.cleanFileName(invariant.name)}.fsh`);
            files.set(filename, [invariant]);
        }
        for (const mapping of this.fshPackage.mappings) {
            const filename = path_1.default.join('mappings', `${this.cleanFileName(mapping.name)}.fsh`);
            files.set(filename, [mapping]);
        }
        for (const profile of this.fshPackage.profiles) {
            const filename = path_1.default.join('profiles', `${this.cleanFileName(profile.name)}.fsh`);
            files.set(filename, [profile]);
        }
        for (const extension of this.fshPackage.extensions) {
            const filename = path_1.default.join('extensions', `${this.cleanFileName(extension.name)}.fsh`);
            files.set(filename, [extension]);
        }
        for (const logical of this.fshPackage.logicals) {
            const filename = path_1.default.join('logicals', `${this.cleanFileName(logical.name)}.fsh`);
            files.set(filename, [logical]);
        }
        for (const resource of this.fshPackage.resources) {
            const filename = path_1.default.join('resources', `${this.cleanFileName(resource.name)}.fsh`);
            files.set(filename, [resource]);
        }
        for (const codeSystem of this.fshPackage.codeSystems) {
            const filename = path_1.default.join('codesystems', `${this.cleanFileName(codeSystem.name)}.fsh`);
            files.set(filename, [codeSystem]);
        }
        for (const valueSet of this.fshPackage.valueSets) {
            const filename = path_1.default.join('valuesets', `${this.cleanFileName(valueSet.name)}.fsh`);
            files.set(filename, [valueSet]);
        }
        for (const instance of this.fshPackage.instances) {
            const filename = path_1.default.join('instances', `${this.cleanFileName(instance.name)}.fsh`);
            files.set(filename, [instance]);
        }
        return files;
    }
    groupByFSHType() {
        const files = new Map();
        files.set('aliases.fsh', this.fshPackage.aliases);
        files.set('profiles.fsh', this.fshPackage.profiles);
        files.set('extensions.fsh', this.fshPackage.extensions);
        files.set('logicals.fsh', this.fshPackage.logicals);
        files.set('resources.fsh', this.fshPackage.resources);
        files.set('valueSets.fsh', this.fshPackage.valueSets);
        files.set('codeSystems.fsh', this.fshPackage.codeSystems);
        files.set('instances.fsh', this.fshPackage.instances);
        files.set('invariants.fsh', this.fshPackage.invariants);
        files.set('mappings.fsh', this.fshPackage.mappings);
        return files;
    }
    groupByProfile() {
        const files = new Map();
        // Group profiles, logicals, and resources with their related instances and invariants.
        [
            ...this.fshPackage.profiles,
            ...this.fshPackage.logicals,
            ...this.fshPackage.resources
        ].forEach(fshEntity => {
            files.set(`${this.cleanFileName(fshEntity.name)}.fsh`, [fshEntity]);
        });
        files.set('instances.fsh', []);
        const [inlineInstances, nonInlineInstances] = (0, lodash_1.partition)(this.fshPackage.instances, i => i.usage === 'Inline');
        // If a non-inline instance is an example of a profile or resource, it is written to the file
        // for that entity. Otherwise it is written to instances.fsh
        nonInlineInstances.forEach(instance => {
            if (instance.usage === 'Example' &&
                files.has(`${this.cleanFileName(instance.instanceOf)}.fsh`)) {
                files.get(`${this.cleanFileName(instance.instanceOf)}.fsh`).push(instance);
            }
            else {
                files.get('instances.fsh').push(instance);
            }
        });
        // Inline instances are written to the file they are used in, if they are only used
        // in one spot. Otherwise they go to instances.fsh
        inlineInstances.forEach(instance => {
            const usedIn = this.inlineInstanceUsedIn(instance, files);
            if (usedIn.length === 1) {
                files.get(usedIn[0]).push(instance);
            }
            else {
                files.get('instances.fsh').push(instance);
            }
        });
        // Invariants are written to the same file as the file they are used in, if they
        // are written in one spot. Otherwise they go to invariants.fsh.
        files.set('invariants.fsh', []);
        this.fshPackage.invariants.forEach(invariant => {
            const usedIn = this.invariantUsedIn(invariant, files);
            if (usedIn.length === 1) {
                files.get(usedIn[0]).push(invariant);
            }
            else {
                files.get('invariants.fsh').push(invariant);
            }
        });
        // All other artifacts are grouped by category
        files.set('aliases.fsh', this.fshPackage.aliases);
        files.set('extensions.fsh', this.fshPackage.extensions);
        files.set('valueSets.fsh', this.fshPackage.valueSets);
        files.set('codeSystems.fsh', this.fshPackage.codeSystems);
        files.set('mappings.fsh', this.fshPackage.mappings);
        return files;
    }
    cleanFileName(entityName) {
        return (0, sanitize_filename_1.default)(entityName, { replacement: '-' });
    }
    inlineInstanceUsedIn(inlineInstance, files) {
        const usedIn = [];
        files.forEach((exportables, file) => {
            exportables
                .filter(exportable => exportable instanceof exportable_1.ExportableInstance ||
                exportable instanceof exportable_1.ExportableProfile ||
                exportable instanceof exportable_1.ExportableExtension ||
                exportable instanceof exportable_1.ExportableLogical ||
                exportable instanceof exportable_1.ExportableResource)
                .forEach((resource) => {
                resource.rules.forEach(rule => {
                    if ((rule instanceof exportable_1.ExportableAssignmentRule ||
                        rule instanceof exportable_1.ExportableCaretValueRule) &&
                        rule.isInstance &&
                        rule.value === inlineInstance.name) {
                        usedIn.push(file);
                    }
                });
            });
        });
        return usedIn;
    }
    invariantUsedIn(invariant, files) {
        const usedIn = [];
        files.forEach((exportables, file) => {
            exportables
                .filter(exportable => exportable instanceof exportable_1.ExportableProfile ||
                exportable instanceof exportable_1.ExportableLogical ||
                exportable instanceof exportable_1.ExportableResource)
                .forEach((profile) => {
                profile.rules.forEach(rule => {
                    if (rule instanceof exportable_1.ExportableObeysRule && rule.keys.includes(invariant.name)) {
                        usedIn.push(file);
                    }
                });
            });
        });
        return usedIn;
    }
}
exports.FSHExporter = FSHExporter;
//# sourceMappingURL=FSHExporter.js.map