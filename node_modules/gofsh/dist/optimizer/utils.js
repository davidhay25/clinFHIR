"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.optimizeURL = optimizeURL;
exports.resolveURL = resolveURL;
exports.resolveAliasFromURL = resolveAliasFromURL;
exports.getTypesForInstancePath = getTypesForInstancePath;
exports.getTypesForCaretPath = getTypesForCaretPath;
const valid_url_1 = require("valid-url");
const fsh_sushi_1 = require("fsh-sushi");
const processor_1 = require("../processor");
const exportable_1 = require("../exportable");
const unsupportedAliasCharRegex = /[^a-zA-z0-9_\-\.]/g;
function optimizeURL(url, aliases, types, fisher, makeAlias = true) {
    var _a, _b, _c;
    if (makeAlias) {
        return (_b = (_a = resolveURL(url, types, fisher)) !== null && _a !== void 0 ? _a : resolveAliasFromURL(url, aliases)) !== null && _b !== void 0 ? _b : url;
    }
    return (_c = resolveURL(url, types, fisher)) !== null && _c !== void 0 ? _c : url;
}
/**
 * Resolves a URL to a name, if possible; otherwise returns undefined. If the URL resolves to a name,
 * but the name does not resolve back to the same URL, then return undefined since the name clashes with
 * a more preferred name. This can happen if a project defines something with the same name as a FHIR
 * definition.
 * @param url - the url to resolve
 * @param types - the allowed types to resolve against
 * @param fisher - a fisher for finding definitions to use during resolution
 * @returns {string} the name representing the URL or undefined if it cannot be resolved to a name
 */
function resolveURL(url, types, fisher) {
    var _a;
    if (url == null) {
        return;
    }
    const def = fisher.fishForFHIR(url, ...types);
    // SUSHI currently does not properly fish for CodeSystems or ValueSets represented as FSH Instances,
    // so if the URL resolves to an unsupported CodeSystem or ValueSet from the LakeOfFHIR, don't resolve it!
    // TODO: Revisit this once SUSHI correctly fishes for unsupported CodeSystems and ValueSets.
    if ((((def === null || def === void 0 ? void 0 : def.resourceType) === 'CodeSystem' && !processor_1.CodeSystemProcessor.isProcessableCodeSystem(def)) ||
        ((def === null || def === void 0 ? void 0 : def.resourceType) === 'ValueSet' && !processor_1.ValueSetProcessor.isProcessableValueSet(def))) &&
        fisher.lakeOfFHIR.fishForFHIR(url, ...types) != null) {
        return;
    }
    // NOTE: Testing against a regex from FHIR because some FHIR core definitions have names that are
    // invalid against the spec!  Good heavens!
    if (((_a = def === null || def === void 0 ? void 0 : def.name) === null || _a === void 0 ? void 0 : _a.match(/^[A-Z]([A-Za-z0-9_]){0,254}$/)) &&
        fisher.fishForMetadata(def.name, ...types).url === url) {
        return def.name;
    }
}
/**
 * Gets an alias for a url. If an alias exists, it is used. If no alias exists, an alias is generated
 * from the url
 * @param aliases - a map of existing aliases
 * @param url - the url to get
 * @param fisher - a fisher for finding definitions to use during resolution
 * @returns {string | undefined} the name representing the URL or the undefined if no alias exists or can be created
 */
function resolveAliasFromURL(url, aliases) {
    var _a, _b;
    const existingAlias = aliases.find(a => a.url === url);
    if (existingAlias) {
        return existingAlias.alias;
    }
    else {
        if (!(0, valid_url_1.isWebUri)(url)) {
            return;
        }
        // Try to construct a human readable alias from the url
        const parsedURL = new URL(url);
        const rawAlias = parsedURL.pathname && parsedURL.pathname !== '/'
            ? (_a = parsedURL.pathname) === null || _a === void 0 ? void 0 : _a.split('/').slice(parsedURL.pathname.endsWith('/') ? -2 : -1)[0]
            : (_b = parsedURL.hostname) === null || _b === void 0 ? void 0 : _b.replace('www.', '').split('.')[0];
        if (rawAlias == null) {
            return;
        }
        // Ensure the generated alias contains only supported characters and is unique
        const aliasPart = `$${rawAlias.replace(unsupportedAliasCharRegex, '-')}`;
        let counterPart = 0;
        let alias = aliasPart;
        const existingAliases = aliases.map(a => a.alias);
        while (existingAliases.includes(alias)) {
            counterPart += 1;
            alias = `${aliasPart}_${counterPart}`;
        }
        aliases.push(new exportable_1.ExportableAlias(alias, url));
        return alias;
    }
}
/**
 * Gets the element types for a given path in respect to an instance of a FHIR resource.
 * Returns undefined if it was not able to determine the types (due to missing definitions, etc.).
 * @param instance - the instance the path relates to
 * @param path - the path to the element of interest
 * @param fisher - a fisher to lookup the instance definition
 * @returns an array of types or undefined if it could not determine the types
 */
function getTypesForInstancePath(instance, path, fisher) {
    return getTypesForPath(instance.instanceOf, path, fisher);
}
/**
 * Gets the element types for a given caret path in respect to a definition and rule path.
 * Returns undefined if it was not able to determine the types (due to missing definitions, etc.).
 * @param definition - the profile, extension, valueset, or codesystem the path relates to
 * @param rulePath - the path to the element of interest to which the caret relates
 * @param caretPath - the path to the element of interest within the definitional object
 * @param fisher - a fisher to lookup the necessary definitions
 * @returns an array of types or undefined if it could not determine the types
 */
function getTypesForCaretPath(definition, rulePath, caretPath, fisher) {
    let instanceOf;
    if (definition instanceof exportable_1.ExportableProfile || definition instanceof exportable_1.ExportableExtension) {
        // We're not concerned w/ what specific element it is, just that it is an element (if there is a rulePath)
        instanceOf = (rulePath === null || rulePath === void 0 ? void 0 : rulePath.length) ? 'ElementDefinition' : 'StructureDefinition';
    }
    else if (definition instanceof exportable_1.ExportableValueSet) {
        instanceOf = 'ValueSet';
    }
    else if (definition instanceof exportable_1.ExportableCodeSystem) {
        instanceOf = 'CodeSystem';
    }
    return getTypesForPath(instanceOf, caretPath, fisher);
}
function getTypesForPath(instanceOf, path, fisher) {
    var _a, _b;
    let instanceOfDef = fisher.fishForFHIR(instanceOf);
    if ((instanceOfDef === null || instanceOfDef === void 0 ? void 0 : instanceOfDef.type) && !(((_a = instanceOfDef.snapshot) === null || _a === void 0 ? void 0 : _a.length) > 1)) {
        // StructureDefinition.fromJSON requires a snapshot, so get the definition of the base resource type instead
        instanceOfDef = fisher.fishForFHIR(instanceOfDef.type);
    }
    if ((instanceOfDef === null || instanceOfDef === void 0 ? void 0 : instanceOfDef.resourceType) === 'StructureDefinition') {
        const instanceOfSD = fsh_sushi_1.fhirtypes.StructureDefinition.fromJSON(instanceOfDef);
        // NOTE: Normalize the path to remove indices and/or slice references
        const element = instanceOfSD.findElementByPath(path.replace(/\[[^\]]+\]/g, ''), fisher);
        if (element === null || element === void 0 ? void 0 : element.contentReference) {
            return (_b = instanceOfSD.findElement(element.contentReference.slice(element.contentReference.indexOf('#') + 1))) === null || _b === void 0 ? void 0 : _b.type;
        }
        else {
            return element === null || element === void 0 ? void 0 : element.type;
        }
    }
}
//# sourceMappingURL=utils.js.map