"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
const exportable_1 = require("../../exportable");
// a ValueSetConceptComponentRule will print as multiple consecutive rules
// if there is a system, but no valuesets.
// normally, this is fine, but if more than one of those concepts has caret rules,
// split them manually so that the caret rules appear immediately after the concept. for example:
// * #BEAR from system http://example.org/zoo
// * #BEAR ^designation.value = "ourse"
// * #BEAR ^designation.language = #fr
// * #PEL from system http://example.org/zoo
// * #PEL ^designation.value = "pelÃ­cano"
// * #PEL ^designation.language = #es
exports.default = {
    name: 'separate_concepts_with_caret_rules',
    description: 'Separate concepts in ValueSets from the same system if they also have caret rules.',
    runBefore: ['resolve_value_set_component_rule_urls'],
    optimize(pkg) {
        pkg.valueSets.forEach(vs => {
            const systemRulesToCheck = vs.rules.filter(rule => {
                return (rule instanceof exportable_1.ExportableValueSetConceptComponentRule &&
                    rule.from.system != null &&
                    (0, lodash_1.isEmpty)(rule.from.valueSets) &&
                    rule.concepts.length > 1);
            });
            const allCodeCaretRules = vs.rules.filter(rule => {
                return rule instanceof exportable_1.ExportableCaretValueRule && rule.pathArray.length > 0;
            });
            if (allCodeCaretRules.length > 0) {
                systemRulesToCheck.forEach(conceptRule => {
                    // for each concept in the rule, see if there are any caret value rules.
                    const caretRulesForSystem = new Map();
                    conceptRule.concepts.forEach(concept => {
                        caretRulesForSystem.set(concept.code, allCodeCaretRules.filter(caretRule => { var _a; return (0, lodash_1.isEqual)(caretRule.pathArray, [`${(_a = conceptRule.from.system) !== null && _a !== void 0 ? _a : ''}#${concept.code}`]); }));
                    });
                    if (caretRulesForSystem.size > 1) {
                        // split apart the codes so that the ones with caret rules can be next to their concept rule
                        const reorganizedRules = [];
                        for (const concept of conceptRule.concepts) {
                            const singleConceptRule = new exportable_1.ExportableValueSetConceptComponentRule(conceptRule.inclusion);
                            singleConceptRule.from.system = conceptRule.from.system;
                            singleConceptRule.concepts = [concept];
                            // don't need to copy indent since it will always be 0
                            reorganizedRules.push(singleConceptRule);
                            for (const caretRule of caretRulesForSystem.get(concept.code)) {
                                reorganizedRules.push(caretRule);
                                vs.rules.splice(vs.rules.indexOf(caretRule), 1);
                            }
                        }
                        const originalConceptRuleIndex = vs.rules.indexOf(conceptRule);
                        vs.rules.splice(originalConceptRuleIndex, 1, ...reorganizedRules);
                    }
                });
            }
        });
    }
};
//# sourceMappingURL=SeparateConceptsWithCaretRulesOptimizer.js.map