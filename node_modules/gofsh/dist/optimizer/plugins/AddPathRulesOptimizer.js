"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const exportable_1 = require("../../exportable");
const ConstructInlineInstanceOptimizer_1 = __importDefault(require("./ConstructInlineInstanceOptimizer"));
const SimplifyArrayIndexingOptimizer_1 = __importDefault(require("./SimplifyArrayIndexingOptimizer"));
const SimplifyRulePathContextsOptimizer_1 = __importDefault(require("./SimplifyRulePathContextsOptimizer"));
// Create a tree with a node for each path part for all rules
function buildPathTree(parent, rule) {
    // We want to process each part, so split at each . not within []
    // Because we want to consider each slice and index within the path as a
    // unique path, we don't want to use the full parseFSHPath.
    const pathParts = rule.path === '.' ? [rule.path] : rule.path.split(/\.(?![^\[]*\])/g);
    let currentPath = '';
    let currentPathNode;
    pathParts.forEach(part => {
        currentPath = currentPath === '' ? part : `${currentPath}.${part}`; // build the path back up
        currentPathNode = parent.children.find(child => child.path === currentPath);
        if (currentPathNode == null) {
            // If this path hasn't been seen, create a node for it in the tree
            const newNode = { path: currentPath, children: [], rules: [] };
            parent.children.push(newNode);
            currentPathNode = newNode;
        }
        // Use the current path's node as the parent for the next path part
        parent = currentPathNode;
    });
    // After building the tree, add the rule in at the current node
    // since the last node will be the full rule path
    currentPathNode.rules = currentPathNode.rules.concat(rule);
}
// Build the list of rules that will create optimal context.
function createAndOrganizeRules(pathNodes, rules) {
    pathNodes === null || pathNodes === void 0 ? void 0 : pathNodes.forEach(node => {
        rules.push(...node.rules);
        if (node.children.length > 1 && node.rules.length === 0) {
            // There are at least 2 children and no parent rule. Push a path rule.
            rules.push(new exportable_1.ExportablePathRule(node.path));
        }
        createAndOrganizeRules(node.children, rules);
    });
}
exports.default = {
    name: 'add_path_rules',
    description: 'Add path rules to support indenting.',
    runAfter: [ConstructInlineInstanceOptimizer_1.default.name],
    runBefore: [SimplifyArrayIndexingOptimizer_1.default.name, SimplifyRulePathContextsOptimizer_1.default.name],
    optimize(pkg) {
        [
            ...pkg.profiles,
            ...pkg.extensions,
            ...pkg.logicals,
            ...pkg.resources,
            ...pkg.instances,
            ...pkg.mappings
        ].forEach(entity => {
            const root = {
                path: '',
                rules: [],
                children: []
            };
            // Build a tree of paths used in rules
            entity.rules.forEach(rule => {
                buildPathTree(root, rule);
            });
            // Create a new list of rules which will have optimal path context.
            // This may mean adding path rules as necessary and changing the order
            // of rules in order to optimize context.
            const rulesWithPathRules = [];
            createAndOrganizeRules(root.children, rulesWithPathRules);
            entity.rules = rulesWithPathRules;
        });
    },
    isEnabled(options) {
        return options.indent === true;
    }
};
//# sourceMappingURL=AddPathRulesOptimizer.js.map