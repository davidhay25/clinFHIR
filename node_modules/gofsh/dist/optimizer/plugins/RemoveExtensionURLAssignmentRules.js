"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const exportable_1 = require("../../exportable");
const utils_1 = require("../../utils");
const lodash_1 = require("lodash");
const valid_url_1 = require("valid-url");
const fsh_sushi_1 = require("fsh-sushi");
// Loop over all profiles and extensions, removing assignment rules on inline extensions
// NOTE: Inline extensions on a profile are allowed by SUSHI, but they are technically not
// valid FHIR and the IG Publisher does not like this
exports.default = {
    name: 'remove_extension_url_assignment_rules',
    description: 'Remove assignment rules on inline extension "url" paths since SUSHI automatically applies these',
    optimize(pkg, fisher) {
        var _a, _b;
        [...pkg.profiles, ...pkg.extensions].forEach(sd => {
            const rulesToRemove = [];
            sd.rules.forEach(rule => {
                if (rule instanceof exportable_1.ExportableContainsRule && /(modifierE|e)xtension$/.test(rule.path)) {
                    rule.items.forEach(item => {
                        var _a;
                        const assignmentRuleIdx = sd.rules.findIndex(other => other instanceof exportable_1.ExportableAssignmentRule &&
                            other.path === `${rule.path}[${item.name}].url`);
                        if (assignmentRuleIdx >= 0) {
                            rulesToRemove.push(assignmentRuleIdx);
                            const urlRule = sd.rules[assignmentRuleIdx];
                            if (!item.type && (0, valid_url_1.isUri)(urlRule.value)) {
                                item.type = (_a = fisher.fishForMetadata(urlRule.value, fsh_sushi_1.utils.Type.Extension)) === null || _a === void 0 ? void 0 : _a.name;
                                if (item.type) {
                                    utils_1.logger.warn(`${sd.name}: Extension at "${rule.path}[${item.name}]" refers to ${urlRule.value} but does not set this value in type.profile. ` +
                                        'The generated "contains" rule will be updated to use the "named" syntax so that SUSHI can process it without error. ' +
                                        'This will cause type.profile to be set on the SUSHI output, which is likely the desired behavior. If this is not desired, ' +
                                        'the generated FSH will have to be manually updated.');
                                }
                            }
                            else if (urlRule.value !== item.name) {
                                utils_1.logger.error(`${sd.name}: Inline extension at "${rule.path}[${item.name}]" has sliceName "${item.name}" but ` +
                                    `"${urlRule.value}" is assigned to url. SUSHI requires that these values match exactly, so the value assigned to the url ` +
                                    'will be used as the sliceName.');
                                // If the value set by the url rule and the sliceName do not match, prefer the value set by the url rule
                                // and replace all occurrences of the old sliceName in other rules
                                const newSliceName = urlRule.value;
                                [...sd.rules, ...rule.cardRules, ...rule.flagRules].forEach(r => {
                                    r.path = r.path.replace(new RegExp(`^${rule.path}\\[${item.name}\\]`), `${rule.path}[${newSliceName}]`);
                                });
                                item.name = newSliceName;
                            }
                        }
                    });
                }
            });
            (0, lodash_1.pullAt)(sd.rules, rulesToRemove);
        });
        // We must know the configuration to determine if a rule assigning "url" matches the url that SUSHI will assume
        if ((_b = (_a = pkg.configuration) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.canonical) {
            pkg.extensions.forEach(extension => {
                const rulesToRemove = [];
                extension.rules.forEach((rule, i) => {
                    if (rule instanceof exportable_1.ExportableAssignmentRule &&
                        rule.path === 'url' &&
                        rule.value ===
                            `${pkg.configuration.config.canonical}/StructureDefinition/${extension.id}`) {
                        rulesToRemove.push(i);
                    }
                });
                (0, lodash_1.pullAt)(extension.rules, rulesToRemove);
            });
        }
    }
};
//# sourceMappingURL=RemoveExtensionURLAssignmentRules.js.map