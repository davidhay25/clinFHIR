"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const exportable_1 = require("../../exportable");
const lodash_1 = require("lodash");
const fsh_sushi_1 = require("fsh-sushi");
// Choice elements have a standard set of slicing rules applied to them by SUSHI.
// Therefore, it is not necessary to define that slicing using FSH when one of the choices exists.
// If the full set of four default rules exists for the same element, remove those rules.
exports.default = {
    name: 'remove_choice_slicing_rules',
    description: 'Remove standard choice slicing rules that SUSHI automatically applies to choices',
    optimize(pkg) {
        [...pkg.profiles, ...pkg.extensions].forEach(sd => {
            const rulesToMaybeRemove = [];
            sd.rules.forEach((rule, i, allRules) => {
                if (rule instanceof exportable_1.ExportableCaretValueRule && rule.path.endsWith('[x]')) {
                    const pathStart = rule.path.replace(/\[x\]$/, '');
                    // check the four relevant caret paths and their default values, and
                    // check if one of the choices exists
                    if (((rule.caretPath === 'slicing.discriminator[0].type' &&
                        rule.value instanceof fsh_sushi_1.fshtypes.FshCode &&
                        rule.value.code === 'type') ||
                        (rule.caretPath === 'slicing.discriminator[0].path' && rule.value === '$this') ||
                        (rule.caretPath === 'slicing.ordered' && rule.value === false) ||
                        (rule.caretPath === 'slicing.rules' &&
                            rule.value instanceof fsh_sushi_1.fshtypes.FshCode &&
                            rule.value.code === 'open')) &&
                        allRules.some(otherRule => !otherRule.path.startsWith(rule.path) && otherRule.path.startsWith(pathStart))) {
                        rulesToMaybeRemove.push(i);
                    }
                }
            });
            // if four rules to maybe remove have the same path, then that's a full set of defaults, and they are removed
            const rulesToRemove = (0, lodash_1.flatten)((0, lodash_1.values)((0, lodash_1.groupBy)(rulesToMaybeRemove, i => sd.rules[i].path)).filter(ruleGroup => ruleGroup.length === 4));
            (0, lodash_1.pullAt)(sd.rules, rulesToRemove);
        });
    }
};
//# sourceMappingURL=RemoveChoiceSlicingRulesOptimizer.js.map