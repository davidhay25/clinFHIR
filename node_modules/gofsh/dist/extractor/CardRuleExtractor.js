"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CardRuleExtractor = void 0;
const exportable_1 = require("../exportable");
const utils_1 = require("../utils");
class CardRuleExtractor {
    static process(input, structDef, fisher, removeInferredSlicedMin = true) {
        if (input.min || input.max) {
            const cardRule = new exportable_1.ExportableCardRule((0, utils_1.getPath)(input));
            if (input.min != null) {
                cardRule.min = input.min;
                input.processedPaths.push('min');
            }
            if (input.max != null) {
                cardRule.max = input.max;
                input.processedPaths.push('max');
            }
            // SUSHI will automatically create a card rule if all of the following is true:
            // - this is a sliced element
            // - there is a cardinality rule on at least one of the slices
            // - the min on this element matches the sum of the mins on all slices
            // If we reach this condition, don't output a card min since SUSHI will do it.
            // Technically this is an optimization, but the optimizations don't have access to
            // the full SD, and we need the full SD to get the sum of all slices (including
            // inherited slices)
            if (removeInferredSlicedMin &&
                hasSlicesWithConstrainedCards(input, structDef) &&
                isSliced(input, structDef, fisher)) {
                const sumOfMins = getSumOfSliceMins(input, structDef, fisher);
                if (sumOfMins === input.min) {
                    if (cardRule.max == null) {
                        // No min or max, so return null card rule
                        return null;
                    }
                    // has a max, so return cardRule without the min
                    cardRule.min = undefined;
                }
            }
            return cardRule;
        }
        else {
            return null;
        }
    }
}
exports.CardRuleExtractor = CardRuleExtractor;
function hasSlicesWithConstrainedCards(input, structDef) {
    var _a, _b;
    return (_b = (_a = structDef === null || structDef === void 0 ? void 0 : structDef.differential) === null || _a === void 0 ? void 0 : _a.element) === null || _b === void 0 ? void 0 : _b.some(el => el.path == input.path &&
        el.id != input.id &&
        el.sliceName != null &&
        (el.min != null || el.max != null));
}
function isSliced(input, structDef, fisher) {
    var _a, _b, _c, _d;
    for (let currentStructDef = structDef; currentStructDef != null; currentStructDef = fisher.fishForFHIR(currentStructDef.baseDefinition)) {
        // If the element is in the snapshot, then presence or lack of slicing is conclusive
        const snapshotEl = (_b = (_a = currentStructDef.snapshot) === null || _a === void 0 ? void 0 : _a.element) === null || _b === void 0 ? void 0 : _b.find(el => el.id === input.id);
        if (snapshotEl) {
            return snapshotEl.slicing != null;
        }
        else {
            // The differential is only conclusive in the positive case, otherwise it could still be inherited from a parent
            const differentialEl = (_d = (_c = currentStructDef.differential) === null || _c === void 0 ? void 0 : _c.element) === null || _d === void 0 ? void 0 : _d.find(el => el.id === input.id);
            if ((differentialEl === null || differentialEl === void 0 ? void 0 : differentialEl.slicing) != null) {
                return true;
            }
        }
    }
    return false;
}
function getSumOfSliceMins(input, structDef, fisher) {
    var _a, _b, _c;
    let sum = 0;
    const countedSlices = new Set();
    for (let currentStructDef = structDef; currentStructDef != null; currentStructDef = fisher.fishForFHIR(currentStructDef.baseDefinition)) {
        const uncountedSlicesWithMins = (_c = (_b = ((_a = currentStructDef.snapshot) !== null && _a !== void 0 ? _a : currentStructDef.differential)) === null || _b === void 0 ? void 0 : _b.element) === null || _c === void 0 ? void 0 : _c.filter(el => el.path === input.path &&
            el.sliceName != null &&
            el.min != null &&
            !countedSlices.has(el.sliceName));
        uncountedSlicesWithMins.forEach(slice => {
            sum += slice.min;
            countedSlices.add(slice.sliceName);
        });
        if (currentStructDef.snapshot != null) {
            break;
        }
    }
    return sum;
}
//# sourceMappingURL=CardRuleExtractor.js.map