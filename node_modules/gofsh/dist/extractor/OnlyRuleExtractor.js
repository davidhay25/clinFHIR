"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OnlyRuleExtractor = void 0;
const exportable_1 = require("../exportable");
const utils_1 = require("../utils");
class OnlyRuleExtractor {
    static process(input) {
        if (!input.type) {
            return null;
        }
        const onlyRule = new exportable_1.ExportableOnlyRule((0, utils_1.getPath)(input));
        input.type.forEach((t, i) => {
            if (['Reference', 'CodeableReference', 'canonical'].includes(t.code) && t.targetProfile) {
                const targeting = {};
                if (t.code === 'Reference') {
                    targeting.isReference = true;
                }
                else if (t.code === 'CodeableReference') {
                    targeting.isCodeableReference = true;
                }
                else {
                    targeting.isCanonical = true;
                }
                t.targetProfile.forEach((tp, tpi) => {
                    onlyRule.types.push(Object.assign({ type: tp }, targeting));
                    input.processedPaths.push(`type[${i}].targetProfile[${tpi}]`);
                });
            }
            else if (t.profile) {
                t.profile.forEach((p, pi) => {
                    onlyRule.types.push({ type: p });
                    input.processedPaths.push(`type[${i}].profile[${pi}]`);
                });
            }
            else {
                onlyRule.types.push({ type: t.code });
            }
            input.processedPaths.push(`type[${i}].code`);
        });
        return onlyRule;
    }
}
exports.OnlyRuleExtractor = OnlyRuleExtractor;
//# sourceMappingURL=OnlyRuleExtractor.js.map