"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigurationExtractor = void 0;
const lodash_1 = require("lodash");
const fsh_sushi_1 = require("fsh-sushi");
const GoFSHLogger_1 = require("../utils/GoFSHLogger");
const exportable_1 = require("../exportable");
class ConfigurationExtractor {
    static process(resources, specifiedFHIRVersion) {
        var _a, _b, _c, _d, _e;
        const igResource = ConfigurationExtractor.getIGResource(resources);
        const missingIGProperties = [];
        if (igResource && !igResource.url) {
            missingIGProperties.push('url');
        }
        let fhirVersion = (_a = igResource === null || igResource === void 0 ? void 0 : igResource.fhirVersion) === null || _a === void 0 ? void 0 : _a.filter((v) => {
            if (!fsh_sushi_1.utils.isSupportedFHIRVersion(v)) {
                GoFSHLogger_1.logger.warn(`Unsupported fhirVersion ${v} in ImplementationGuide will be ignored.`);
                return false;
            }
            return true;
        });
        if (igResource && !(fhirVersion === null || fhirVersion === void 0 ? void 0 : fhirVersion.length)) {
            missingIGProperties.push('fhirVersion');
        }
        if (missingIGProperties.length > 0) {
            GoFSHLogger_1.logger.warn(`ImplementationGuide missing properties needed to generate configuration file: ${missingIGProperties.join(', ')}. These properties will be inferred based on FHIR definitions.`);
        }
        // canonical and fhirVersion are required elements in configuration, so they get defaults
        const canonical = (_c = (_b = igResource === null || igResource === void 0 ? void 0 : igResource.url) === null || _b === void 0 ? void 0 : _b.replace(/\/ImplementationGuide\/[^/]+$/, '')) !== null && _c !== void 0 ? _c : (ConfigurationExtractor.inferCanonical(resources) || 'http://example.org');
        if (!(fhirVersion === null || fhirVersion === void 0 ? void 0 : fhirVersion.length)) {
            const fhirVersionFromResources = ConfigurationExtractor.inferString(resources, 'fhirVersion');
            if (fsh_sushi_1.utils.isSupportedFHIRVersion(fhirVersionFromResources)) {
                fhirVersion = [fhirVersionFromResources];
            }
        }
        if (specifiedFHIRVersion) {
            // If there is a detected version, check if it matches the specified version
            if ((fhirVersion === null || fhirVersion === void 0 ? void 0 : fhirVersion.length) && fhirVersion.indexOf(specifiedFHIRVersion) === -1) {
                GoFSHLogger_1.logger.warn(`FHIR Version mismatch warning: specified version is: ${specifiedFHIRVersion} while detected version is: ${fhirVersion.join(', ')}. GoFSH will use the specified version (${specifiedFHIRVersion}), but this may result in additional processing errors.`);
            }
            fhirVersion = [specifiedFHIRVersion];
        }
        //if fhirVersion is still not known, default to 4.0.1
        if (!(fhirVersion === null || fhirVersion === void 0 ? void 0 : fhirVersion.length)) {
            fhirVersion = ['4.0.1'];
            if (!specifiedFHIRVersion) {
                GoFSHLogger_1.logger.warn(`Could not determine FHIR version. Using ${fhirVersion[0]}.`);
            }
        }
        GoFSHLogger_1.logger.info(`Using FHIR Version ${fhirVersion[0]}`);
        const config = new exportable_1.ExportableConfiguration({
            canonical: canonical,
            fhirVersion: fhirVersion,
            FSHOnly: true,
            applyExtensionMetadataToRoot: false
        });
        if (igResource) {
            config.config.id = igResource.id;
            config.config.name = igResource.name;
        }
        else {
            // infer name and id using canonical
            Object.assign(config.config, ConfigurationExtractor.inferNameAndId(canonical));
        }
        // infer status and version from most common values
        const status = (_d = igResource === null || igResource === void 0 ? void 0 : igResource.status) !== null && _d !== void 0 ? _d : ConfigurationExtractor.inferString(resources, 'status');
        if (status) {
            config.config.status = status;
        }
        const version = (_e = igResource === null || igResource === void 0 ? void 0 : igResource.version) !== null && _e !== void 0 ? _e : ConfigurationExtractor.inferString(resources, 'version');
        if (version) {
            config.config.version = version;
        }
        const dependencies = igResource === null || igResource === void 0 ? void 0 : igResource.dependsOn;
        if (dependencies) {
            config.config.dependencies = dependencies;
        }
        return config;
    }
    static inferCanonical(resources) {
        const potentialCanonicals = [];
        resources.forEach(resource => {
            if (resource.url) {
                potentialCanonicals.push(resource.url
                    .toString()
                    .replace(/\/(StructureDefinition|ValueSet|CodeSystem|ImplementationGuide)\/[^/]+$/, ''));
            }
        });
        return ConfigurationExtractor.getStringMode(potentialCanonicals);
    }
    static inferString(resources, path) {
        const potentialStrings = [];
        resources.forEach(resource => {
            if (resource[path]) {
                potentialStrings.push(resource[path].toString());
            }
        });
        return ConfigurationExtractor.getStringMode(potentialStrings);
    }
    // The regular expression for matching the canonical won't behave perfectly in all cases,
    // due to the sheer variety of possible valid URLs. But, it tries its best.
    static inferNameAndId(canonical) {
        var _a, _b;
        const canonicalMatch = canonical.match(/^https?:\/\/([\w.]+)(\/.*)?$/);
        if (canonicalMatch) {
            const hostParts = canonicalMatch[1].split('.').slice(0, -1);
            const pathParts = (_b = (_a = canonicalMatch[2]) === null || _a === void 0 ? void 0 : _a.split('/').filter(part => part.length > 0)) !== null && _b !== void 0 ? _b : [];
            const idParts = [
                ...(0, lodash_1.filter)(hostParts, part => part.length > 2 && part !== 'www'),
                ...(0, lodash_1.filter)(pathParts, part => part.length > 0)
            ];
            // Many IGs are hosted at a URL that starts with http://hl7.org/fhir/
            // However, they generally do not include "hl7" and "fhir" at the start of their name.
            // So, if the first two idParts are "hl7" and "fhir" don't use them in the name.
            const id = idParts.join('.');
            const name = ((idParts === null || idParts === void 0 ? void 0 : idParts[0]) === 'hl7' && (idParts === null || idParts === void 0 ? void 0 : idParts[1]) === 'fhir' ? idParts.slice(2) : idParts)
                .map(lodash_1.capitalize)
                .join('');
            return { name, id };
        }
        else {
            return {};
        }
    }
    static getStringMode(potentials) {
        if (potentials.length > 0) {
            // Example results after each function
            //   potentials: ['foo', 'bar', 'baz', 'foo', 'bar', 'bar']
            //   countBy:    { 'foo': 2, 'bar': 3, 'baz': 1 }
            //   toPairs:    [ ['foo', 2], ['bar': 3], ['baz': 1] ]
            //   maxBy:      ['bar', 3]
            //   maxyBy[0]:  'bar'
            return (0, lodash_1.maxBy)((0, lodash_1.toPairs)((0, lodash_1.countBy)(potentials)), pair => pair[1])[0];
        }
        else {
            return '';
        }
    }
    static getIGResource(resources) {
        return resources.find(r => r.resourceType === 'ImplementationGuide');
    }
}
exports.ConfigurationExtractor = ConfigurationExtractor;
//# sourceMappingURL=ConfigurationExtractor.js.map