"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InvariantExtractor = void 0;
const fsh_sushi_1 = require("fsh-sushi");
const lodash_1 = require("lodash");
const ExportableInvariant_1 = require("../exportable/ExportableInvariant");
const processor_1 = require("../processor");
const utils_1 = require("../utils");
const exportable_1 = require("../exportable");
class InvariantExtractor {
    static process(input, structDef, existingInvariants, fisher) {
        var _a;
        const invariants = [];
        if (((_a = input.constraint) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            input.constraint.forEach((constraint, i) => {
                // clone the constraint so we can take it apart as we work with it
                const workingConstraint = (0, lodash_1.cloneDeep)(constraint);
                const constraintPaths = [];
                // required: key, human, severity
                const invariant = new ExportableInvariant_1.ExportableInvariant(workingConstraint.key);
                invariant.description = workingConstraint.human;
                invariant.severity = new fsh_sushi_1.fshtypes.FshCode(workingConstraint.severity);
                constraintPaths.push(`constraint[${i}].key`, `constraint[${i}].human`, `constraint[${i}].severity`);
                delete workingConstraint.key;
                delete workingConstraint.human;
                delete workingConstraint.severity;
                // optional: expression, xpath
                if (workingConstraint.expression) {
                    invariant.expression = workingConstraint.expression;
                    constraintPaths.push(`constraint[${i}].expression`);
                    delete workingConstraint.expression;
                }
                if (workingConstraint.xpath) {
                    invariant.xpath = workingConstraint.xpath;
                    constraintPaths.push(`constraint[${i}].xpath`);
                    delete workingConstraint.xpath;
                }
                // SUSHI autopopulates source to the current SD URL, so as long as it matches, mark that path as processed
                if (workingConstraint.source == null || workingConstraint.source === structDef.url) {
                    constraintPaths.push(`constraint[${i}].source`);
                    delete workingConstraint.source;
                }
                // other properties are created with rules on the invariant
                // since we're already inside the ElementDefinition, we have to manually prepend "constraint" to the path
                // so that we can get the FSH value correctly.
                // but, we want the original path for the rule itself.
                const flatPropertyArray = (0, lodash_1.toPairs)((0, utils_1.getPathValuePairs)(workingConstraint, x => `constraint[${i}].${x}`));
                const elementPath = (0, utils_1.getPath)(input);
                const entityPath = elementPath === '.' ? structDef.name : `${structDef.name}.${elementPath}`;
                flatPropertyArray.forEach(([path], propertyIdx) => {
                    const originalPath = path.replace(`constraint[${i}].`, '');
                    const assignmentRule = new exportable_1.ExportableAssignmentRule(originalPath);
                    assignmentRule.value = (0, utils_1.getFSHValue)(propertyIdx, flatPropertyArray, 'ElementDefinition', entityPath, fisher);
                    if (!(0, utils_1.isFSHValueEmpty)(assignmentRule.value)) {
                        invariant.rules.push(assignmentRule);
                    }
                    constraintPaths.push(path);
                });
                (0, processor_1.switchQuantityRules)(invariant.rules);
                // if an invariant with this key already exists, don't make a new invariant with the same key.
                // if the new invariant would be an exact match of the existing invariant, mark the paths as
                // processed so an ObeysRule is created and no CaretValueRules are created.
                // if the new invariant has a key match but isn't an exact match, it will be created using CaretValueRules.
                const matchingKeyInvariant = [...existingInvariants, ...invariants].find(inv => inv.name === invariant.name);
                if (matchingKeyInvariant) {
                    if ((0, lodash_1.isEqual)(matchingKeyInvariant, invariant)) {
                        input.processedPaths.push(...constraintPaths);
                    }
                }
                else {
                    input.processedPaths.push(...constraintPaths);
                    invariants.push(invariant);
                }
            });
        }
        return invariants;
    }
}
exports.InvariantExtractor = InvariantExtractor;
//# sourceMappingURL=InvariantExtractor.js.map