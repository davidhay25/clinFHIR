"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AddElementRuleExtractor = void 0;
const lodash_1 = require("lodash");
const exportable_1 = require("../exportable");
const utils_1 = require("../utils");
const _1 = require(".");
const OnlyRuleExtractor_1 = require("./OnlyRuleExtractor");
class AddElementRuleExtractor {
    static process(input, structDef) {
        var _a, _b;
        const addElementRule = new exportable_1.ExportableAddElementRule((0, utils_1.getPath)(input));
        // we always have cardinality
        // don't use CardRuleExtractor here, since that has extra logic
        // that we don't want to use.
        addElementRule.min = input.min;
        addElementRule.max = input.max;
        input.processedPaths.push('min', 'max');
        // get types using OnlyRuleExtractor
        addElementRule.types = (_b = (_a = OnlyRuleExtractor_1.OnlyRuleExtractor.process(input)) === null || _a === void 0 ? void 0 : _a.types) !== null && _b !== void 0 ? _b : [];
        if (input.contentReference) {
            if ((0, lodash_1.isEmpty)(addElementRule.types)) {
                addElementRule.contentReference = input.contentReference;
            }
            else {
                utils_1.logger.warn(`Found types and contentReference for element ${input.id} in ${structDef.name}. The contentReference will be ignored.`);
            }
            input.processedPaths.push('contentReference');
        }
        // if types and contentReference were missing, default to BackboneElement
        if ((0, lodash_1.isEmpty)(addElementRule.types) && (0, lodash_1.isEmpty)(addElementRule.contentReference)) {
            addElementRule.types = [{ type: 'BackboneElement' }];
            utils_1.logger.warn(`No types or contentReference found for element ${input.id} in ${structDef.name}. Defaulting to BackboneElement.`);
        }
        // we might have flags, so use FlagRuleExtractor
        const flagRule = _1.FlagRuleExtractor.process(input);
        if (flagRule) {
            Object.assign(addElementRule, flagRule);
        }
        // we might have short and definition
        if (input.short) {
            addElementRule.short = input.short;
            input.processedPaths.push('short');
        }
        if (input.definition) {
            addElementRule.definition = input.definition;
            input.processedPaths.push('definition');
        }
        return addElementRule;
    }
}
exports.AddElementRuleExtractor = AddElementRuleExtractor;
//# sourceMappingURL=AddElementRuleExtractor.js.map