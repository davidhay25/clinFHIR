"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.instantRegex = exports.timeRegex = exports.dateRegex = exports.dateTimeRegex = void 0;
exports.getPath = getPath;
exports.getPathValuePairs = getPathValuePairs;
exports.getFSHValue = getFSHValue;
exports.isFSHValueEmpty = isFSHValueEmpty;
exports.getAncestorElement = getAncestorElement;
exports.getCardinality = getCardinality;
exports.getAncestorSliceDefinition = getAncestorSliceDefinition;
const flat_1 = require("flat");
const lodash_1 = require("lodash");
const fsh_sushi_1 = require("fsh-sushi");
const GoFSHLogger_1 = require("./GoFSHLogger");
// See https://hl7.org/fhir/R5/datatypes.html#dateTime
exports.dateTimeRegex = /^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$/;
// See https://hl7.org/fhir/R5/datatypes.html#date
exports.dateRegex = /^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$/;
// See https://hl7.org/fhir/R5/datatypes.html#time
exports.timeRegex = /^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?$/;
// See https://hl7.org/fhir/R5/datatypes.html#instant
exports.instantRegex = /^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]{1,9})?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))$/;
// This function depends on the id of an element to construct the path.
// Per the specification https://www.hl7.org/fhir/elementdefinition.html#id, we should
// be able to assume that id will exist and each token will have the form pathpart:slicename/reslicename
function getPath(element) {
    const FHIRtokens = element.id.split('.').slice(1);
    // If the id is for the root element (ex "Observation"), we specify that path in FSH as "."
    if (!FHIRtokens.length) {
        return '.';
    }
    const FSHtokens = [];
    FHIRtokens.forEach(FHIRtoken => {
        const [pathPart, slicePart] = FHIRtoken.split(':', 2);
        const sliceTokens = slicePart === null || slicePart === void 0 ? void 0 : slicePart.split('/');
        // If this is a sliced choice element, we use the sliceName for the path
        // value[x]:valueString -> valueString
        if (pathPart.endsWith('[x]') && (sliceTokens === null || sliceTokens === void 0 ? void 0 : sliceTokens.length)) {
            FSHtokens.push(sliceTokens[0]);
            return;
        }
        // Construct the FSHToken to be equivalent to the FHIR token except:
        // - Use [] for slicing and reslicing (instead of ':' and '/')
        // - Remove leading '_' since FSH does not require them in its paths
        let FSHToken = pathPart.replace(/^_/, '');
        sliceTokens === null || sliceTokens === void 0 ? void 0 : sliceTokens.forEach(sliceToken => (FSHToken += `[${sliceToken}]`));
        FSHtokens.push(FSHToken);
    });
    return FSHtokens.join('.');
}
function getPathValuePairs(originalObject, keyConverter = identityKey) {
    const flatObject = (0, flat_1.flatten)(originalObject, { safe: true });
    const flatFSHObject = {};
    Object.keys(flatObject)
        .filter(key => flatObject[key] != null)
        .forEach(key => {
        const newKey = keyConverter(key).replace(/(^|\.)_/g, (_, sep) => `${sep}`);
        if (Array.isArray(flatObject[key])) {
            const subFlat = getPathValuePairs(flatObject[key], arrayIndexKey);
            Object.keys(subFlat).forEach(subKey => {
                if (subFlat[subKey] != null) {
                    const combinedKey = newKey + subKey;
                    flatFSHObject[combinedKey] = subFlat[subKey];
                }
            });
        }
        else {
            flatFSHObject[newKey] = flatObject[key];
        }
    });
    return flatFSHObject;
}
function identityKey(key) {
    return key;
}
function arrayIndexKey(key) {
    const splitKey = key.split('.');
    splitKey[0] = `[${splitKey[0]}]`;
    return splitKey.join('.');
}
const typeCache = new Map();
function getFSHValue(index, flatArray, resourceType, resourceName, fisher) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
    const [key, value] = flatArray[index];
    const fishingType = resourceType === 'Concept' ? 'CodeSystem' : resourceType;
    // Finding element by path works without array information (note: leading _ has been removed by this point)
    let pathWithoutIndex = key.replace(/\[\d+\]/g, '');
    if (resourceType === 'Concept') {
        pathWithoutIndex = `concept.${pathWithoutIndex}`;
    }
    // If we have already looked up this path for this resource, get it from cache
    const type = (_a = typeCache.get(resourceType)) === null || _a === void 0 ? void 0 : _a.get(pathWithoutIndex);
    if (type === 'code') {
        return new fsh_sushi_1.fshtypes.FshCode(value.toString());
    }
    else if (type === 'integer64') {
        return BigInt(value);
    }
    else if (type === 'dateTime') {
        if (!exports.dateTimeRegex.test(value.toString())) {
            GoFSHLogger_1.logger.warn(`Value ${value.toString()} on ${resourceName} element ${key} is not a valid FHIR dateTime`);
        }
        return value;
    }
    else if (type === 'date') {
        if (!exports.dateRegex.test(value.toString())) {
            GoFSHLogger_1.logger.warn(`Value ${value.toString()} on ${resourceName} element ${key} is not a valid FHIR date`);
        }
        return value;
    }
    else if (type === 'time') {
        if (!exports.timeRegex.test(value.toString())) {
            GoFSHLogger_1.logger.warn(`Value ${value.toString()} on ${resourceName} element ${key} is not a valid FHIR time`);
        }
        return value;
    }
    else if (type === 'instant') {
        typeCache.get(resourceType).set(pathWithoutIndex, 'instant');
        if (!exports.instantRegex.test(value.toString())) {
            GoFSHLogger_1.logger.warn(`Value ${value.toString()} on ${resourceName} element ${key} is not a valid FHIR instant`);
        }
        return value;
    }
    else if (type) {
        return value;
    }
    // If the path is one on an entry/contained resource, find the element on the ResourceType of the entry/contained resource
    if (pathWithoutIndex.startsWith('entry.resource.') ||
        pathWithoutIndex.startsWith('parameter.resource.') ||
        pathWithoutIndex.startsWith('contained.')) {
        const [, baseKey, newKey] = key.match(/^((?:entry|parameter)\[\d+\].resource|contained\[\d+\])\.(.+)/);
        // We can safely assume that all of the paths for a given contained resource are
        // sequential in the flatArray, so find the start and end of that sequence and slice it out
        const nestedResourceStartIndex = flatArray.findIndex(([key]) => key.startsWith(baseKey));
        let nestedResourceEndIndex = nestedResourceStartIndex + 1;
        while ((_b = flatArray[nestedResourceEndIndex]) === null || _b === void 0 ? void 0 : _b[0].startsWith(baseKey)) {
            nestedResourceEndIndex++;
        }
        const subArray = flatArray
            .slice(nestedResourceStartIndex, nestedResourceEndIndex)
            .map(([key, value]) => [
            key.replace(/^((entry|parameter)\[\d+\].resource|contained\[\d+\])\./, ''),
            value
        ]);
        const containedResourceType = (_c = subArray.find(([key]) => key === 'resourceType')) === null || _c === void 0 ? void 0 : _c[1];
        const newIndex = subArray.findIndex(([key]) => key === newKey);
        const containedResourceName = `${resourceName}.${baseKey}`;
        // Get the FSH value based on the contained resource type. Use paths relative to the contained resource.
        return getFSHValue(newIndex, subArray, containedResourceType, containedResourceName, fisher);
    }
    if (!typeCache.has(resourceType)) {
        typeCache.set(resourceType, new Map());
    }
    const definition = fsh_sushi_1.fhirtypes.StructureDefinition.fromJSON(fisher.fishForFHIR(fishingType, fsh_sushi_1.utils.Type.Resource, fsh_sushi_1.utils.Type.Type));
    const element = definition.findElementByPath(pathWithoutIndex, fisher);
    if (((_e = (_d = element === null || element === void 0 ? void 0 : element.type) === null || _d === void 0 ? void 0 : _d[0]) === null || _e === void 0 ? void 0 : _e.code) === 'code') {
        typeCache.get(resourceType).set(pathWithoutIndex, 'code');
        return new fsh_sushi_1.fshtypes.FshCode(value.toString());
    }
    else if (((_g = (_f = element === null || element === void 0 ? void 0 : element.type) === null || _f === void 0 ? void 0 : _f[0]) === null || _g === void 0 ? void 0 : _g.code) === 'integer64') {
        typeCache.get(resourceType).set(pathWithoutIndex, 'integer64');
        return BigInt(value);
    }
    else if (((_j = (_h = element === null || element === void 0 ? void 0 : element.type) === null || _h === void 0 ? void 0 : _h[0]) === null || _j === void 0 ? void 0 : _j.code) === 'dateTime') {
        typeCache.get(resourceType).set(pathWithoutIndex, 'dateTime');
        if (!exports.dateTimeRegex.test(value.toString())) {
            GoFSHLogger_1.logger.warn(`Value ${value.toString()} on ${resourceName} element ${key} is not a valid FHIR dateTime`);
        }
        return value;
    }
    else if (((_l = (_k = element === null || element === void 0 ? void 0 : element.type) === null || _k === void 0 ? void 0 : _k[0]) === null || _l === void 0 ? void 0 : _l.code) === 'date') {
        typeCache.get(resourceType).set(pathWithoutIndex, 'date');
        if (!exports.dateRegex.test(value.toString())) {
            GoFSHLogger_1.logger.warn(`Value ${value.toString()} on ${resourceName} element ${key} is not a valid FHIR date`);
        }
        return value;
    }
    else if (((_o = (_m = element === null || element === void 0 ? void 0 : element.type) === null || _m === void 0 ? void 0 : _m[0]) === null || _o === void 0 ? void 0 : _o.code) === 'time') {
        typeCache.get(resourceType).set(pathWithoutIndex, 'time');
        if (!exports.timeRegex.test(value.toString())) {
            GoFSHLogger_1.logger.warn(`Value ${value.toString()} on ${resourceName} element ${key} is not a valid FHIR time`);
        }
        return value;
    }
    else if (((_q = (_p = element === null || element === void 0 ? void 0 : element.type) === null || _p === void 0 ? void 0 : _p[0]) === null || _q === void 0 ? void 0 : _q.code) === 'instant') {
        typeCache.get(resourceType).set(pathWithoutIndex, 'instant');
        if (!exports.instantRegex.test(value.toString())) {
            GoFSHLogger_1.logger.warn(`Value ${value.toString()} on ${resourceName} element ${key} is not a valid FHIR instant`);
        }
        return value;
    }
    else {
        typeCache.get(resourceType).set(pathWithoutIndex, typeof value);
        return value;
    }
}
// Typical empty FSH values are: [], {}, null, undefined
function isFSHValueEmpty(fshValue) {
    return ((0, lodash_1.isObject)(fshValue) && (0, lodash_1.isEmpty)(fshValue)) || (0, lodash_1.isNil)(fshValue);
}
function getAncestorElement(id, structDef, fisher) {
    var _a, _b, _c;
    let element;
    let currentStructDef = fisher.fishForFHIR(structDef.baseDefinition);
    while (currentStructDef && !element) {
        element =
            (_b = (_a = currentStructDef.snapshot) === null || _a === void 0 ? void 0 : _a.element.find((el) => el.id === id)) !== null && _b !== void 0 ? _b : (_c = currentStructDef.differential) === null || _c === void 0 ? void 0 : _c.element.find((el) => el.id === id);
        currentStructDef = fisher.fishForFHIR(currentStructDef.baseDefinition);
    }
    return element !== null && element !== void 0 ? element : null;
}
function getCardinality(id, structDef, fisher) {
    var _a, _b, _c;
    let min;
    let max;
    let currentStructDef = structDef;
    while (currentStructDef && (min == null || max == null)) {
        const element = (_b = (_a = currentStructDef.snapshot) === null || _a === void 0 ? void 0 : _a.element.find((el) => el.id === id)) !== null && _b !== void 0 ? _b : (_c = currentStructDef.differential) === null || _c === void 0 ? void 0 : _c.element.find((el) => el.id === id);
        min = min !== null && min !== void 0 ? min : element === null || element === void 0 ? void 0 : element.min;
        max = max !== null && max !== void 0 ? max : element === null || element === void 0 ? void 0 : element.max;
        currentStructDef = fisher.fishForFHIR(currentStructDef.baseDefinition);
    }
    return min != null && max != null ? { min, max } : null;
}
function getAncestorSliceDefinition(element, sd, fisher) {
    // slices may be defined in various ways.
    // for example, the slice Z at path:
    // alpha[X].beta[Y].gamma[Z]
    // may be defined in any of the following ways:
    // alpha.beta.gamma[Z]
    // alpha[X].beta.gamma[Z]
    // alpha.beta[Y].gamma[Z]
    // alpha[X].beta[Y].gamma[Z]
    // we can use getAncestorElement to help us out here.
    if (element.sliceName) {
        const idParts = element.id.split('.');
        // if there are slices earlier in the id,
        // check both the slice and list element.
        const idPartVariations = [
            ...idParts.slice(0, -1).map(part => {
                if (part.indexOf(':') > -1) {
                    return [part, part.split(':')[0]];
                }
                else {
                    return [part];
                }
            }),
            idParts.slice(-1)
        ];
        // the set of ids to check is the cartesian product of all the id variations
        const idsToCheck = cartesian(...idPartVariations);
        for (const id of idsToCheck) {
            const ancestorElement = getAncestorElement(id.join('.'), sd, fisher);
            if (ancestorElement) {
                return ancestorElement;
            }
        }
    }
}
// adapted from https://stackoverflow.com/questions/12303989/cartesian-product-of-multiple-arrays-in-javascript#43053803
function cartesian(...sublists) {
    return sublists.reduce((prevList, curList) => {
        return (0, lodash_1.flatMap)(prevList, prevElement => {
            return curList.map(curElement => {
                return (0, lodash_1.flatten)([prevElement, curElement]);
            });
        });
    });
}
//# sourceMappingURL=element.js.map