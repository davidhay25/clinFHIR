"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getInputDir = getInputDir;
exports.getAliasFile = getAliasFile;
exports.ensureOutputDir = ensureOutputDir;
exports.getFhirProcessor = getFhirProcessor;
exports.getResources = getResources;
exports.writeFSH = writeFSH;
exports.loadExternalDependencies = loadExternalDependencies;
exports.loadConfiguredDependencies = loadConfiguredDependencies;
exports.getLakeOfFHIR = getLakeOfFHIR;
exports.readJSONorXML = readJSONorXML;
exports.isProcessableContent = isProcessableContent;
exports.getIgPathFromIgIni = getIgPathFromIgIni;
exports.getFilesRecursive = getFilesRecursive;
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const ini_1 = __importDefault(require("ini"));
const readline_sync_1 = __importDefault(require("readline-sync"));
const GoFSHLogger_1 = require("./GoFSHLogger");
const fsh_sushi_1 = require("fsh-sushi");
const processor_1 = require("../processor");
const FSHExporter_1 = require("../export/FSHExporter");
const optimizer_1 = require("../optimizer");
const utils_1 = require("../utils");
const fhir_1 = require("fhir/fhir");
const FHIRConverter = new fhir_1.Fhir();
function getInputDir(input = '.') {
    // default to current directory
    GoFSHLogger_1.logger.info(`Using input directory: ${input}`);
    return input;
}
function getAliasFile(input = '') {
    GoFSHLogger_1.logger.info(`Using alias file: ${input}`);
    return input;
}
function ensureOutputDir(output = path_1.default.join('.', 'gofsh')) {
    GoFSHLogger_1.logger.info(`Using output directory: ${output}`);
    fs_extra_1.default.ensureDirSync(output);
    if (fs_extra_1.default.readdirSync(output).length > 0) {
        const continuationOption = readline_sync_1.default.keyIn([
            `Output directory ${output} contains files. How would you like to proceed?`,
            '- [D]elete',
            '- [C]ontinue',
            '- [Q]uit',
            'Choose one [D,C,Q]: '
        ].join('\n'), { limit: 'DCQ', cancel: false });
        if (/[Dd]/.test(continuationOption)) {
            fs_extra_1.default.emptyDirSync(output);
        }
        else if (/[Qq]/.test(continuationOption)) {
            return;
        }
    }
    return output;
}
async function getFhirProcessor(inDir, defs, fileType) {
    const lake = getLakeOfFHIR(inDir, fileType);
    await lake.prepareDefs();
    if (defs == null) {
        defs = new utils_1.FHIRDefinitions();
    }
    await defs.initialize();
    const igIniIgPath = getIgPathFromIgIni(inDir);
    const fisher = new utils_1.MasterFisher(lake, defs);
    return new processor_1.FHIRProcessor(lake, fisher, igIniIgPath);
}
async function getResources(processor, config, options = {}, aliases = []) {
    const fisher = processor.getFisher();
    const resources = processor.process(config, options, aliases);
    // Dynamically load and run the optimizers
    GoFSHLogger_1.logger.info('Optimizing FSH definitions to follow best practices...');
    const optimizers = await (0, optimizer_1.loadOptimizers)();
    optimizers.forEach(opt => {
        if (typeof opt.isEnabled !== 'function' || opt.isEnabled(options)) {
            GoFSHLogger_1.logger.info(`Running optimizer ${opt.name}: ${opt.description}`);
            opt.optimize(resources, fisher, options);
        }
        else {
            GoFSHLogger_1.logger.debug(`Skipping optimizer ${opt.name}: ${opt.description}`);
        }
    });
    return resources;
}
function writeFSH(resources, outDir, style) {
    const exporter = new FSHExporter_1.FSHExporter(resources);
    try {
        const resourceDir = path_1.default.join(outDir, 'input', 'fsh');
        exporter.export(style).forEach((content, name) => {
            fs_extra_1.default.ensureFileSync(path_1.default.join(resourceDir, name));
            fs_extra_1.default.writeFileSync(path_1.default.join(resourceDir, name), content);
        });
        GoFSHLogger_1.logger.info(`Wrote fsh to ${resourceDir}.`);
        if (resources.configuration) {
            const configPath = path_1.default.join(outDir, 'sushi-config.yaml');
            fs_extra_1.default.writeFileSync(configPath, resources.configuration.toFSH());
            GoFSHLogger_1.logger.info(`Wrote config to ${configPath}.`);
        }
    }
    catch (error) {
        GoFSHLogger_1.logger.error(`Could not write to output directory: ${error.message}`);
        process.exit(1);
    }
}
async function loadExternalDependencies(defs, config) {
    var _a, _b, _c, _d;
    const allDependencies = (_b = (_a = config.config.dependencies) === null || _a === void 0 ? void 0 : _a.map((dep) => `${dep.packageId}@${dep.version}`)) !== null && _b !== void 0 ? _b : [];
    const fhirPackageId = (_c = fsh_sushi_1.utils.getFHIRVersionInfo(config.config.fhirVersion[0])) === null || _c === void 0 ? void 0 : _c.packageId;
    if (!allDependencies.includes(`${fhirPackageId}@${config.config.fhirVersion[0]}`)) {
        allDependencies.push(`${fhirPackageId}@${config.config.fhirVersion[0]}`);
    }
    await fsh_sushi_1.utils.loadAutomaticDependencies(config.config.fhirVersion[0], (_d = config.config.dependencies) !== null && _d !== void 0 ? _d : [], 
    // @ts-ignore TODO: this can be removed once SUSHI changes the type signature for this function to use FPL's FHIRDefinitions type
    defs);
    await loadConfiguredDependencies(defs, allDependencies);
}
async function loadConfiguredDependencies(defs, dependencies = []) {
    // Automatically include FHIR R4 if no other versions of FHIR are already included
    if (!dependencies.some(dep => /hl7\.fhir\.r(4|5|4b|6)\.core/.test(dep))) {
        dependencies.push('hl7.fhir.r4.core@4.0.1');
    }
    // Load dependencies
    for (const dep of dependencies) {
        const [packageId, version] = dep.split('@');
        if (version == null) {
            GoFSHLogger_1.logger.error(`Failed to load ${packageId}: No version specified. To specify the version use ` +
                `the format ${packageId}@current`);
            continue;
        }
        await defs.loadPackage(packageId, version).catch(e => {
            GoFSHLogger_1.logger.error(`Failed to load ${packageId}#${version}: ${e.message}`);
            if (e.stack) {
                GoFSHLogger_1.logger.debug(e.stack);
            }
        });
    }
    return defs;
}
function getLakeOfFHIR(inDir, fileType) {
    const files = getFilesRecursive(inDir);
    const jsonFiles = files.filter(f => f.endsWith('.json'));
    const xmlFiles = files.filter(f => f.endsWith('.xml'));
    const docs = [];
    let pluralJsonFiles = '';
    let pluralXmlFiles = '';
    if (jsonFiles.length !== 1) {
        pluralJsonFiles = 's';
    }
    if (xmlFiles.length !== 1) {
        pluralXmlFiles = 's';
    }
    if (fileType === 'json-only') {
        GoFSHLogger_1.logger.info(`Found ${jsonFiles.length} JSON file${pluralJsonFiles}.`);
        loadPrimaryFiles(jsonFiles, docs);
        const nonDuplicateXMLFiles = findNonDuplicateSecondaryFiles(xmlFiles, docs);
        if (nonDuplicateXMLFiles.length > 0) {
            // We only find the first non-duplicate file and warn on it, because warnings for every non-duplicate may be annoying
            GoFSHLogger_1.logger.warn(`${nonDuplicateXMLFiles.length} XML definition(s) found without corresponding JSON definitions (for example, ${nonDuplicateXMLFiles[0]}).` +
                ' These definitions will be ignored since GoFSH is running in "json-only" mode.' +
                ' To process XML definitions along with JSON, set the "-t" flag to "json-and-xml".' +
                ' To process only XML definitions, set the "-t" flag to "xml-only".');
        }
    }
    else if (fileType === 'xml-only') {
        GoFSHLogger_1.logger.info(`Found ${xmlFiles.length} XML file${pluralXmlFiles}.`);
        loadPrimaryFiles(xmlFiles, docs);
        const nonDuplicateJSONFiles = findNonDuplicateSecondaryFiles(jsonFiles, docs);
        if (nonDuplicateJSONFiles.length > 0) {
            // We only find the first non-duplicate file and warn on it, because warnings for every non-duplicate may be annoying
            GoFSHLogger_1.logger.warn(`${nonDuplicateJSONFiles.length} JSON definition(s) found without corresponding XML definitions (for example, ${nonDuplicateJSONFiles[0]}).` +
                ' These definitions will be ignored since GoFSH is running in "xml-only" mode.' +
                ' To process JSON definitions along with XML, set the "-t" flag to "json-and-xml".' +
                ' To process only JSON definitions, set the "-t" flag to "json-only", or leave it unset.');
        }
    }
    else if (fileType === 'json-and-xml') {
        GoFSHLogger_1.logger.info(`Found ${jsonFiles.length} JSON file${pluralJsonFiles}.`);
        loadPrimaryFiles(jsonFiles, docs);
        GoFSHLogger_1.logger.info(`Found ${xmlFiles.length} XML file${pluralXmlFiles}.`);
        loadPrimaryFiles(xmlFiles, docs);
    }
    return new processor_1.LakeOfFHIR(docs);
}
function loadPrimaryFiles(files, docs) {
    files.forEach(file => {
        try {
            const loadedFile = readJSONorXML(file);
            if (isProcessableContent(loadedFile.content, file)) {
                docs.push(new processor_1.WildFHIR(loadedFile, file));
            }
        }
        catch (ex) {
            // If an "Unknown resource type" error is logged, we can be almost
            // certain that it is an xml file that should be ignored, so only log
            // a debug and not an error
            if (path_1.default.extname(file) === '.xml' && /Unknown resource type:/.test(ex.message)) {
                GoFSHLogger_1.logger.debug(`Skipping non-FHIR XML: ${file}`);
            }
            else {
                GoFSHLogger_1.logger.error(`Could not load ${file}: ${ex.message}`);
            }
        }
    });
}
function findNonDuplicateSecondaryFiles(files, docs) {
    return files.filter(file => {
        try {
            const content = readJSONorXML(file).content;
            return (isProcessableContent(content, file) &&
                content.id &&
                !docs.some(existingResource => existingResource.content.resourceType === content.resourceType &&
                    existingResource.content.id === content.id));
        }
        catch (_a) { } // We don't want to log any errors with the secondary files
    });
}
function readJSONorXML(file) {
    if (file.endsWith('.json')) {
        const buffer = fs_extra_1.default.readFileSync(file);
        const importedFile = {
            content: JSON.parse(buffer.toString().replace(/^\uFEFF/, ''))
        };
        if (buffer.length > LARGE_FILE_BUFFER_LENGTH) {
            importedFile.large = true;
        }
        return importedFile;
    }
    else if (file.endsWith('.xml')) {
        const buffer = fs_extra_1.default.readFileSync(file);
        const importedFile = { content: FHIRConverter.xmlToObj(buffer.toString()) };
        if (buffer.length > LARGE_FILE_BUFFER_LENGTH) {
            importedFile.large = true;
        }
        return importedFile;
    }
}
function isProcessableContent(content, source) {
    if (typeof content !== 'object' || content.resourceType == null) {
        GoFSHLogger_1.logger.debug(`Skipping non-FHIR input: ${source}`);
        return false;
    }
    else if (/^http:\/\/hl7.org\/fhir\/comparison\//.test(content.url)) {
        // The IG Publisher creates weird "Intersection" and "Union" SD files, so this check filters them out
        GoFSHLogger_1.logger.debug(`Skipping temporary "comparison" resource created by IG Publisher: ${source}`);
        return false;
    }
    else if (source === null || source === void 0 ? void 0 : source.endsWith(path_1.default.join('other', 'validation-oo.json'))) {
        // The IG Publisher creates a Bundle of OperationOutcome resources based on validation results, which we don't want
        GoFSHLogger_1.logger.debug(`Skipping validation outcome resource created by IG Publisher: ${source}`);
        return false;
    }
    else {
        return true;
    }
}
function getIgPathFromIgIni(inDir) {
    var _a;
    let igPath;
    const igIniPath = getFilesRecursive(inDir).find(file => path_1.default.parse(file).base === 'ig.ini');
    if (igIniPath) {
        try {
            const igIni = ini_1.default.parse(fs_extra_1.default.readFileSync(igIniPath, 'utf-8'));
            if ((_a = igIni.IG) === null || _a === void 0 ? void 0 : _a.ig) {
                igPath = path_1.default.join(path_1.default.dirname(igIniPath), igIni.IG.ig);
            }
        }
        catch (_b) { }
    }
    return igPath;
}
// thanks, peturv
function getFilesRecursive(dir) {
    if (fs_extra_1.default.statSync(dir).isDirectory()) {
        const ancestors = fs_extra_1.default.readdirSync(dir, 'utf8').map(f => {
            // Don't get any files in .git folder or in a child temp folder
            if (f === 'temp' || f === '.git') {
                GoFSHLogger_1.logger.debug(`Skipping ${f} folder: ${path_1.default.join(dir, f)}`);
                return [];
            }
            return getFilesRecursive(path_1.default.join(dir, f));
        });
        return [].concat(...ancestors);
    }
    else {
        // IG Publisher creates .escaped.json files that are not valid JSON
        if (dir.endsWith('.escaped.json') ||
            dir.endsWith('-spreadsheet.xml') ||
            IGNORED_RESOURCE_LIKE_FILES.some(path => dir.endsWith(path)) ||
            IGNORED_NON_RESOURCE_DIRECTORIES.some(path => dir.includes(path))) {
            GoFSHLogger_1.logger.debug(`Skipping ${dir} file`);
            return [];
        }
        return [dir];
    }
}
const IGNORED_RESOURCE_LIKE_FILES = [
    // If expansions.json is in an output directory, it was likely generated by the IG Publisher
    // Since it is a generated file and it can be large, we skip processing it
    `output${path_1.default.sep}expansions.json`,
    `output${path_1.default.sep}expansions.xml`,
    // qa.xml contains FHIR that will only cause us issues, so we skip it
    `output${path_1.default.sep}qa.xml`,
    // These template files do not contain valid JSON. Since they are template files, we skip processing them.
    `template${path_1.default.sep}onGenerate-validation.json`,
    `template${path_1.default.sep}ongenerate-validation-igqa.json`,
    `template${path_1.default.sep}ongenerate-validation-jira.json`,
    //Ignore ig-r4.json because it contains the same information as the original IG file
    'ig-r4.json'
];
// Certain directories are common in IG Publisher output, but don't contain any FHIR, and processing
// them will only create confusing errors, so we ignore these directories
const IGNORED_NON_RESOURCE_DIRECTORIES = [
    `input${path_1.default.sep}includes`,
    `input${path_1.default.sep}pagecontent`,
    `input${path_1.default.sep}pages`,
    `input${path_1.default.sep}intro-notes`,
    `input${path_1.default.sep}images`,
    `input${path_1.default.sep}images-source`
];
const LARGE_FILE_BUFFER_LENGTH = 200000;
//# sourceMappingURL=Processing.js.map