#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const commander_1 = require("commander");
const chalk_1 = __importDefault(require("chalk"));
const lodash_1 = require("lodash");
const fsh_sushi_1 = require("fsh-sushi");
const utils_1 = require("./utils");
const processor_1 = require("./processor");
const FSH_VERSION = '2.0.0';
app().catch(e => {
    utils_1.logger.error(`Unexpected error: ${e.message}`);
    process.exit(1);
});
async function app() {
    var _a, _b, _c, _d, _e;
    let inDir;
    const program = new commander_1.Command()
        .name('goFSH')
        .usage('[path-to-fhir-resources] [options]')
        .storeOptionsAsProperties(false)
        .option('-o, --out <out>', 'the path to the output folder')
        .option('-l, --log-level <level>', 'specify the level of log messages: error, warn, info (default), debug')
        .option('-d, --dependency <dependency...>', 'specify dependencies to be loaded using format dependencyId@version (FHIR R4 included by default)')
        .option('-s, --style <style>', 'specify how the output is organized into files: file-per-definition (default), group-by-fsh-type, group-by-profile, single-file')
        .option('-f, --fshing-trip', 'run SUSHI on the output of GoFSH and generate a comparison of the round trip results')
        .option('-i, --installed-sushi', 'use the locally installed version of SUSHI when generating comparisons with the "-f" option')
        .option('-t, --file-type <type>', 'specify which file types GoFSH should accept as input: json-only (default), xml-only, json-and-xml')
        .option('--indent', 'output FSH with indented rules using context paths')
        .option('--meta-profile <mode>', 'specify how meta.profile on Instances should be applied to the InstanceOf keyword: only-one (default), first, none')
        .option('-a, --alias-file <alias-filePath>', 'specify an existing FSH file containing aliases to be loaded.')
        .option('--no-alias', 'output FSH without generating Aliases')
        .option('-u, --useFHIRVersion <fhirVersion>', 'specify which FHIR version to use when it cannot be inferred')
        .version(getVersion(), '-v, --version', 'print goFSH version')
        .on('--help', () => {
        console.log('');
        console.log('goFSH is used to convert JSON FHIR resources');
        console.log('to FSH. This makes it easier to start');
        console.log('using FSH to author FHIR resources.');
    })
        .arguments('[path-to-fsh-defs]')
        .action(function (pathToFhirResources) {
        inDir = pathToFhirResources;
    })
        .parse(process.argv);
    // Set the log level. If no level specified, loggers default to info
    const programOptions = program.opts();
    const { logLevel } = programOptions;
    if (logLevel === 'debug' || logLevel === 'warn' || logLevel === 'error') {
        utils_1.logger.level = logLevel; // GoFSH logger
        fsh_sushi_1.utils.logger.level = logLevel; // SUSHI logger
    }
    utils_1.logger.info(`Starting ${getVersion()}`);
    utils_1.logger.info('Arguments:');
    if (programOptions.logLevel) {
        utils_1.logger.info(`  --log-level ${programOptions.logLevel}`);
    }
    if (programOptions.dependency) {
        utils_1.logger.info(`  --dependency ${programOptions.dependency}`);
    }
    if (programOptions.style) {
        utils_1.logger.info(`  --style ${programOptions.style}`);
    }
    if (programOptions.fshingTrip) {
        utils_1.logger.info('  --fshing-trip');
    }
    if (programOptions.installedSushi) {
        utils_1.logger.info('  --installed-sushi');
    }
    if (programOptions.fileType) {
        utils_1.logger.info(`  --file-type ${programOptions.fileType}`);
    }
    if (programOptions.indent) {
        utils_1.logger.info('  --indent');
    }
    if (programOptions.metaProfile) {
        utils_1.logger.info(`  --meta-profile ${programOptions.metaProfile}`);
    }
    if (programOptions.aliasFile) {
        utils_1.logger.info(`  --alias-file ${programOptions.aliasFile}`);
    }
    if (!programOptions.alias) {
        utils_1.logger.info('  --no-alias');
    }
    if (programOptions.useFHIRVersion) {
        utils_1.logger.info(`  --useFHIRVersion ${programOptions.useFHIRVersion}`);
    }
    if (programOptions.out) {
        utils_1.logger.info(`  --out ${path_1.default.resolve(programOptions.out)}`);
    }
    utils_1.logger.info(`  ${path_1.default.resolve(inDir || '.')}`);
    inDir = (0, utils_1.getInputDir)(inDir);
    let outDir;
    try {
        outDir = (0, utils_1.ensureOutputDir)(programOptions.out);
    }
    catch (err) {
        utils_1.logger.error(`Could not use output directory: ${err.message}`);
        process.exit(1);
    }
    if (!outDir) {
        utils_1.logger.info('Exiting.');
        process.exit(1);
    }
    // Load dependencies
    const defs = new utils_1.FHIRDefinitions();
    await defs.initialize();
    // Trim empty spaces from command line dependencies
    const dependencies = (_a = programOptions.dependency) === null || _a === void 0 ? void 0 : _a.map((dep) => dep.trim());
    // Use specified FHIR Version
    const specifiedFHIRVersion = programOptions.useFHIRVersion;
    if (specifiedFHIRVersion && !fsh_sushi_1.utils.isSupportedFHIRVersion(specifiedFHIRVersion)) {
        utils_1.logger.error(`Specified FHIR version is not supported: ${specifiedFHIRVersion}`);
        process.exit(1);
    }
    // Load FhirProcessor and config object
    const fileType = (_c = (_b = programOptions.fileType) === null || _b === void 0 ? void 0 : _b.toLowerCase()) !== null && _c !== void 0 ? _c : 'json-only';
    if (!['json-only', 'xml-only', 'json-and-xml'].includes(fileType)) {
        utils_1.logger.error(`Unsupported "file-type" option: ${fileType}. Valid options are "json-only", "xml-only", and "json-and-xml".`);
        process.exit(1);
    }
    const metaProfileBehavior = (_e = (_d = programOptions.metaProfile) === null || _d === void 0 ? void 0 : _d.toLowerCase()) !== null && _e !== void 0 ? _e : 'only-one';
    if (!['only-one', 'first', 'none'].includes(metaProfileBehavior)) {
        utils_1.logger.error(`Unsupported "meta-profile" option: ${metaProfileBehavior}. Valid options are "only-one", "first", and "none".`);
        process.exit(1);
    }
    // Load alias file
    let aliases;
    if (programOptions.aliasFile) {
        const aliasFile = (0, utils_1.getAliasFile)(programOptions.aliasFile);
        aliases = processor_1.AliasProcessor.process(aliasFile);
    }
    // Get options for processors and optimizers
    const processingOptions = {
        indent: programOptions.indent === true,
        metaProfile: metaProfileBehavior,
        alias: programOptions.alias
    };
    const processor = await (0, utils_1.getFhirProcessor)(inDir, defs, fileType);
    const config = processor.processConfig(dependencies, specifiedFHIRVersion);
    // Load dependencies from config for GoFSH processing
    await (0, utils_1.loadExternalDependencies)(defs, config);
    let pkg;
    try {
        pkg = await (0, utils_1.getResources)(processor, config, processingOptions, aliases);
    }
    catch (err) {
        utils_1.logger.error(`Could not use input directory: ${err.message}`);
        process.exit(1);
    }
    (0, utils_1.writeFSH)(pkg, outDir, programOptions.style);
    const proNum = (0, lodash_1.pad)(pkg.profiles.length.toString(), 18);
    const extNum = (0, lodash_1.pad)(pkg.extensions.length.toString(), 17);
    const logNum = (0, lodash_1.pad)(pkg.logicals.length.toString(), 18);
    const resNum = (0, lodash_1.pad)(pkg.resources.length.toString(), 18);
    const vsNum = (0, lodash_1.pad)(pkg.valueSets.length.toString(), 17);
    const csNum = (0, lodash_1.pad)(pkg.codeSystems.length.toString(), 18);
    const instNum = (0, lodash_1.pad)(pkg.instances.length.toString(), 18);
    const invNum = (0, lodash_1.pad)(pkg.invariants.length.toString(), 17);
    const mapNum = (0, lodash_1.pad)(pkg.mappings.length.toString(), 18);
    const aliasNum = (0, lodash_1.pad)(pkg.aliases.length.toString(), 18);
    const errNumMsg = (0, lodash_1.pad)(`${utils_1.stats.numError} Error${utils_1.stats.numError !== 1 ? 's' : ''}`, 12);
    const wrnNumMsg = (0, lodash_1.padStart)(`${utils_1.stats.numWarn} Warning${utils_1.stats.numWarn !== 1 ? 's' : ''}`, 12);
    const aWittyMessageInvolvingABadFishPun = (0, lodash_1.padEnd)((0, utils_1.getRandomPun)(utils_1.stats.numError, utils_1.stats.numWarn), 37);
    const clr = utils_1.stats.numError > 0 ? chalk_1.default.red : utils_1.stats.numWarn > 0 ? chalk_1.default.rgb(179, 98, 0) : chalk_1.default.green;
    // prettier-ignore
    const results = [
        clr('╔' + '═════════════════════════ GoFSH RESULTS ═════════════════════════' + '╗'),
        clr('║') + ' ╭────────────────────┬───────────────────┬────────────────────╮ ' + clr('║'),
        clr('║') + ' │      Profiles      │    Extensions     │      Logicals      │ ' + clr('║'),
        clr('║') + ' ├────────────────────┼───────────────────┼────────────────────┤ ' + clr('║'),
        clr('║') + ` │ ${proNum} │ ${extNum} │ ${logNum} │ ` + clr('║'),
        clr('║') + ' ╰────────────────────┴───────────────────┴────────────────────╯ ' + clr('║'),
        clr('║') + ' ╭────────────────────┬───────────────────┬────────────────────╮ ' + clr('║'),
        clr('║') + ' │     Resources      │     ValueSets     │     CodeSystems    │ ' + clr('║'),
        clr('║') + ' ├────────────────────┼───────────────────┼────────────────────┤ ' + clr('║'),
        clr('║') + ` │ ${resNum} │ ${vsNum} │ ${csNum} │ ` + clr('║'),
        clr('║') + ' ╰────────────────────┴───────────────────┴────────────────────╯ ' + clr('║'),
        clr('║') + ' ╭────────────────────┬───────────────────┬────────────────────╮ ' + clr('║'),
        clr('║') + ' │     Instances      │    Invariants     │      Mappings      │ ' + clr('║'),
        clr('║') + ' ├────────────────────┼───────────────────┼────────────────────┤ ' + clr('║'),
        clr('║') + ` │ ${instNum} │ ${invNum} │ ${mapNum} │ ` + clr('║'),
        clr('║') + ' ╰────────────────────┴───────────────────┴────────────────────╯ ' + clr('║'),
        clr('║') + ' ╭────────────────────┬───────────────────┬────────────────────╮ ' + clr('║'),
        clr('║') + ' │      Aliases       │                   │                    │ ' + clr('║'),
        clr('║') + ' ├────────────────────┼───────────────────┼────────────────────┤ ' + clr('║'),
        clr('║') + ` │ ${aliasNum} │                   │                    │ ` + clr('║'),
        clr('║') + ' ╰────────────────────┴───────────────────┴────────────────────╯ ' + clr('║'),
        clr('║') + '                                                                 ' + clr('║'),
        clr('╠' + '═════════════════════════════════════════════════════════════════' + '╣'),
        clr('║') + ` ${aWittyMessageInvolvingABadFishPun} ${errNumMsg} ${wrnNumMsg} ` + clr('║'),
        clr('╚' + '═════════════════════════════════════════════════════════════════' + '╝')
    ];
    console.log();
    results.forEach(r => console.log(r));
    if (programOptions.fshingTrip) {
        if (fileType === 'xml-only') {
            utils_1.logger.error('FSHing Trip is not supported for XML inputs.');
            process.exit(1);
        }
        else if (fileType === 'json-and-xml') {
            utils_1.logger.warn('FSHing Trip is not supported for XML inputs. Comparisons will only be generated for JSON input files.');
        }
        (0, utils_1.fshingTrip)(inDir, outDir, processor.getLakeOfFHIR(), programOptions.installedSushi);
    }
    process.exit(0);
}
function getVersion() {
    var _a;
    const packageJSONPath = path_1.default.join(__dirname, '..', 'package.json');
    if (fs_extra_1.default.existsSync(packageJSONPath)) {
        const goFshVersion = (_a = fs_extra_1.default.readJSONSync(packageJSONPath)) === null || _a === void 0 ? void 0 : _a.version;
        return `goFSH v${goFshVersion} (implements FHIR Shorthand specification v${FSH_VERSION})`;
    }
    return 'unknown';
}
//# sourceMappingURL=app.js.map