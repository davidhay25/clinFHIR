"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExportableContainsRule = void 0;
const os_1 = require("os");
const fsh_sushi_1 = require("fsh-sushi");
const _1 = require(".");
const lodash_1 = require("lodash");
class ExportableContainsRule extends fsh_sushi_1.fshrules.ContainsRule {
    constructor(path) {
        super(path);
        this.cardRules = [];
        this.flagRules = [];
        this.indent = 0;
    }
    toFSH() {
        var _a;
        const itemsWithAssociatedRules = this.items.map(item => {
            let line = '';
            // Add contains rule info
            if (item.type) {
                line += `${item.type} named ${item.name}`;
            }
            else {
                line += `${item.name}`;
            }
            // Add card rules for the current item
            const associatedCardRule = this.cardRules.find(r => r.path.endsWith(`[${item.name}]`));
            line += associatedCardRule ? ` ${associatedCardRule.cardToString()}` : '';
            // Add flag rules for the current item
            const associatedFlagRule = this.flagRules.find(r => r.path.endsWith(`[${item.name}]`));
            line += associatedFlagRule ? ` ${associatedFlagRule.flagsToString()}` : '';
            return line;
        });
        const spaces = (0, lodash_1.repeat)(' ', _1.INDENT_SIZE * ((_a = this.indent) !== null && _a !== void 0 ? _a : 0));
        return `${spaces}* ${this.path} contains${itemsWithAssociatedRules.length > 1 ? `${os_1.EOL}${spaces}    ` : ' '}${itemsWithAssociatedRules.join(` and${os_1.EOL}${spaces}    `)}`; // New line and indent each
    }
}
exports.ExportableContainsRule = ExportableContainsRule;
//# sourceMappingURL=ExportableContainsRule.js.map