"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValueSetProcessor = void 0;
const lodash_1 = require("lodash");
const flat_1 = require("flat");
const exportable_1 = require("../exportable");
const extractor_1 = require("../extractor");
const common_1 = require("./common");
const SUPPORTED_COMPONENT_PATHS = [
    'system',
    'version',
    'concept',
    'filter',
    'filter.property',
    'filter.op',
    'filter.value',
    'valueSet'
];
const VALUESET_SYSTEM_EXTENSION = 'http://hl7.org/fhir/StructureDefinition/valueset-system';
class ValueSetProcessor {
    static extractKeywords(input, target) {
        if (input.id) {
            target.id = input.id;
        }
        if (input.title) {
            target.title = input.title;
        }
        if (input.description) {
            target.description = input.description;
        }
    }
    static extractRules(input, target, fisher, config) {
        var _a, _b;
        const newRules = [];
        newRules.push(...extractor_1.CaretValueRuleExtractor.processResource(input, fisher, input.resourceType, config));
        if (input.compose) {
            (_a = input.compose.include) === null || _a === void 0 ? void 0 : _a.forEach((vsComponent) => {
                var _a;
                newRules.push(extractor_1.ValueSetFilterComponentRuleExtractor.process(vsComponent, input, true));
                newRules.push(extractor_1.ValueSetConceptComponentRuleExtractor.process(vsComponent, true));
                (_a = vsComponent.concept) === null || _a === void 0 ? void 0 : _a.forEach(includedConcept => {
                    var _a;
                    const conceptCaretRules = extractor_1.CaretValueRuleExtractor.processConcept(includedConcept, [`${(_a = vsComponent.system) !== null && _a !== void 0 ? _a : ''}#${includedConcept.code}`], target.name, 'ValueSet', fisher);
                    newRules.push(...conceptCaretRules);
                });
            });
            (_b = input.compose.exclude) === null || _b === void 0 ? void 0 : _b.forEach((vsComponent) => {
                var _a;
                newRules.push(extractor_1.ValueSetFilterComponentRuleExtractor.process(vsComponent, input, false));
                newRules.push(extractor_1.ValueSetConceptComponentRuleExtractor.process(vsComponent, false));
                (_a = vsComponent.concept) === null || _a === void 0 ? void 0 : _a.forEach(excludedConcept => {
                    var _a;
                    const conceptCaretRules = extractor_1.CaretValueRuleExtractor.processConcept(excludedConcept, [`${(_a = vsComponent.system) !== null && _a !== void 0 ? _a : ''}#${excludedConcept.code}`], target.name, 'ValueSet', fisher);
                    newRules.push(...conceptCaretRules);
                });
            });
        }
        target.rules = (0, lodash_1.compact)(newRules);
    }
    static process(input, fisher, config) {
        var _a;
        // It must be representable using the FSH ValueSet syntax
        if (ValueSetProcessor.isProcessableValueSet(input)) {
            // Prefer name (which is optional), otherwise create a reasonable name from the id with only allowable characters
            const name = (_a = input.name) !== null && _a !== void 0 ? _a : input.id.split(/[-.]+/).map(lodash_1.capitalize).join('');
            const valueSet = new exportable_1.ExportableValueSet(name);
            ValueSetProcessor.extractKeywords(input, valueSet);
            ValueSetProcessor.extractRules(input, valueSet, fisher, config);
            (0, common_1.makeNameSushiSafe)(valueSet);
            return valueSet;
        }
    }
    // Ensures that a ValueSet instance is fully representable using the ValueSet syntax in FSH.
    // For example, if there is no name or id we cannot process it.  In addition, if compose.include
    // or compose.exclude have extensions, or concepts have designations, etc., then we can't
    // represent it in FSH ValueSet syntax.  It must be represented using Instance instead.
    // One extension is allowed, though: the valueset-system extension, which may be present on
    // component.include.system or component.exclude.system. This extension is present when the system
    // refers to a contained CodeSystem. SUSHI adds it automatically, so we can safely ignore it here
    // and SUSHI will handle it correctly.
    // NOTE: by FHIR spec, if the include list exists, it must contain at least one element
    // but we can still do some processing without that as long as other criteria holds.
    // See http://hl7.org/fhir/r4/valueset-definitions.html#ValueSet.compose.include
    static isProcessableValueSet(input) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (input.resourceType !== 'ValueSet' || (input.name == null && input.id == null)) {
            return false;
        }
        // We support all higher-level paths via caret rules.  We only need to worry about the
        // input.compose.include and input.compose.exclude components because there is no easy way
        // to associate caret rules with them when the special FSH include/exclude syntax is used.
        // First thing to do is to remove the VALUESET_SYSTEM_EXTENSION. If it's the only extension,
        // we can remove the extension array, and if _system has no properties left, we can remove it, too.
        [...((_b = (_a = input.compose) === null || _a === void 0 ? void 0 : _a.include) !== null && _b !== void 0 ? _b : []), ...((_d = (_c = input.compose) === null || _c === void 0 ? void 0 : _c.exclude) !== null && _d !== void 0 ? _d : [])].forEach((component) => {
            var _a;
            if ((_a = component._system) === null || _a === void 0 ? void 0 : _a.extension) {
                component._system.extension = component._system.extension.filter((ext) => ext.url !== VALUESET_SYSTEM_EXTENSION);
                if (component._system.extension.length === 0) {
                    delete component._system.extension;
                }
                if ((0, lodash_1.isEmpty)(component._system)) {
                    delete component._system;
                }
            }
        });
        // Second, get the flat paths of input.compose.include and input.compose.exclude
        let flatPaths = Object.keys((0, flat_1.flatten)([...((_f = (_e = input.compose) === null || _e === void 0 ? void 0 : _e.include) !== null && _f !== void 0 ? _f : []), ...((_h = (_g = input.compose) === null || _g === void 0 ? void 0 : _g.exclude) !== null && _h !== void 0 ? _h : [])]));
        // Remove the array indices from the paths (we don't care about them)
        flatPaths = flatPaths.map(p => {
            return p
                .split('.')
                .filter(k => isNaN(parseInt(k)))
                .join('.');
        });
        // any path that starts with "concept." is okay, since those can use code caret rules
        flatPaths = flatPaths.filter(p => !p.startsWith('concept.'));
        // Check if there are any paths that are not a supported path
        return (0, lodash_1.difference)(flatPaths, SUPPORTED_COMPONENT_PATHS).length === 0;
    }
}
exports.ValueSetProcessor = ValueSetProcessor;
//# sourceMappingURL=ValueSetProcessor.js.map