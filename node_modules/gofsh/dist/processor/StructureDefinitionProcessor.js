"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StructureDefinitionProcessor = exports.LOGICAL_TARGET_EXTENSION = exports.TYPE_CHARACTERISTICS_EXTENSION = void 0;
const lodash_1 = require("lodash");
const fsh_sushi_1 = require("fsh-sushi");
const exportable_1 = require("../exportable");
const extractor_1 = require("../extractor");
const _1 = require(".");
const utils_1 = require("../utils");
const common_1 = require("../exportable/common");
const valid_url_1 = require("valid-url");
exports.TYPE_CHARACTERISTICS_EXTENSION = 'http://hl7.org/fhir/StructureDefinition/structuredefinition-type-characteristics';
exports.LOGICAL_TARGET_EXTENSION = 'http://hl7.org/fhir/tools/StructureDefinition/logical-target';
class StructureDefinitionProcessor {
    static process(input, fisher, config, existingInvariants = []) {
        var _a, _b, _c, _d;
        if (StructureDefinitionProcessor.isProcessableStructureDefinition(input)) {
            let sd;
            // Prefer name (which is required). If we happen to get invalid FHIR, create a reasonable name from the id with only allowable characters
            const name = (_a = input.name) !== null && _a !== void 0 ? _a : input.id.split(/[-.]+/).map(lodash_1.capitalize).join('');
            if (input.kind === 'logical' && input.derivation === 'specialization') {
                sd = new exportable_1.ExportableLogical(name);
            }
            else if (input.kind === 'resource' && input.derivation === 'specialization') {
                sd = new exportable_1.ExportableResource(name);
            }
            else if (input.derivation === 'constraint' && input.type === 'Extension') {
                if (input.kind !== 'complex-type') {
                    utils_1.logger.error(`Extension "${name}" should have "kind" set to "complex-type" but has "${input.kind}" instead. The generated FSH will set "kind" to "complex-type".`);
                    input.kind = 'complex-type';
                }
                sd = new exportable_1.ExportableExtension(name);
            }
            else if (input.derivation === 'constraint') {
                sd = new exportable_1.ExportableProfile(name);
            }
            else {
                // this should never be encountered when running normally, hopefully,
                // since the LakeOfFHIR should only be providing us with non-Instance StructureDefinitions
                throw new Error('This StructureDefinition does not represent a FSH Profile, Extension, Logical, or Resource.');
            }
            const elements = (_d = (_c = (_b = input.differential) === null || _b === void 0 ? void 0 : _b.element) === null || _c === void 0 ? void 0 : _c.map(rawElement => {
                return _1.ProcessableElementDefinition.fromJSON(rawElement, false);
            })) !== null && _d !== void 0 ? _d : [];
            StructureDefinitionProcessor.extractKeywords(input, sd);
            const invariants = StructureDefinitionProcessor.extractInvariants(input, elements, existingInvariants, fisher);
            const mappings = StructureDefinitionProcessor.extractMappings(elements, input, fisher);
            StructureDefinitionProcessor.extractRules(input, elements, sd, fisher, config);
            (0, _1.makeNameSushiSafe)(sd);
            // TODO: Destructuring an array with invariants and mappings is required for TypeScript 3.0
            // With TypeScript 4.0, we should update to return the following line, which is more clear:
            // return [sd, ...invariants, ...mappings];
            return [sd, ...[...invariants, ...mappings]];
        }
        return [];
    }
    static extractKeywords(input, target) {
        // Name is already set (by constructor) based on input.name or input.id
        if (input.id) {
            target.id = input.id;
        }
        if (input.title) {
            target.title = input.title;
        }
        if (input.description) {
            target.description = input.description;
        }
        if (input.baseDefinition) {
            target.parent = input.baseDefinition;
        }
        if (target instanceof exportable_1.ExportableExtension && input.context) {
            target.contexts = input.context.map(ctx => {
                if (ctx.type === 'fhirpath') {
                    return {
                        isQuoted: true,
                        value: (0, common_1.fshifyString)(ctx.expression)
                    };
                }
                // element and extension contexts are a little trickier, since they may involve paths.
                // we'll make a little ElementDefinition to help us out.
                // if there's a #, or the whole value is a valid URL, wait until later to try to resolve the URL, since it may refer to
                // another resource being processed.
                // but either way, we can handle the fhirPath now.
                if (ctx.expression.indexOf('#') > -1) {
                    const [url, fhirPath] = ctx.expression.split('#');
                    const fakeElement = new fsh_sushi_1.fhirtypes.ElementDefinition(fhirPath);
                    const fshPath = (0, utils_1.getPath)(fakeElement);
                    // the fshPath from getPath removes the resource name, which is convenient here
                    return {
                        isQuoted: false,
                        value: `${url}#${fshPath}`
                    };
                }
                else if ((0, valid_url_1.isUri)(ctx.expression)) {
                    return {
                        isQuoted: false,
                        value: ctx.expression
                    };
                }
                else {
                    const fakeElement = new fsh_sushi_1.fhirtypes.ElementDefinition(ctx.expression);
                    const fshPath = (0, utils_1.getPath)(fakeElement);
                    // the fshPath from getPath removes the resource name, so add the resource name back to the start
                    // it will turn a resource name by itself into the path ".", which we don't need
                    let contextValue = ctx.expression.split('.')[0];
                    if (fshPath !== '.') {
                        contextValue += `.${fshPath}`;
                    }
                    return {
                        isQuoted: false,
                        value: contextValue
                    };
                }
            });
        }
        if (target instanceof exportable_1.ExportableLogical && input.extension) {
            // most characteristics use TYPE_CHARACTERISTICS_EXTENSION,
            // but there may also be LOGICAL_TARGET_EXTENSION with valueBoolean true for the can-be-target characteristic.
            const characteristics = [];
            input.extension.forEach(ext => {
                if (ext.url === exports.TYPE_CHARACTERISTICS_EXTENSION && ext.valueCode != null) {
                    characteristics.push(ext.valueCode);
                }
                else if (ext.url === exports.LOGICAL_TARGET_EXTENSION && ext.valueBoolean === true) {
                    characteristics.push('can-be-target');
                }
            });
            if (characteristics.length) {
                target.characteristics = characteristics;
            }
        }
    }
    static extractRules(input, elements, target, fisher, config) {
        const newRules = [];
        let parentDefinition;
        if (input.baseDefinition) {
            parentDefinition = fisher.fishForFHIR(input.baseDefinition);
        }
        else if (target instanceof exportable_1.ExportableResource) {
            parentDefinition = fisher.fishForFHIR('http://hl7.org/fhir/StructureDefinition/DomainResource');
        }
        else if (target instanceof exportable_1.ExportableLogical) {
            parentDefinition = fisher.fishForFHIR('http://hl7.org/fhir/StructureDefinition/Base');
        }
        // First extract the top-level caret rules from the StructureDefinition
        newRules.push(...extractor_1.CaretValueRuleExtractor.processStructureDefinition(input, fisher, config));
        // Then extract rules based on the differential elements
        elements.forEach(element => {
            var _a, _b;
            const ancestorSliceDefinition = (0, utils_1.getAncestorSliceDefinition)(element, input, fisher);
            // if there is a slice, which is not a choice slice, but no ancestor definition, it will need a contains rule
            const isNewSlice = element.sliceName &&
                !/\[x]:[a-z][a-z0-9]*[A-Z][A-Za-z0-9]*$/.test(element.id) &&
                ancestorSliceDefinition == null;
            const idWithoutName = element.id.slice(element.id.indexOf('.') + 1);
            if ((target instanceof exportable_1.ExportableResource || target instanceof exportable_1.ExportableLogical) &&
                !((_b = (_a = parentDefinition === null || parentDefinition === void 0 ? void 0 : parentDefinition.snapshot) === null || _a === void 0 ? void 0 : _a.element) === null || _b === void 0 ? void 0 : _b.some(parentEl => parentEl.id.slice(parentEl.id.indexOf('.') + 1) === idWithoutName))) {
                // a newly defined element on a Resource or Logical needs an AddElementRule
                // AddElementRule contains cardinality, flag, and type information, so those extractors don't need to be called here
                // the root element doesn't need to be added, but all other elements do.
                // but, we still want to mark paths as processed so that caret value rules are not made.
                if (isNewSlice) {
                    utils_1.logger.warn(`${target.constructorName} ${target.name} contains a slice definition for ${element.sliceName} on ${element.path}. This is not supported by FHIR.`);
                    newRules.push(extractor_1.ContainsRuleExtractor.process(element, input, fisher));
                }
                else {
                    if (element.path.indexOf('.') === -1) {
                        // For the root element, mark the cardinality paths as processed
                        // so that they don't get CaretValueRules created.
                        element.processedPaths.push('min', 'max');
                    }
                    else {
                        // For all other elements, make a rule to add them.
                        const addElementRule = extractor_1.AddElementRuleExtractor.process(element, input);
                        newRules.push(addElementRule);
                    }
                }
                newRules.push(extractor_1.BindingRuleExtractor.process(element), extractor_1.ObeysRuleExtractor.process(element), ...extractor_1.AssignmentRuleExtractor.process(element, target.name));
            }
            else if (isNewSlice) {
                newRules.push(extractor_1.ContainsRuleExtractor.process(element, input, fisher), extractor_1.OnlyRuleExtractor.process(element), ...extractor_1.AssignmentRuleExtractor.process(element, target.name), extractor_1.BindingRuleExtractor.process(element), extractor_1.ObeysRuleExtractor.process(element));
            }
            else {
                newRules.push(extractor_1.CardRuleExtractor.process(element, input, fisher), extractor_1.OnlyRuleExtractor.process(element), ...extractor_1.AssignmentRuleExtractor.process(element, target.name), extractor_1.FlagRuleExtractor.process(element), extractor_1.BindingRuleExtractor.process(element), extractor_1.ObeysRuleExtractor.process(element));
            }
            // if there is a slice, and there is an ancestor definition, don't process the sliceName again
            if (element.sliceName && ancestorSliceDefinition) {
                element.processedPaths.push('sliceName');
            }
            // NOTE: CaretValueExtractor for elements can only run once other Extractors have finished,
            // since it will convert any remaining fields to CaretValueRules
            newRules.push(...extractor_1.CaretValueRuleExtractor.process(element, input, fisher));
        });
        target.rules = (0, lodash_1.compact)(newRules);
        (0, _1.switchQuantityRules)(target.rules);
    }
    static extractInvariants(input, elements, existingInvariants, fisher) {
        const invariants = [];
        elements.forEach(element => {
            invariants.push(...extractor_1.InvariantExtractor.process(element, input, [...existingInvariants, ...invariants], fisher));
        });
        return invariants;
    }
    static extractMappings(elements, input, fisher) {
        return extractor_1.MappingExtractor.process(input, elements, fisher);
    }
    static isProcessableStructureDefinition(input) {
        return input.resourceType === 'StructureDefinition' && (input.name != null || input.id != null);
    }
}
exports.StructureDefinitionProcessor = StructureDefinitionProcessor;
//# sourceMappingURL=StructureDefinitionProcessor.js.map