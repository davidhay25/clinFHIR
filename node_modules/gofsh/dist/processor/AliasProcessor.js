"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AliasProcessor = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const exportable_1 = require("../exportable");
const GoFSHLogger_1 = require("../utils/GoFSHLogger");
const antlr4_1 = require("antlr4");
// digging up the lexer/parser so that we can implement with less code duplication
// it's a little risky, but such is the nature of the sea
const FSHLexer_1 = __importDefault(require("fsh-sushi/dist/import/generated/FSHLexer"));
const FSHParser_1 = __importDefault(require("fsh-sushi/dist/import/generated/FSHParser"));
const aliasRegex = /^\$?[a-zA-z0-9_\-\.]+$/;
class AliasProcessor {
    static process(aliasFile) {
        // Load aliases from alias-file option.
        if (AliasProcessor.isProcessableAliasFile(aliasFile)) {
            let aliasFileContent;
            try {
                aliasFileContent = fs_extra_1.default.readFileSync(aliasFile, 'utf8');
            }
            catch (e) {
                GoFSHLogger_1.logger.error(`Alias file read failed with error: ${e.message}`);
            }
            if (aliasFileContent != null) {
                const aliases = AliasProcessor.parseAliases(aliasFileContent);
                if (aliases.length === 0) {
                    GoFSHLogger_1.logger.warn(`No aliases present in ${aliasFile}.`);
                }
                return aliases;
            }
        }
        return [];
    }
    static isProcessableAliasFile(input) {
        return input != null && input.length > 0 && input.endsWith('.fsh');
    }
    // This implementation is more or less copied out of SUSHI to just get the aliases
    static parseAliases(aliasFileContent) {
        const input = aliasFileContent.endsWith('\n') ? aliasFileContent : aliasFileContent + '\n';
        const aliases = new Map();
        // parse that fsh, citizen
        const chars = new antlr4_1.InputStream(input);
        const lexer = new FSHLexer_1.default(chars);
        // @ts-ignore
        const tokens = new antlr4_1.CommonTokenStream(lexer);
        const parser = new FSHParser_1.default(tokens);
        // @ts-ignore
        parser.buildParseTrees = true;
        // @ts-ignore
        const ctx = parser.doc();
        ctx.entity().forEach(entity => {
            var _a;
            if (entity.alias()) {
                const name = entity.alias().name().getText();
                let value = (_a = entity.alias().SEQUENCE()) === null || _a === void 0 ? void 0 : _a.getText();
                // When the url contains a fragment (http://example.org#fragment), the grammar will read it as a
                // CODE, so we also accept that for the value here
                if (!value && entity.alias().CODE()) {
                    value = entity.alias().CODE().getText();
                }
                if (name.includes('|')) {
                    GoFSHLogger_1.logger.error(`Alias ${name} cannot include "|" since the "|" character is reserved for indicating a version`);
                    return;
                }
                else if (!aliasRegex.test(name)) {
                    GoFSHLogger_1.logger.warn(`Alias ${name} includes unsupported characters. Alias names can only contain letters, numbers, underscores ("_"), hyphens ("-"), and dots (".").`);
                }
                if (aliases.has(name) && aliases.get(name) !== value) {
                    GoFSHLogger_1.logger.error(`Alias ${name} cannot be redefined to ${value}; it is already defined as ${aliases.get(name)}.`);
                    // don't set it -- just keep the original definition
                }
                else {
                    aliases.set(name, value);
                }
            }
        });
        return Array.from(aliases.entries()).map(([name, value]) => new exportable_1.ExportableAlias(name, value));
    }
}
exports.AliasProcessor = AliasProcessor;
//# sourceMappingURL=AliasProcessor.js.map