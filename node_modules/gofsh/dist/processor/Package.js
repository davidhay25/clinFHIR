"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Package = void 0;
const exportable_1 = require("../exportable");
const utils_1 = require("../utils");
class Package {
    constructor() {
        this.profiles = [];
        this.extensions = [];
        this.resources = [];
        this.logicals = [];
        this.instances = [];
        this.valueSets = [];
        this.codeSystems = [];
        this.invariants = [];
        this.mappings = [];
        this.aliases = [];
    }
    add(resource) {
        if (resource instanceof exportable_1.ExportableProfile) {
            checkDuplicateDefinition(this.profiles, resource, 'profile');
            this.profiles.push(resource);
        }
        else if (resource instanceof exportable_1.ExportableExtension) {
            checkDuplicateDefinition(this.extensions, resource, 'extension');
            this.extensions.push(resource);
        }
        else if (resource instanceof exportable_1.ExportableResource) {
            checkDuplicateDefinition(this.resources, resource, 'resource');
            this.resources.push(resource);
        }
        else if (resource instanceof exportable_1.ExportableLogical) {
            checkDuplicateDefinition(this.logicals, resource, 'logical');
            this.logicals.push(resource);
        }
        else if (resource instanceof exportable_1.ExportableInstance) {
            checkDuplicateDefinition(this.instances, resource, 'instance');
            this.instances.push(resource);
        }
        else if (resource instanceof exportable_1.ExportableValueSet) {
            checkDuplicateDefinition(this.valueSets, resource, 'value set');
            this.valueSets.push(resource);
        }
        else if (resource instanceof exportable_1.ExportableCodeSystem) {
            checkDuplicateDefinition(this.codeSystems, resource, 'code system');
            this.codeSystems.push(resource);
        }
        else if (resource instanceof exportable_1.ExportableInvariant) {
            checkDuplicateDefinition(this.invariants, resource, 'invariant');
            this.invariants.push(resource);
        }
        else if (resource instanceof exportable_1.ExportableMapping) {
            checkDuplicateDefinition(this.mappings, resource, 'mapping');
            this.mappings.push(resource);
        }
        else if (resource instanceof exportable_1.ExportableAlias) {
            const duplicateAlias = this.aliases.find(e => e.alias === resource.alias);
            if (duplicateAlias != null) {
                if (duplicateAlias.url !== resource.url) {
                    utils_1.logger.error(`Encountered alias with a duplicate name, ${resource.alias}, which GoFSH cannot make unique. Fix the source file to resolve this error or update the resulting FSH definition.`);
                }
            }
            else {
                this.aliases.push(resource);
            }
        }
        else if (resource instanceof exportable_1.ExportableConfiguration) {
            if (this.configuration) {
                utils_1.logger.warn(`Multiple implementation guide resources found in input folder. Skipping implementation guide with canonical ${resource.config.canonical}`);
            }
            else {
                this.configuration = resource;
            }
        }
    }
}
exports.Package = Package;
// When we call this function, we have already removed definitions that had the same resourceType and id
// We have also already tried to de-deduplicate the name if we can (for example, Instances add the InstanceOf information to their name)
// At this point, if a definition has the same name as another, the definition or the resulting FSH will need to be
// changed by hand in order for SUSHI to process it without errors.
// Log an error that there will be a definition with the same name written to FSH files.
function checkDuplicateDefinition(array, resource, type) {
    const existing = array.find(e => e.name === resource.name);
    if (existing) {
        utils_1.logger.error(`Encountered ${type}s (id: ${existing.id} and id: ${resource.id}) with duplicate name: ` +
            `${resource.name}. SUSHI requires named to be unique. Fix the source file for one of ` +
            `these ${type}s to resolve this error or update the resulting FSH definition.`);
        return true;
    }
    return false;
}
//# sourceMappingURL=Package.js.map