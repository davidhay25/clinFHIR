"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FHIRProcessor = void 0;
const semver_1 = __importDefault(require("semver"));
const utils_1 = require("../utils");
const _1 = require(".");
const extractor_1 = require("../extractor");
const InstanceProcessor_1 = require("./InstanceProcessor");
class FHIRProcessor {
    constructor(lake, fisher, igPath = null) {
        this.lake = lake;
        this.fisher = fisher;
        this.igPath = igPath;
    }
    getFisher() {
        return this.fisher;
    }
    getLakeOfFHIR() {
        return this.lake;
    }
    processConfig(externalDeps, specifiedFHIRVersion) {
        var _a;
        const igForConfig = (_a = this.lake.getAllImplementationGuides().find(doc => doc.path === this.igPath)) !== null && _a !== void 0 ? _a : this.lake.getAllImplementationGuides()[0];
        const resources = [
            ...this.lake.getAllStructureDefinitions(),
            ...this.lake.getAllCodeSystems(),
            ...this.lake.getAllValueSets()
        ].map(wild => wild.content);
        if (igForConfig) {
            resources.push(igForConfig.content);
        }
        const config = extractor_1.ConfigurationExtractor.process(resources, specifiedFHIRVersion);
        if ((externalDeps === null || externalDeps === void 0 ? void 0 : externalDeps.length) > 0) {
            const existingIds = [];
            config.config.dependencies = config.config.dependencies || [];
            externalDeps.forEach(dep => {
                const [id, version] = dep.split('@');
                config.config.dependencies.forEach(element => {
                    existingIds.push(element.packageId);
                    if (element.packageId === id && element.version !== version) {
                        if (semver_1.default.gt(version, element.version))
                            element.version = version;
                    }
                });
                if (!existingIds.includes(id)) {
                    const newDep = {
                        packageId: id,
                        version: version
                    };
                    config.config.dependencies.push(newDep);
                }
            });
        }
        return config;
    }
    // Outputs a counter for each resource type being processed
    outputCount(fhirArr, index, type) {
        if (index == fhirArr.length - 1) {
            // Ideally, we want the logger to overwrite the previous count,
            // but since we've encountered issues, we'll remove it for now
            // process.stdout.write('\x1b[A\r');
            let finalMessage = `Processed ${fhirArr.length} ${type}`;
            if (fhirArr.length === 1) {
                utils_1.logger.info(finalMessage.padEnd(45));
                return;
            }
            else {
                finalMessage = finalMessage.concat('s');
                utils_1.logger.info(finalMessage.padEnd(45));
                return;
            }
        }
        else if ((index + 1) % 5 == 0) {
            // Ideally, we want the logger to overwrite the previous count
            // but since we've encountered issues, we'll remove it for now
            // process.stdout.write('\x1b[A\r');
            utils_1.logger.info(`Processed ${index + 1} of ${fhirArr.length} ${type}s...\r`);
        }
    }
    process(config, options = {}, aliases = []) {
        var _a;
        const resources = new _1.Package();
        const igForConfig = (_a = this.lake.getAllImplementationGuides().find(doc => doc.path === this.igPath)) !== null && _a !== void 0 ? _a : this.lake.getAllImplementationGuides()[0];
        resources.add(config);
        if (aliases.length > 0)
            utils_1.logger.info('Processing Aliases...');
        aliases.forEach(alias => resources.add(alias));
        const structureDefs = this.lake.getAllStructureDefinitions();
        if (structureDefs.length > 0)
            utils_1.logger.info('Processing StructureDefinitions...');
        structureDefs.forEach((wild, index) => {
            try {
                _1.StructureDefinitionProcessor.process(wild.content, this.fisher, config.config, resources.invariants).forEach(resource => {
                    resources.add(resource);
                });
                this.outputCount(structureDefs, index, 'StructureDefinition');
            }
            catch (ex) {
                utils_1.logger.error(`Could not process StructureDefinition at ${wild.path}: ${ex.message}`);
            }
        });
        const codeSystems = this.lake.getAllCodeSystems(false);
        if (codeSystems.length > 0)
            utils_1.logger.info('Processing CodeSystems...');
        codeSystems.forEach((wild, index) => {
            try {
                resources.add(_1.CodeSystemProcessor.process(wild.content, this.fisher, config.config));
                this.outputCount(codeSystems, index, 'CodeSystem');
            }
            catch (ex) {
                utils_1.logger.error(`Could not process CodeSystem at ${wild.path}: ${ex.message}`);
            }
        });
        const valueSets = this.lake.getAllValueSets(false);
        if (valueSets.length > 0)
            utils_1.logger.info('Processing ValueSets...');
        valueSets.forEach((wild, index) => {
            try {
                resources.add(_1.ValueSetProcessor.process(wild.content, this.fisher, config.config));
                this.outputCount(valueSets, index, 'ValueSet');
            }
            catch (ex) {
                utils_1.logger.error(`Could not process ValueSet at ${wild.path}: ${ex.message}`);
            }
        });
        const instances = this.lake.getAllInstances(true);
        if (instances.length > 0)
            utils_1.logger.info('Processing Instances...');
        instances.forEach((wild, index) => {
            try {
                if (wild.large) {
                    utils_1.logger.info(`Instance ${wild.content.id} is especially large. Processing may take a while.`);
                }
                resources.add(InstanceProcessor_1.InstanceProcessor.process(wild.content, igForConfig === null || igForConfig === void 0 ? void 0 : igForConfig.content, this.fisher, options));
                this.outputCount(instances, index, 'Instance');
            }
            catch (ex) {
                utils_1.logger.error(`Could not process Instance at ${wild.path}: ${ex.message}`);
            }
        });
        return resources;
    }
}
exports.FHIRProcessor = FHIRProcessor;
//# sourceMappingURL=FHIRProcessor.js.map