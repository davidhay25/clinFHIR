"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValueSetExporter = void 0;
const fhirtypes_1 = require("../fhirtypes");
const fshtypes_1 = require("../fshtypes");
const FSHLogger_1 = require("../utils/FSHLogger");
const errors_1 = require("../errors");
const utils_1 = require("../utils");
const rules_1 = require("../fshtypes/rules");
const common_1 = require("../fhirtypes/common");
const valid_url_1 = require("valid-url");
const lodash_1 = require("lodash");
class ValueSetExporter {
    constructor(tank, pkg, fisher) {
        this.tank = tank;
        this.pkg = pkg;
        this.fisher = fisher;
    }
    setMetadata(valueSet, fshDefinition) {
        valueSet.setName(fshDefinition.name, fshDefinition.sourceInfo);
        valueSet.setId(fshDefinition.id, fshDefinition.sourceInfo);
        if (fshDefinition.title) {
            valueSet.title = fshDefinition.title;
        }
        if (fshDefinition.description) {
            valueSet.description = fshDefinition.description;
        }
        // Version is set to value provided in config, will be overriden if reset by rules
        valueSet.version = this.tank.config.version;
        valueSet.url = `${this.tank.config.canonical}/ValueSet/${valueSet.id}`;
    }
    setCompose(valueSet, components) {
        if (components.length > 0) {
            valueSet.compose = {
                include: [],
                exclude: []
            };
            components.forEach(component => {
                var _a, _b, _c;
                const composeElement = {};
                if (component.from.system) {
                    const systemParts = component.from.system.split('|');
                    const foundSystem = ((_b = (_a = this.fisher.fishForMetadata(systemParts[0], utils_1.Type.CodeSystem)) === null || _a === void 0 ? void 0 : _a.url) !== null && _b !== void 0 ? _b : component.from.system).split('|');
                    composeElement.system = foundSystem[0];
                    // if the rule specified a version, use that version.
                    composeElement.version = systemParts.slice(1).join('|') || undefined;
                    if (!valid_url_1.isUri(composeElement.system)) {
                        throw new errors_1.InvalidUriError(composeElement.system);
                    }
                }
                if (component.from.valueSets) {
                    composeElement.valueSet = component.from.valueSets.map(vs => {
                        var _a, _b;
                        return (_b = (_a = this.fisher.fishForMetadata(vs, utils_1.Type.ValueSet)) === null || _a === void 0 ? void 0 : _a.url) !== null && _b !== void 0 ? _b : vs;
                    });
                    composeElement.valueSet.forEach(vs => {
                        // Canonical URI may include | to specify version: https://www.hl7.org/fhir/references.html#canonical
                        if (!valid_url_1.isUri(vs.split('|')[0])) {
                            throw new errors_1.InvalidUriError(vs);
                        }
                    });
                }
                if (component instanceof rules_1.ValueSetConceptComponentRule && component.concepts.length > 0) {
                    composeElement.concept = component.concepts.map(concept => {
                        const composeConcept = {
                            code: concept.code
                        };
                        if (concept.display) {
                            composeConcept.display = concept.display;
                        }
                        return composeConcept;
                    });
                    // if we can fish up the system in the tank, it's local, and we should check the listed concepts
                    const codeSystem = this.tank.fish(composeElement.system, utils_1.Type.CodeSystem);
                    if (codeSystem instanceof fshtypes_1.FshCodeSystem || codeSystem instanceof fshtypes_1.Instance) {
                        common_1.listUndefinedLocalCodes(codeSystem, composeElement.concept.map(concept => concept.code), this.tank, component);
                    }
                }
                else if (component instanceof rules_1.ValueSetFilterComponentRule &&
                    component.filters.length > 0) {
                    composeElement.filter = component.filters.map(filter => {
                        // if filter.value is a FshCode, perform the local code system check here as well
                        if (filter.value instanceof fshtypes_1.FshCode) {
                            const codeSystem = this.tank.fish(composeElement.system, utils_1.Type.CodeSystem);
                            if (codeSystem instanceof fshtypes_1.FshCodeSystem || codeSystem instanceof fshtypes_1.Instance) {
                                common_1.listUndefinedLocalCodes(codeSystem, [filter.value.code], this.tank, component);
                            }
                        }
                        return {
                            property: filter.property.toString(),
                            op: filter.operator.toString(),
                            value: this.filterValueToString(filter.value)
                        };
                    });
                }
                if (component.inclusion) {
                    if (((_c = composeElement.concept) === null || _c === void 0 ? void 0 : _c.length) > 0) {
                        // warn the user if they have already included a concept in this component
                        // concept, system, and version must all match to be considered equal
                        const matchingComposeElements = valueSet.compose.include.filter(compose => {
                            var _a;
                            return (compose.system === composeElement.system &&
                                compose.version === composeElement.version &&
                                ((_a = compose.concept) === null || _a === void 0 ? void 0 : _a.length) > 0);
                        });
                        const potentialMatches = lodash_1.flatMap(matchingComposeElements, compose => compose.concept).map(concept => concept.code);
                        composeElement.concept = composeElement.concept.filter((concept, idx, currentConcepts) => {
                            if (potentialMatches.includes(concept.code) ||
                                currentConcepts
                                    .slice(0, idx)
                                    .some(duplicateConcept => duplicateConcept.code === concept.code)) {
                                FSHLogger_1.logger.warn(`ValueSet ${valueSet.name} already includes ${composeElement.system}${composeElement.version ? `|${composeElement.version}` : ''}#${concept.code}`, component.sourceInfo);
                                return false;
                            }
                            return true;
                        });
                        if (composeElement.concept.length > 0) {
                            valueSet.compose.include.push(composeElement);
                        }
                    }
                    else {
                        valueSet.compose.include.push(composeElement);
                    }
                }
                else {
                    valueSet.compose.exclude.push(composeElement);
                }
            });
            if (valueSet.compose.exclude.length == 0) {
                delete valueSet.compose.exclude;
            }
        }
    }
    setCaretRules(valueSet, rules) {
        const vsStructureDefinition = fhirtypes_1.StructureDefinition.fromJSON(this.fisher.fishForFHIR('ValueSet', utils_1.Type.Resource));
        utils_1.resolveSoftIndexing(rules);
        for (const rule of rules) {
            try {
                if (rule instanceof rules_1.CaretValueRule) {
                    const { assignedValue, pathParts } = vsStructureDefinition.validateValueAtPath(rule.caretPath, rule.value, this.fisher);
                    common_1.setPropertyOnInstance(valueSet, pathParts, assignedValue, this.fisher);
                }
            }
            catch (e) {
                FSHLogger_1.logger.error(e.message, rule.sourceInfo);
            }
        }
    }
    filterValueToString(value) {
        if (value instanceof RegExp) {
            return value.source;
        }
        else if (value instanceof fshtypes_1.FshCode) {
            return value.code;
        }
        else {
            return value.toString();
        }
    }
    export() {
        const valueSets = this.tank.getAllValueSets();
        for (const valueSet of valueSets) {
            try {
                this.exportValueSet(valueSet);
            }
            catch (e) {
                FSHLogger_1.logger.error(e.message, valueSet.sourceInfo);
            }
        }
        if (valueSets.length > 0) {
            FSHLogger_1.logger.info(`Converted ${valueSets.length} FHIR ValueSets.`);
        }
        return this.pkg;
    }
    exportValueSet(fshDefinition) {
        if (this.pkg.valueSets.some(vs => vs.name === fshDefinition.name)) {
            return;
        }
        const vs = new fhirtypes_1.ValueSet();
        this.setMetadata(vs, fshDefinition);
        // fshDefinition.rules may include insert rules, which must be expanded before applying other rules
        common_1.applyInsertRules(fshDefinition, this.tank);
        this.setCaretRules(vs, fshDefinition.rules.filter(rule => rule instanceof rules_1.CaretValueRule));
        this.setCompose(vs, fshDefinition.rules.filter(rule => rule instanceof rules_1.ValueSetComponentRule));
        if (vs.compose && vs.compose.include.length == 0) {
            throw new errors_1.ValueSetComposeError(fshDefinition.name);
        }
        // check for another value set with the same id
        // see https://www.hl7.org/fhir/resource.html#id
        if (this.pkg.valueSets.some(valueSet => vs.id === valueSet.id)) {
            FSHLogger_1.logger.error(`Multiple value sets with id ${vs.id}. Each value set must have a unique id.`, fshDefinition.sourceInfo);
        }
        this.pkg.valueSets.push(vs);
        return vs;
    }
}
exports.ValueSetExporter = ValueSetExporter;
//# sourceMappingURL=ValueSetExporter.js.map