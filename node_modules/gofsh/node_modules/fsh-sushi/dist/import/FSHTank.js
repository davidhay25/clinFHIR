"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FSHTank = void 0;
const fshtypes_1 = require("../fshtypes");
const rules_1 = require("../fshtypes/rules");
const Fishable_1 = require("../utils/Fishable");
const common_1 = require("../fhirtypes/common");
const flatMap_1 = __importDefault(require("lodash/flatMap"));
class FSHTank {
    constructor(docs, config) {
        this.docs = docs;
        this.config = config;
    }
    /**
     * Gets all profiles in the tank
     * @returns {Profile[]}
     */
    getAllProfiles() {
        return flatMap_1.default(this.docs, doc => Array.from(doc.profiles.values()));
    }
    /**
     * Gets all extensions in the tank
     * @returns {Extension[]}
     */
    getAllExtensions() {
        return flatMap_1.default(this.docs, doc => Array.from(doc.extensions.values()));
    }
    /**
     * Gets all logical models in the tank
     * @returns {Logical[]}
     */
    getAllLogicals() {
        return flatMap_1.default(this.docs, doc => Array.from(doc.logicals.values()));
    }
    /**
     * Gets all resources in the tank
     * @returns {Resource[]}
     */
    getAllResources() {
        return flatMap_1.default(this.docs, doc => Array.from(doc.resources.values()));
    }
    /**
     * Gets all instances in the tank
     * @returns {Instance[]}
     */
    getAllInstances() {
        return flatMap_1.default(this.docs, doc => Array.from(doc.instances.values()));
    }
    /**
     * Gets all structure definitions (i.e., FshStructures) (profiles, extensions,
     * logical models, and resources) in the tank.
     * @returns {(Profile | Extension)[]}
     */
    getAllStructureDefinitions() {
        return [
            ...this.getAllProfiles(),
            ...this.getAllExtensions(),
            ...this.getAllLogicals(),
            ...this.getAllResources()
        ];
    }
    /**
     * Gets all value sets in the tank
     * @returns {FshValueSet[]}
     */
    getAllValueSets() {
        return flatMap_1.default(this.docs, doc => Array.from(doc.valueSets.values()));
    }
    /**
     * Gets all code systems in the tank
     * @returns {FshCodeSystem[]}
     */
    getAllCodeSystems() {
        return flatMap_1.default(this.docs, doc => Array.from(doc.codeSystems.values()));
    }
    /**
     * Gets all invariants in the tank
     * @returns {Invariant[]}
     */
    getAllInvariants() {
        return flatMap_1.default(this.docs, doc => Array.from(doc.invariants.values()));
    }
    /**
     * Gets all ruleSets in the tank
     * @returns {RuleSet[]}
     */
    getAllRuleSets() {
        return flatMap_1.default(this.docs, doc => Array.from(doc.ruleSets.values()));
    }
    /**
     * Gets all Mappings in the tank
     * @returns {Mapping[]}
     */
    getAllMappings() {
        return flatMap_1.default(this.docs, doc => Array.from(doc.mappings.values()));
    }
    /**
     * Finds the alias in the tank, if it exists
     * @param {string} name - The name of the alias we're looking for
     * @returns {string | undefined}
     */
    resolveAlias(name) {
        for (const doc of this.docs) {
            const foundAlias = doc.aliases.get(name);
            if (foundAlias)
                return foundAlias;
        }
        return undefined;
    }
    fish(item, ...types) {
        var _a;
        // Resolve alias if necessary
        item = (_a = this.resolveAlias(item)) !== null && _a !== void 0 ? _a : item;
        // No types passed in means to search ALL supported types
        if (types.length === 0) {
            types = [
                Fishable_1.Type.Profile,
                Fishable_1.Type.Extension,
                Fishable_1.Type.Logical,
                Fishable_1.Type.Resource,
                Fishable_1.Type.ValueSet,
                Fishable_1.Type.CodeSystem,
                Fishable_1.Type.Instance,
                Fishable_1.Type.Invariant,
                Fishable_1.Type.RuleSet,
                Fishable_1.Type.Mapping
            ];
        }
        for (const t of types) {
            let result;
            switch (t) {
                case Fishable_1.Type.Profile:
                    result = this.getAllProfiles().find(p => p.name === item ||
                        p.id === item ||
                        common_1.getUrlFromFshDefinition(p, this.config.canonical) === item);
                    break;
                case Fishable_1.Type.Extension:
                    result = this.getAllExtensions().find(e => e.name === item ||
                        e.id === item ||
                        common_1.getUrlFromFshDefinition(e, this.config.canonical) === item);
                    break;
                case Fishable_1.Type.Logical:
                    result = this.getAllLogicals().find(l => l.name === item ||
                        l.id === item ||
                        common_1.getUrlFromFshDefinition(l, this.config.canonical) === item);
                    break;
                case Fishable_1.Type.Resource:
                    result = this.getAllResources().find(r => r.name === item ||
                        r.id === item ||
                        common_1.getUrlFromFshDefinition(r, this.config.canonical) === item);
                    break;
                case Fishable_1.Type.ValueSet:
                    result = this.getAllValueSets().find(vs => vs.name === item ||
                        vs.id === item ||
                        common_1.getUrlFromFshDefinition(vs, this.config.canonical) === item);
                    break;
                case Fishable_1.Type.CodeSystem:
                    result = this.getAllCodeSystems().find(cs => cs.name === item ||
                        cs.id === item ||
                        common_1.getUrlFromFshDefinition(cs, this.config.canonical) === item);
                    if (!result) {
                        result = this.getAllInstances().find(csInstance => (csInstance === null || csInstance === void 0 ? void 0 : csInstance.instanceOf) === 'CodeSystem' &&
                            (csInstance === null || csInstance === void 0 ? void 0 : csInstance.usage) === 'Definition' &&
                            ((csInstance === null || csInstance === void 0 ? void 0 : csInstance.name) === item ||
                                csInstance.id === item ||
                                common_1.getUrlFromFshDefinition(csInstance, this.config.canonical) === item));
                    }
                    break;
                case Fishable_1.Type.Instance:
                    result = this.getAllInstances().find(i => i.name === item || i.id === item);
                    break;
                case Fishable_1.Type.Invariant:
                    result = this.getAllInvariants().find(i => i.name === item);
                    break;
                case Fishable_1.Type.RuleSet:
                    result = this.getAllRuleSets().find(r => r.name === item);
                    break;
                case Fishable_1.Type.Mapping:
                    result = this.getAllMappings().find(m => m.name === item);
                    break;
                case Fishable_1.Type.Type:
                default:
                    // Tank doesn't support these types
                    break;
            }
            if (result != null) {
                return result;
            }
        }
        // No match, return undefined
        return;
    }
    fishForAppliedRuleSet(item) {
        for (const doc of this.docs) {
            const ruleSet = doc.appliedRuleSets.get(item);
            if (ruleSet) {
                return ruleSet;
            }
        }
    }
    fishForMetadata(item, ...types) {
        var _a;
        const result = this.fish(item, ...types);
        if (result) {
            const meta = {
                id: result.id,
                name: result.name
            };
            if (result instanceof fshtypes_1.Profile ||
                result instanceof fshtypes_1.Extension ||
                result instanceof fshtypes_1.Logical ||
                result instanceof fshtypes_1.Resource) {
                meta.url = common_1.getUrlFromFshDefinition(result, this.config.canonical);
                meta.parent = result.parent;
                meta.resourceType = 'StructureDefinition';
                if (result instanceof fshtypes_1.Logical) {
                    // Logical models should always use an absolute URL as their StructureDefinition.type
                    // unless HL7 published them. In that case, the URL is relative to
                    // http://hl7.org/fhir/StructureDefinition/.
                    // Ref: https://chat.fhir.org/#narrow/stream/179177-conformance/topic/StructureDefinition.2Etype.20for.20Logical.20Models.2FCustom.20Resources/near/240488388
                    const HL7_URL = 'http://hl7.org/fhir/StructureDefinition/';
                    meta.sdType = meta.url.startsWith(HL7_URL) ? meta.url.slice(HL7_URL.length) : meta.url;
                }
            }
            else if (result instanceof fshtypes_1.FshValueSet || result instanceof fshtypes_1.FshCodeSystem) {
                meta.url = common_1.getUrlFromFshDefinition(result, this.config.canonical);
                if (result instanceof fshtypes_1.FshValueSet) {
                    meta.resourceType = 'ValueSet';
                }
                else {
                    meta.resourceType = 'CodeSystem';
                }
            }
            else if (result instanceof fshtypes_1.Instance) {
                (_a = result.rules) === null || _a === void 0 ? void 0 : _a.forEach(r => {
                    if (r.path === 'url' && r instanceof rules_1.AssignmentRule && typeof r.value === 'string') {
                        meta.url = r.value;
                        // don't break; keep looping in case there is a later rule that re-assigns url
                    }
                });
                meta.instanceUsage = result.usage;
            }
            return meta;
        }
        return;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    fishForFHIR(item, ...types) {
        // the FSHTank cannot return FHIR definitions, but we define this function
        // in order to implement the Fishable interface
    }
}
exports.FSHTank = FSHTank;
//# sourceMappingURL=FSHTank.js.map