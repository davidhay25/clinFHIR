"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FSHImporter = void 0;
const pc = __importStar(require("./parserContexts"));
const FSHDocument_1 = require("./FSHDocument");
const FSHErrorListener_1 = require("./FSHErrorListener");
const FSHVisitor_1 = require("./generated/FSHVisitor");
const FSHLexer_1 = require("./generated/FSHLexer");
const FSHParser_1 = require("./generated/FSHParser");
const fshtypes_1 = require("../fshtypes");
const rules_1 = require("../fshtypes/rules");
const common_1 = require("../fhirtypes/common");
const antlr4_1 = require("antlr4");
const FSHLogger_1 = require("../utils/FSHLogger");
const Tree_1 = require("antlr4/tree/Tree");
const errors_1 = require("../errors");
const isEmpty_1 = __importDefault(require("lodash/isEmpty"));
const isEqual_1 = __importDefault(require("lodash/isEqual"));
const sortBy_1 = __importDefault(require("lodash/sortBy"));
const upperFirst_1 = __importDefault(require("lodash/upperFirst"));
const min_1 = __importDefault(require("lodash/min"));
const parseCodeLexeme_1 = require("./parseCodeLexeme");
const os_1 = require("os");
var SdMetadataKey;
(function (SdMetadataKey) {
    SdMetadataKey["Id"] = "Id";
    SdMetadataKey["Parent"] = "Parent";
    SdMetadataKey["Title"] = "Title";
    SdMetadataKey["Description"] = "Description";
    SdMetadataKey["Unknown"] = "Unknown";
})(SdMetadataKey || (SdMetadataKey = {}));
var InstanceMetadataKey;
(function (InstanceMetadataKey) {
    InstanceMetadataKey["InstanceOf"] = "InstanceOf";
    InstanceMetadataKey["Title"] = "Title";
    InstanceMetadataKey["Description"] = "Description";
    InstanceMetadataKey["Usage"] = "Usage";
    InstanceMetadataKey["Unknown"] = "Unknown";
})(InstanceMetadataKey || (InstanceMetadataKey = {}));
var VsMetadataKey;
(function (VsMetadataKey) {
    VsMetadataKey["Id"] = "Id";
    VsMetadataKey["Title"] = "Title";
    VsMetadataKey["Description"] = "Description";
    VsMetadataKey["Unknown"] = "Unknown";
})(VsMetadataKey || (VsMetadataKey = {}));
var CsMetadataKey;
(function (CsMetadataKey) {
    CsMetadataKey["Id"] = "Id";
    CsMetadataKey["Title"] = "Title";
    CsMetadataKey["Description"] = "Description";
    CsMetadataKey["Unknown"] = "Unknown";
})(CsMetadataKey || (CsMetadataKey = {}));
var InvariantMetadataKey;
(function (InvariantMetadataKey) {
    InvariantMetadataKey["Description"] = "Description";
    InvariantMetadataKey["Expression"] = "Expression";
    InvariantMetadataKey["XPath"] = "XPath";
    InvariantMetadataKey["Severity"] = "Severity";
    InvariantMetadataKey["Unknown"] = "Unknown";
})(InvariantMetadataKey || (InvariantMetadataKey = {}));
var MappingMetadataKey;
(function (MappingMetadataKey) {
    MappingMetadataKey["Id"] = "Id";
    MappingMetadataKey["Source"] = "Source";
    MappingMetadataKey["Target"] = "Target";
    MappingMetadataKey["Description"] = "Description";
    MappingMetadataKey["Title"] = "Title";
    MappingMetadataKey["Unknown"] = "Unknown";
})(MappingMetadataKey || (MappingMetadataKey = {}));
var Flag;
(function (Flag) {
    Flag[Flag["MustSupport"] = 0] = "MustSupport";
    Flag[Flag["Summary"] = 1] = "Summary";
    Flag[Flag["Modifier"] = 2] = "Modifier";
    Flag[Flag["TrialUse"] = 3] = "TrialUse";
    Flag[Flag["Normative"] = 4] = "Normative";
    Flag[Flag["Draft"] = 5] = "Draft";
    Flag[Flag["Unknown"] = 6] = "Unknown";
})(Flag || (Flag = {}));
const FLAGS = ['MS', 'SU', '?!', 'TU', 'N', 'D'];
const INDENT_WIDTH = 2;
const DEFAULT_START_COLUMN = 1;
/**
 * FSHImporter handles the parsing of FSH documents, constructing the data into FSH types.
 * FSHImporter uses a visitor pattern approach with some accomodations due to the ANTLR4
 * implementation and TypeScript requirements.  For example, the `accept` functions that
 * each `ctx` has cannot be used because their signatures return `void` by default. Instead,
 * we must call the explicit visitX functions.
 */
class FSHImporter extends FSHVisitor_1.FSHVisitor {
    constructor() {
        super();
        this.docs = [];
        this.paramRuleSets = new Map();
        this.topLevelParse = true;
    }
    import(rawFSHes) {
        this.allAliases = new Map();
        const contexts = [];
        // Preprocess the FSH files
        rawFSHes.forEach(rawFSH => {
            var _a;
            // Create and store doc for main import process
            const doc = new FSHDocument_1.FSHDocument(rawFSH.path);
            this.docs.push(doc);
            this.currentDoc = doc;
            this.currentFile = (_a = this.currentDoc.file) !== null && _a !== void 0 ? _a : '';
            // Create and store context for main import process
            // We are appending a newline to the file content if there is not one there already.
            // This is being done because we discovered a syntax error that occurs if a comments
            // ends a file, and there is no newline after it. Comments are only tokenized in our
            // grammar if a newline follows it. In order to prevent this error from occurring,
            // we add a newline to the content before we parse it so comments at EOF can be tokenized.
            const content = rawFSH.content.endsWith('\n') ? rawFSH.content : rawFSH.content + '\n';
            const ctx = this.parseDoc(content, rawFSH.path);
            contexts.push(ctx);
            // Collect the aliases and store in global map
            ctx.entity().forEach(e => {
                var _a, _b, _c;
                if (e.alias()) {
                    const name = e.alias().SEQUENCE()[0].getText();
                    let value = (_a = e.alias().SEQUENCE()[1]) === null || _a === void 0 ? void 0 : _a.getText();
                    // When the url contains a fragment (http://example.org#fragment), the grammar will read it as a
                    // CODE, so we also accept that for the value here
                    if (!value && e.alias().CODE()) {
                        value = e.alias().CODE().getText();
                    }
                    if (name.includes('|')) {
                        FSHLogger_1.logger.error(`Alias ${name} cannot include "|" since the "|" character is reserved for indicating a version`, { file: (_b = doc.file) !== null && _b !== void 0 ? _b : '', location: this.extractStartStop(e.alias()) });
                        return;
                    }
                    if (this.allAliases.has(name) && this.allAliases.get(name) !== value) {
                        FSHLogger_1.logger.error(`Alias ${name} cannot be redefined to ${value}; it is already defined as ${this.allAliases.get(name)}.`, { file: (_c = doc.file) !== null && _c !== void 0 ? _c : '', location: this.extractStartStop(e.alias()) });
                        // don't set it -- just keep the original definition
                    }
                    else {
                        this.allAliases.set(name, value);
                        doc.aliases.set(name, value);
                    }
                }
                if (e.paramRuleSet()) {
                    this.visitParamRuleSet(e.paramRuleSet());
                }
            });
            this.currentDoc = null;
            this.currentFile = null;
        });
        FSHLogger_1.logger.info(`Preprocessed ${this.docs.length} documents with ${this.allAliases.size} aliases.`);
        // Now do the main import
        contexts.forEach((context, index) => {
            var _a;
            this.currentDoc = this.docs[index];
            this.currentFile = (_a = this.currentDoc.file) !== null && _a !== void 0 ? _a : '';
            this.visitDoc(context);
            this.currentDoc = null;
            this.currentFile = null;
        });
        let [definitions, instances] = [0, 0];
        this.docs.forEach(doc => {
            definitions +=
                doc.codeSystems.size + doc.extensions.size + doc.profiles.size + doc.valueSets.size;
            instances += doc.instances.size;
        });
        FSHLogger_1.logger.info(`Imported ${definitions} definitions and ${instances} instances.`);
        return this.docs;
    }
    visitDoc(ctx) {
        ctx.entity().forEach(e => {
            try {
                this.visitEntity(e);
            }
            catch (err) {
                const sourceInfo = { location: this.extractStartStop(e), file: this.currentFile };
                FSHLogger_1.logger.error(`Error in parsing: ${err.message}`, sourceInfo);
            }
        });
    }
    visitEntity(ctx) {
        // Reset the pathContext for each entity
        this.pathContext = [];
        if (ctx.profile()) {
            this.visitProfile(ctx.profile());
        }
        else if (ctx.extension()) {
            this.visitExtension(ctx.extension());
        }
        else if (ctx.resource()) {
            this.visitResource(ctx.resource());
        }
        else if (ctx.logical()) {
            this.visitLogical(ctx.logical());
        }
        else if (ctx.instance()) {
            this.visitInstance(ctx.instance());
        }
        else if (ctx.valueSet()) {
            this.visitValueSet(ctx.valueSet());
        }
        else if (ctx.codeSystem()) {
            this.visitCodeSystem(ctx.codeSystem());
        }
        else if (ctx.invariant()) {
            this.visitInvariant(ctx.invariant());
        }
        else if (ctx.ruleSet()) {
            this.visitRuleSet(ctx.ruleSet());
        }
        else if (ctx.mapping()) {
            this.visitMapping(ctx.mapping());
        }
    }
    visitProfile(ctx) {
        const profile = new fshtypes_1.Profile(ctx.name().getText())
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        if (this.docs.some(doc => doc.profiles.has(profile.name))) {
            FSHLogger_1.logger.error(`Skipping Profile: a Profile named ${profile.name} already exists.`, {
                file: this.currentFile,
                location: this.extractStartStop(ctx)
            });
        }
        else {
            this.parseProfileOrExtension(profile, ctx.sdMetadata(), ctx.sdRule());
            this.currentDoc.profiles.set(profile.name, profile);
        }
    }
    visitExtension(ctx) {
        const extension = new fshtypes_1.Extension(ctx.name().getText())
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        if (this.docs.some(doc => doc.extensions.has(extension.name))) {
            FSHLogger_1.logger.error(`Skipping Extension: an Extension named ${extension.name} already exists.`, {
                file: this.currentFile,
                location: this.extractStartStop(ctx)
            });
        }
        else {
            this.parseProfileOrExtension(extension, ctx.sdMetadata(), ctx.sdRule());
            this.currentDoc.extensions.set(extension.name, extension);
        }
    }
    parseProfileOrExtension(def, metaCtx = [], ruleCtx = []) {
        const seenPairs = new Map();
        metaCtx
            .map(sdMeta => (Object.assign(Object.assign({}, this.visitSdMetadata(sdMeta)), { context: sdMeta })))
            .forEach(pair => {
            if (seenPairs.has(pair.key)) {
                FSHLogger_1.logger.error(`Metadata field '${pair.key}' already declared with value '${seenPairs.get(pair.key)}'.`, { file: this.currentFile, location: this.extractStartStop(pair.context) });
                return;
            }
            seenPairs.set(pair.key, pair.value);
            if (pair.key === SdMetadataKey.Id) {
                def.id = pair.value;
            }
            else if (pair.key === SdMetadataKey.Parent) {
                def.parent = pair.value;
            }
            else if (pair.key === SdMetadataKey.Title) {
                def.title = pair.value;
            }
            else if (pair.key === SdMetadataKey.Description) {
                def.description = pair.value;
            }
        });
        ruleCtx.forEach(sdRule => {
            def.rules.push(...this.visitSdRule(sdRule));
        });
    }
    visitResource(ctx) {
        const resource = new fshtypes_1.Resource(ctx.name().getText())
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        if (this.docs.some(doc => doc.resources.has(resource.name))) {
            FSHLogger_1.logger.error(`Skipping Resource: a Resource named ${resource.name} already exists.`, {
                file: this.currentFile,
                location: this.extractStartStop(ctx)
            });
        }
        else {
            this.parseResourceOrLogical(resource, ctx.sdMetadata(), ctx.lrRule());
            this.currentDoc.resources.set(resource.name, resource);
        }
    }
    visitLogical(ctx) {
        const logical = new fshtypes_1.Logical(ctx.name().getText())
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        if (this.docs.some(doc => doc.logicals.has(logical.name))) {
            FSHLogger_1.logger.error(`Skipping Logical Model: a Logical Model named ${logical.name} already exists.`, {
                file: this.currentFile,
                location: this.extractStartStop(ctx)
            });
        }
        else {
            this.parseResourceOrLogical(logical, ctx.sdMetadata(), ctx.lrRule());
            this.currentDoc.logicals.set(logical.name, logical);
        }
    }
    parseResourceOrLogical(def, metaCtx = [], ruleCtx = []) {
        const seenPairs = new Map();
        metaCtx
            .map(sdMeta => (Object.assign(Object.assign({}, this.visitSdMetadata(sdMeta)), { context: sdMeta })))
            .forEach(pair => {
            if (seenPairs.has(pair.key)) {
                FSHLogger_1.logger.error(`Metadata field '${pair.key}' already declared with value '${seenPairs.get(pair.key)}'.`, { file: this.currentFile, location: this.extractStartStop(pair.context) });
                return;
            }
            seenPairs.set(pair.key, pair.value);
            if (pair.key === SdMetadataKey.Id) {
                def.id = pair.value;
            }
            else if (pair.key === SdMetadataKey.Parent) {
                def.parent = pair.value;
            }
            else if (pair.key === SdMetadataKey.Title) {
                def.title = pair.value;
            }
            else if (pair.key === SdMetadataKey.Description) {
                def.description = pair.value;
            }
        });
        ruleCtx.forEach(lrRule => {
            def.rules.push(...this.visitLrRule(lrRule));
        });
    }
    visitInstance(ctx) {
        const instance = new fshtypes_1.Instance(ctx.name().getText())
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        if (this.docs.some(doc => doc.instances.has(instance.name))) {
            FSHLogger_1.logger.error(`Skipping Instance: an Instance named ${instance.name} already exists.`, {
                file: this.currentFile,
                location: this.extractStartStop(ctx)
            });
        }
        else {
            try {
                this.parseInstance(instance, ctx.instanceMetadata(), ctx.instanceRule());
                this.currentDoc.instances.set(instance.name, instance);
            }
            catch (e) {
                FSHLogger_1.logger.error(e.message, instance.sourceInfo);
            }
        }
    }
    parseInstance(instance, metaCtx = [], ruleCtx = []) {
        const seenPairs = new Map();
        metaCtx
            .map(instanceMetadata => (Object.assign(Object.assign({}, this.visitInstanceMetadata(instanceMetadata)), { context: instanceMetadata })))
            .forEach(pair => {
            if (seenPairs.has(pair.key)) {
                FSHLogger_1.logger.error(`Metadata field '${pair.key}' already declared with value '${seenPairs.get(pair.key)}'.`, { file: this.currentFile, location: this.extractStartStop(pair.context) });
                return;
            }
            seenPairs.set(pair.key, pair.value);
            if (pair.key === InstanceMetadataKey.InstanceOf) {
                instance.instanceOf = pair.value;
            }
            else if (pair.key === InstanceMetadataKey.Title) {
                instance.title = pair.value;
            }
            else if (pair.key === InstanceMetadataKey.Description) {
                instance.description = pair.value;
            }
            else if (pair.key === InstanceMetadataKey.Usage) {
                instance.usage = pair.value;
            }
        });
        if (!instance.instanceOf) {
            throw new errors_1.RequiredMetadataError('InstanceOf', 'Instance', instance.name);
        }
        ruleCtx.forEach(instanceRule => {
            const rule = this.visitInstanceRule(instanceRule);
            if (rule) {
                instance.rules.push(rule);
            }
        });
    }
    visitValueSet(ctx) {
        const valueSet = new fshtypes_1.FshValueSet(ctx.name().getText())
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        if (this.docs.some(doc => doc.valueSets.has(valueSet.name))) {
            FSHLogger_1.logger.error(`Skipping ValueSet: a ValueSet named ${valueSet.name} already exists.`, {
                file: this.currentFile,
                location: this.extractStartStop(ctx)
            });
        }
        else {
            this.parseValueSet(valueSet, ctx.vsMetadata(), ctx.vsRule());
            this.currentDoc.valueSets.set(valueSet.name, valueSet);
        }
    }
    parseValueSet(valueSet, metaCtx = [], vsRuleCtx = []) {
        const seenPairs = new Map();
        metaCtx
            .map(vsMetadata => (Object.assign(Object.assign({}, this.visitVsMetadata(vsMetadata)), { context: vsMetadata })))
            .forEach(pair => {
            if (seenPairs.has(pair.key)) {
                FSHLogger_1.logger.error(`Metadata field '${pair.key}' already declared with value '${seenPairs.get(pair.key)}'.`, { file: this.currentFile, location: this.extractStartStop(pair.context) });
                return;
            }
            seenPairs.set(pair.key, pair.value);
            if (pair.key === VsMetadataKey.Id) {
                valueSet.id = pair.value;
            }
            else if (pair.key === VsMetadataKey.Title) {
                valueSet.title = pair.value;
            }
            else if (pair.key === VsMetadataKey.Description) {
                valueSet.description = pair.value;
            }
        });
        vsRuleCtx.forEach(vsRule => {
            const rule = this.visitVsRule(vsRule);
            // if rule is a concept component,
            // we may be able to merge its concepts into an existing concept component.
            if (rule instanceof rules_1.ValueSetConceptComponentRule) {
                const matchedComponent = valueSet.rules.find(existingComponent => {
                    return (existingComponent instanceof rules_1.ValueSetConceptComponentRule &&
                        rule.inclusion == existingComponent.inclusion &&
                        rule.from.system == existingComponent.from.system &&
                        isEqual_1.default(sortBy_1.default(rule.from.valueSets), sortBy_1.default(existingComponent.from.valueSets)));
                });
                if (matchedComponent) {
                    matchedComponent.concepts.push(...rule.concepts);
                }
                else {
                    valueSet.rules.push(rule);
                }
            }
            else if (rule) {
                valueSet.rules.push(rule);
            }
        });
    }
    visitCodeSystem(ctx) {
        const codeSystem = new fshtypes_1.FshCodeSystem(ctx.name().getText())
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        if (this.docs.some(doc => doc.codeSystems.has(codeSystem.name))) {
            FSHLogger_1.logger.error(`Skipping code system: a code system named ${codeSystem.name} already exists.`, {
                file: this.currentFile,
                location: this.extractStartStop(ctx)
            });
        }
        else {
            this.parseCodeSystem(codeSystem, ctx.csMetadata(), ctx.csRule());
            this.currentDoc.codeSystems.set(codeSystem.name, codeSystem);
        }
    }
    parseCodeSystem(codeSystem, metaCtx = [], csRuleCtx = []) {
        const seenPairs = new Map();
        metaCtx
            .map(csMetadata => (Object.assign(Object.assign({}, this.visitCsMetadata(csMetadata)), { context: csMetadata })))
            .forEach(pair => {
            if (seenPairs.has(pair.key)) {
                FSHLogger_1.logger.error(`Metadata field '${pair.key}' already declared with value '${seenPairs.get(pair.key)}'.`, { file: this.currentFile, location: this.extractStartStop(pair.context) });
                return;
            }
            seenPairs.set(pair.key, pair.value);
            if (pair.key === CsMetadataKey.Id) {
                codeSystem.id = pair.value;
            }
            else if (pair.key === CsMetadataKey.Title) {
                codeSystem.title = pair.value;
            }
            else if (pair.key === CsMetadataKey.Description) {
                codeSystem.description = pair.value;
            }
        });
        csRuleCtx.forEach(ruleCtx => {
            const rule = this.visitCsRule(ruleCtx);
            if (rule instanceof rules_1.ConceptRule) {
                try {
                    codeSystem.addConcept(rule);
                }
                catch (e) {
                    FSHLogger_1.logger.error(e.message, rule.sourceInfo);
                }
            }
            else if (rule) {
                codeSystem.rules.push(rule);
            }
        });
    }
    visitInvariant(ctx) {
        const invariant = new fshtypes_1.Invariant(ctx.name().getText())
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        if (this.docs.some(doc => doc.invariants.has(invariant.name))) {
            FSHLogger_1.logger.error(`Skipping Invariant: an Invariant named ${invariant.name} already exists.`, {
                file: this.currentFile,
                location: this.extractStartStop(ctx)
            });
        }
        else {
            this.parseInvariant(invariant, ctx.invariantMetadata());
            if (invariant.description == null) {
                FSHLogger_1.logger.error(`Invariant ${invariant.name} must have a Description.`, invariant.sourceInfo);
            }
            if (invariant.severity == null) {
                FSHLogger_1.logger.error(`Invariant ${invariant.name} must have a Severity.`, invariant.sourceInfo);
            }
            this.currentDoc.invariants.set(invariant.name, invariant);
        }
    }
    parseInvariant(invariant, metaCtx = []) {
        const seenPairs = new Map();
        metaCtx
            .map(invariantMetadata => (Object.assign(Object.assign({}, this.visitInvariantMetadata(invariantMetadata)), { context: invariantMetadata })))
            .forEach(pair => {
            if (seenPairs.has(pair.key)) {
                FSHLogger_1.logger.error(`Metadata field '${pair.key}' already declared with value '${seenPairs.get(pair.key)}'.`, { file: this.currentFile, location: this.extractStartStop(pair.context) });
                return;
            }
            seenPairs.set(pair.key, pair.value);
            if (pair.key === InvariantMetadataKey.Description) {
                invariant.description = pair.value;
            }
            else if (pair.key === InvariantMetadataKey.Expression) {
                invariant.expression = pair.value;
            }
            else if (pair.key === InvariantMetadataKey.Severity) {
                invariant.severity = pair.value;
            }
            else if (pair.key === InvariantMetadataKey.XPath) {
                invariant.xpath = pair.value;
            }
        });
    }
    visitRuleSet(ctx) {
        const ruleSet = new fshtypes_1.RuleSet(ctx.RULESET_REFERENCE().getText().trim())
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        if (this.docs.some(doc => doc.ruleSets.has(ruleSet.name))) {
            FSHLogger_1.logger.error(`Skipping RuleSet: a RuleSet named ${ruleSet.name} already exists.`, {
                file: this.currentFile,
                location: this.extractStartStop(ctx)
            });
        }
        else {
            this.parseRuleSet(ruleSet, ctx.ruleSetRule());
            this.currentDoc.ruleSets.set(ruleSet.name, ruleSet);
        }
    }
    parseRuleSet(ruleSet, rules) {
        rules.forEach(rule => {
            if (rule.sdRule()) {
                ruleSet.rules.push(...this.visitSdRule(rule.sdRule()));
            }
            else if (rule.vsComponent()) {
                ruleSet.rules.push(this.visitVsComponent(rule.vsComponent()));
            }
            else if (rule.concept()) {
                ruleSet.rules.push(this.visitConcept(rule.concept()));
            }
            else if (rule.addElementRule()) {
                ruleSet.rules.push(this.visitAddElementRule(rule.addElementRule()));
            }
            else if (rule.codeCaretValueRule()) {
                ruleSet.rules.push(this.visitCodeCaretValueRule(rule.codeCaretValueRule()));
            }
            else if (rule.mappingRule()) {
                ruleSet.rules.push(this.visitMappingRule(rule.mappingRule()));
            }
        });
    }
    visitParamRuleSet(ctx) {
        const [rulesetName, ruleParams] = this.parseRulesetReference(ctx.PARAM_RULESET_REFERENCE().getText());
        const paramRuleSet = new fshtypes_1.ParamRuleSet(rulesetName)
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        if (this.paramRuleSets.has(paramRuleSet.name)) {
            FSHLogger_1.logger.error(`Skipping RuleSet: a RuleSet named ${paramRuleSet.name} already exists.`, {
                file: this.currentFile,
                location: this.extractStartStop(ctx)
            });
        }
        else {
            paramRuleSet.parameters = ruleParams
                .replace(/(^\()|(\)$)/g, '')
                .split(',')
                .map(param => param.trim());
            paramRuleSet.contents = this.visitParamRuleSetContent(ctx.paramRuleSetContent());
            const unusedParameters = paramRuleSet.getUnusedParameters();
            if (unusedParameters.length > 0) {
                FSHLogger_1.logger.warn(`RuleSet ${paramRuleSet.name} contains unused parameter${unusedParameters.length > 1 ? 's' : ''}: ${unusedParameters.join(', ')}`, paramRuleSet.sourceInfo);
            }
            this.paramRuleSets.set(paramRuleSet.name, paramRuleSet);
        }
    }
    visitParamRuleSetContent(ctx) {
        return ctx.start.getInputStream().getText(ctx.start.start, ctx.stop.stop);
    }
    visitMapping(ctx) {
        const mapping = new fshtypes_1.Mapping(ctx.name().getText())
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        if (this.docs.some(doc => doc.mappings.has(mapping.name))) {
            FSHLogger_1.logger.error(`Skipping Mapping: a Mapping named ${mapping.name} already exists.`, {
                file: this.currentFile,
                location: this.extractStartStop(ctx)
            });
        }
        else {
            this.parseMapping(mapping, ctx.mappingMetadata(), ctx.mappingEntityRule());
            this.currentDoc.mappings.set(mapping.name, mapping);
        }
    }
    parseMapping(mapping, metaCtx = [], ruleCtx = []) {
        const seenPairs = new Map();
        metaCtx
            .map(mapMeta => (Object.assign(Object.assign({}, this.visitMappingMetadata(mapMeta)), { context: mapMeta })))
            .forEach(pair => {
            if (seenPairs.has(pair.key)) {
                FSHLogger_1.logger.error(`Metadata field '${pair.key}' already declared with value '${seenPairs.get(pair.key)}'.`, { file: this.currentFile, location: this.extractStartStop(pair.context) });
                return;
            }
            seenPairs.set(pair.key, pair.value);
            if (pair.key === MappingMetadataKey.Id) {
                mapping.id = pair.value;
            }
            else if (pair.key === MappingMetadataKey.Source) {
                mapping.source = pair.value;
            }
            else if (pair.key === MappingMetadataKey.Target) {
                mapping.target = pair.value;
            }
            else if (pair.key === MappingMetadataKey.Description) {
                mapping.description = pair.value;
            }
            else if (pair.key === MappingMetadataKey.Title) {
                mapping.title = pair.value;
            }
        });
        ruleCtx.forEach(mappingRule => {
            const rule = this.visitMappingEntityRule(mappingRule);
            if (rule) {
                mapping.rules.push(rule);
            }
        });
    }
    visitSdMetadata(ctx) {
        if (ctx.id()) {
            return { key: SdMetadataKey.Id, value: this.visitId(ctx.id()) };
        }
        else if (ctx.parent()) {
            return { key: SdMetadataKey.Parent, value: this.visitParent(ctx.parent()) };
        }
        else if (ctx.title()) {
            return { key: SdMetadataKey.Title, value: this.visitTitle(ctx.title()) };
        }
        else if (ctx.description()) {
            return { key: SdMetadataKey.Description, value: this.visitDescription(ctx.description()) };
        }
        return { key: SdMetadataKey.Unknown, value: ctx.getText() };
    }
    visitInstanceMetadata(ctx) {
        if (ctx.instanceOf()) {
            return { key: InstanceMetadataKey.InstanceOf, value: this.visitInstanceOf(ctx.instanceOf()) };
        }
        else if (ctx.title()) {
            return { key: InstanceMetadataKey.Title, value: this.visitTitle(ctx.title()) };
        }
        else if (ctx.description()) {
            return {
                key: InstanceMetadataKey.Description,
                value: this.visitDescription(ctx.description())
            };
        }
        else if (ctx.usage()) {
            return {
                key: InstanceMetadataKey.Usage,
                value: this.visitUsage(ctx.usage())
            };
        }
        return { key: InstanceMetadataKey.Unknown, value: ctx.getText() };
    }
    visitVsMetadata(ctx) {
        if (ctx.id()) {
            return { key: VsMetadataKey.Id, value: this.visitId(ctx.id()) };
        }
        else if (ctx.title()) {
            return { key: VsMetadataKey.Title, value: this.visitTitle(ctx.title()) };
        }
        else if (ctx.description()) {
            return { key: VsMetadataKey.Description, value: this.visitDescription(ctx.description()) };
        }
        return { key: VsMetadataKey.Unknown, value: ctx.getText() };
    }
    visitCsMetadata(ctx) {
        if (ctx.id()) {
            return { key: CsMetadataKey.Id, value: this.visitId(ctx.id()) };
        }
        else if (ctx.title()) {
            return { key: CsMetadataKey.Title, value: this.visitTitle(ctx.title()) };
        }
        else if (ctx.description()) {
            return { key: CsMetadataKey.Description, value: this.visitDescription(ctx.description()) };
        }
        return { key: CsMetadataKey.Unknown, value: ctx.getText() };
    }
    visitInvariantMetadata(ctx) {
        if (ctx.description()) {
            return {
                key: InvariantMetadataKey.Description,
                value: this.visitDescription(ctx.description())
            };
        }
        else if (ctx.expression()) {
            return {
                key: InvariantMetadataKey.Expression,
                value: this.visitExpression(ctx.expression())
            };
        }
        else if (ctx.xpath()) {
            return {
                key: InvariantMetadataKey.XPath,
                value: this.visitXpath(ctx.xpath())
            };
        }
        else if (ctx.severity()) {
            return {
                key: InvariantMetadataKey.Severity,
                value: this.visitSeverity(ctx.severity())
            };
        }
        return {
            key: InvariantMetadataKey.Unknown,
            value: ctx.getText()
        };
    }
    visitMappingMetadata(ctx) {
        if (ctx.id()) {
            return { key: MappingMetadataKey.Id, value: this.visitId(ctx.id()) };
        }
        else if (ctx.source()) {
            return { key: MappingMetadataKey.Source, value: this.visitSource(ctx.source()) };
        }
        else if (ctx.target()) {
            return { key: MappingMetadataKey.Target, value: this.visitTarget(ctx.target()) };
        }
        else if (ctx.description()) {
            return {
                key: MappingMetadataKey.Description,
                value: this.visitDescription(ctx.description())
            };
        }
        else if (ctx.title()) {
            return { key: MappingMetadataKey.Title, value: this.visitTitle(ctx.title()) };
        }
        return { key: MappingMetadataKey.Unknown, value: ctx.getText() };
    }
    visitId(ctx) {
        return ctx.name().getText();
    }
    visitParent(ctx) {
        return this.aliasAwareValue(ctx.name());
    }
    visitTitle(ctx) {
        return this.extractString(ctx.STRING());
    }
    visitDescription(ctx) {
        if (ctx.STRING()) {
            return this.extractString(ctx.STRING());
        }
        else if (ctx.MULTILINE_STRING()) {
            return this.extractMultilineString(ctx.MULTILINE_STRING());
        }
        // this can happen due to parsing errors, so just return empty string
        return '';
    }
    visitInstanceOf(ctx) {
        return this.aliasAwareValue(ctx.name());
    }
    visitUsage(ctx) {
        var _a;
        const usageConcept = this.parseCodeLexeme(ctx.CODE().getText(), ctx.CODE())
            .withLocation(this.extractStartStop(ctx.CODE()))
            .withFile(this.currentFile);
        if (((_a = usageConcept.system) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            FSHLogger_1.logger.warn('Do not specify a system for instance Usage.', usageConcept.sourceInfo);
        }
        let usage = upperFirst_1.default(usageConcept.code);
        if (!fshtypes_1.isInstanceUsage(usage)) {
            FSHLogger_1.logger.error('Invalid Usage. Supported usage codes are "#example", "#definition", and "#inline". Instance will be treated as an example.', usageConcept.sourceInfo);
            usage = 'Example';
        }
        return usage;
    }
    visitExpression(ctx) {
        return this.extractString(ctx.STRING());
    }
    visitXpath(ctx) {
        return this.extractString(ctx.STRING());
    }
    visitSeverity(ctx) {
        var _a;
        const concept = this.parseCodeLexeme(ctx.CODE().getText(), ctx.CODE())
            .withLocation(this.extractStartStop(ctx.CODE()))
            .withFile(this.currentFile);
        if (((_a = concept.system) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            FSHLogger_1.logger.warn('Do not specify a system for invariant severity.', concept.sourceInfo);
        }
        if (concept.code != 'error' && concept.code != 'warning') {
            FSHLogger_1.logger.error('Invalid invariant severity code: code must be "#error" or "#warning".', concept.sourceInfo);
        }
        return concept;
    }
    visitSource(ctx) {
        return this.aliasAwareValue(ctx.name());
    }
    visitTarget(ctx) {
        return this.extractString(ctx.STRING());
    }
    parseCodeLexeme(conceptText, parentCtx) {
        var _a;
        const concept = parseCodeLexeme_1.parseCodeLexeme(conceptText);
        if (((_a = concept.system) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            concept.system = this.aliasAwareValue(parentCtx, concept.system);
        }
        return concept;
    }
    visitLrRule(ctx) {
        if (ctx.addElementRule()) {
            return [this.visitAddElementRule(ctx.addElementRule())];
        }
        else if (ctx.sdRule()) {
            return this.visitSdRule(ctx.sdRule());
        }
        FSHLogger_1.logger.warn(`Unsupported rule: ${ctx.getText()}`, {
            file: this.currentFile,
            location: this.extractStartStop(ctx)
        });
        return [];
    }
    visitAddElementRule(ctx) {
        const path = this.getPathWithContext(this.visitPath(ctx.path()), ctx);
        const addElementRule = new rules_1.AddElementRule(path)
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        const card = this.parseCard(ctx.CARD().getText(), addElementRule);
        if (card.min == null || Number.isNaN(card.min)) {
            FSHLogger_1.logger.error(`The 'min' cardinality attribute in AddElementRule for path '${path}' must be specified.`, {
                file: this.currentFile,
                location: this.extractStartStop(ctx)
            });
        }
        if (isEmpty_1.default(card.max)) {
            FSHLogger_1.logger.error(`The 'max' cardinality attribute in AddElementRule for path '${path}' must be specified.`, {
                file: this.currentFile,
                location: this.extractStartStop(ctx)
            });
        }
        addElementRule.min = card.min;
        addElementRule.max = card.max;
        if (ctx.flag() && ctx.flag().length > 0) {
            this.parseFlags(addElementRule, ctx.flag());
        }
        addElementRule.types = this.parseTargetType(ctx);
        addElementRule.types.forEach(onlyRuleType => {
            if (FLAGS.includes(onlyRuleType.type)) {
                FSHLogger_1.logger.warn(`The targetType '${onlyRuleType.type}' appears to be a flag value rather than a valid target data type.`, {
                    file: this.currentFile,
                    location: this.extractStartStop(ctx)
                });
            }
        });
        if (isEmpty_1.default(ctx.STRING())) {
            FSHLogger_1.logger.error(`The 'short' attribute in AddElementRule for path '${path}' must be specified.`, {
                file: this.currentFile,
                location: this.extractStartStop(ctx)
            });
        }
        else {
            addElementRule.short = this.extractString(ctx.STRING()[0]);
            if (isEmpty_1.default(ctx.STRING()[1]) && isEmpty_1.default(ctx.MULTILINE_STRING())) {
                // Default definition to the value of short
                addElementRule.definition = addElementRule.short;
            }
            else if (!isEmpty_1.default(ctx.STRING()[1])) {
                addElementRule.definition = this.extractString(ctx.STRING()[1]);
            }
            else {
                addElementRule.definition = this.extractMultilineString(ctx.MULTILINE_STRING());
            }
        }
        return addElementRule;
    }
    visitSdRule(ctx) {
        if (ctx.cardRule()) {
            return this.visitCardRule(ctx.cardRule());
        }
        else if (ctx.flagRule()) {
            return this.visitFlagRule(ctx.flagRule());
        }
        else if (ctx.valueSetRule()) {
            return [this.visitValueSetRule(ctx.valueSetRule())];
        }
        else if (ctx.fixedValueRule()) {
            const rule = this.visitFixedValueRule(ctx.fixedValueRule());
            return [rule];
        }
        else if (ctx.onlyRule()) {
            return [this.visitOnlyRule(ctx.onlyRule())];
        }
        else if (ctx.containsRule()) {
            return this.visitContainsRule(ctx.containsRule());
        }
        else if (ctx.caretValueRule()) {
            return [this.visitCaretValueRule(ctx.caretValueRule())];
        }
        else if (ctx.obeysRule()) {
            return this.visitObeysRule(ctx.obeysRule());
        }
        else if (ctx.insertRule()) {
            const rule = this.visitInsertRule(ctx.insertRule());
            return rule ? [rule] : [];
        }
        else if (ctx.pathRule()) {
            this.visitPathRule(ctx.pathRule());
            return [];
        }
        FSHLogger_1.logger.warn(`Unsupported rule: ${ctx.getText()}`, {
            file: this.currentFile,
            location: this.extractStartStop(ctx)
        });
        return [];
    }
    visitInstanceRule(ctx) {
        if (ctx.fixedValueRule()) {
            return this.visitFixedValueRule(ctx.fixedValueRule());
        }
        else if (ctx.insertRule()) {
            return this.visitInsertRule(ctx.insertRule());
        }
        else if (ctx.pathRule()) {
            this.visitPathRule(ctx.pathRule());
            return;
        }
    }
    visitVsRule(ctx) {
        if (ctx.vsComponent()) {
            return this.visitVsComponent(ctx.vsComponent());
        }
        if (ctx.caretValueRule()) {
            const rule = this.visitCaretValueRule(ctx.caretValueRule());
            if (rule.path) {
                FSHLogger_1.logger.error('Caret rule on ValueSet cannot contain path before ^, skipping rule.', rule.sourceInfo);
            }
            else {
                return this.visitCaretValueRule(ctx.caretValueRule());
            }
        }
        else if (ctx.insertRule()) {
            return this.visitInsertRule(ctx.insertRule());
        }
    }
    visitCsRule(ctx) {
        if (ctx.concept()) {
            return this.visitConcept(ctx.concept());
        }
        else if (ctx.codeCaretValueRule()) {
            return this.visitCodeCaretValueRule(ctx.codeCaretValueRule());
        }
        else if (ctx.codeInsertRule()) {
            return this.visitCodeInsertRule(ctx.codeInsertRule());
        }
    }
    visitMappingEntityRule(ctx) {
        if (ctx.mappingRule()) {
            return this.visitMappingRule(ctx.mappingRule());
        }
        else if (ctx.insertRule()) {
            return this.visitInsertRule(ctx.insertRule());
        }
        else if (ctx.pathRule()) {
            // A path rule may swallow a mapping rule that has no spaces, so catch that case here
            if (this.visitPath(ctx.pathRule().path()).includes('->')) {
                FSHLogger_1.logger.error("Mapping rules must include at least one space both before and after the '->' operator", {
                    location: this.extractStartStop(ctx.pathRule()),
                    file: this.currentFile
                });
            }
            this.visitPathRule(ctx.pathRule());
            return;
        }
    }
    getPathWithContext(path, parentCtx) {
        const splitPath = path === '.' ? [path] : common_1.splitOnPathPeriods(path).filter(p => p);
        return this.getArrayPathWithContext(splitPath, parentCtx).join('.');
    }
    getArrayPathWithContext(pathArray, parentCtx) {
        return this.prependPathContext(pathArray, parentCtx);
    }
    visitPath(ctx) {
        if (ctx === null || ctx === void 0 ? void 0 : ctx.KW_SYSTEM()) {
            return ctx.KW_SYSTEM().getText();
        }
        return (ctx === null || ctx === void 0 ? void 0 : ctx.SEQUENCE().getText()) || '';
    }
    visitCaretPath(ctx) {
        return ctx.CARET_SEQUENCE().getText();
    }
    visitCardRule(ctx) {
        const rules = [];
        const cardRule = new rules_1.CardRule(this.getPathWithContext(this.visitPath(ctx.path()), ctx))
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        const card = this.parseCard(ctx.CARD().getText(), cardRule);
        cardRule.min = card.min;
        cardRule.max = card.max;
        rules.push(cardRule);
        if (ctx.flag() && ctx.flag().length > 0) {
            const flagRule = new rules_1.FlagRule(cardRule.path)
                .withLocation(this.extractStartStop(ctx))
                .withFile(this.currentFile);
            this.parseFlags(flagRule, ctx.flag());
            rules.push(flagRule);
        }
        return rules;
    }
    parseCard(card, rule) {
        const parts = card.split('..', 2);
        if (parts[0] === '' && parts[1] === '') {
            FSHLogger_1.logger.error(`Neither side of the cardinality was specified on path "${rule.path}". A min, max, or both need to be specified.`, rule.sourceInfo);
        }
        return {
            min: parseInt(parts[0]),
            max: parts[1]
        };
    }
    visitFlagRule(ctx) {
        return ctx.path().map(path => {
            const flagRule = new rules_1.FlagRule(this.getPathWithContext(this.visitPath(path), ctx))
                .withLocation(this.extractStartStop(ctx))
                .withFile(this.currentFile);
            this.parseFlags(flagRule, ctx.flag());
            return flagRule;
        });
    }
    parseFlags(flagRule, flagContext) {
        const flags = flagContext.map(f => this.visitFlag(f));
        if (flags.includes(Flag.MustSupport)) {
            flagRule.mustSupport = true;
        }
        if (flags.includes(Flag.Summary)) {
            flagRule.summary = true;
        }
        if (flags.includes(Flag.Modifier)) {
            flagRule.modifier = true;
        }
        if (flags.includes(Flag.TrialUse)) {
            flagRule.trialUse = true;
        }
        if (flags.includes(Flag.Normative)) {
            flagRule.normative = true;
        }
        if (flags.includes(Flag.Draft)) {
            flagRule.draft = true;
        }
    }
    visitFlag(ctx) {
        if (ctx.KW_MS()) {
            return Flag.MustSupport;
        }
        else if (ctx.KW_SU()) {
            return Flag.Summary;
        }
        else if (ctx.KW_MOD()) {
            return Flag.Modifier;
        }
        else if (ctx.KW_TU()) {
            return Flag.TrialUse;
        }
        else if (ctx.KW_NORMATIVE()) {
            return Flag.Normative;
        }
        else if (ctx.KW_DRAFT()) {
            return Flag.Draft;
        }
        return Flag.Unknown;
    }
    visitValueSetRule(ctx) {
        const vsRule = new rules_1.BindingRule(this.getPathWithContext(this.visitPath(ctx.path()), ctx))
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        vsRule.valueSet = this.aliasAwareValue(ctx.name());
        vsRule.strength = ctx.strength() ? this.visitStrength(ctx.strength()) : 'required';
        return vsRule;
    }
    visitStrength(ctx) {
        if (ctx.KW_EXAMPLE()) {
            return 'example';
        }
        else if (ctx.KW_PREFERRED()) {
            return 'preferred';
        }
        else if (ctx.KW_EXTENSIBLE()) {
            return 'extensible';
        }
        return 'required';
    }
    visitFixedValueRule(ctx) {
        const assignmentRule = new rules_1.AssignmentRule(this.getPathWithContext(this.visitPath(ctx.path()), ctx))
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        assignmentRule.value = this.visitValue(ctx.value());
        assignmentRule.exactly = ctx.KW_EXACTLY() != null;
        assignmentRule.isInstance =
            ctx.value().name() != null && !this.allAliases.has(ctx.value().name().getText());
        return assignmentRule;
    }
    visitValue(ctx) {
        // In cases where the parser encounters an error, ctx might be null
        if (ctx == null) {
            return;
        }
        if (ctx.name()) {
            return this.aliasAwareValue(ctx, ctx.name().getText());
        }
        if (ctx.STRING()) {
            return this.extractString(ctx.STRING());
        }
        if (ctx.MULTILINE_STRING()) {
            return this.extractMultilineString(ctx.MULTILINE_STRING());
        }
        if (ctx.NUMBER()) {
            const numberString = ctx.NUMBER().getText();
            // If the number is an integer, store it as a bigint, a FHIR integer64 may be larger
            // than an integer we can safely store as a number
            return /^[-]?\d+$/.test(numberString) ? BigInt(numberString) : parseFloat(numberString);
        }
        if (ctx.DATETIME()) {
            // for now, treat datetime like a string
            return ctx.DATETIME().getText();
        }
        if (ctx.TIME()) {
            // for now, treat datetime like a string
            return ctx.TIME().getText();
        }
        if (ctx.reference()) {
            return this.visitReference(ctx.reference());
        }
        if (ctx.canonical()) {
            const canonicals = this.visitCanonical(ctx.canonical());
            if (canonicals.length > 1) {
                FSHLogger_1.logger.error('Multiple choices of canonicals are not allowed when setting a value. Only the first choice will be used.', {
                    file: this.currentFile,
                    location: this.extractStartStop(ctx.canonical())
                });
            }
            return canonicals[0];
        }
        if (ctx.code()) {
            return this.visitCode(ctx.code());
        }
        if (ctx.quantity()) {
            return this.visitQuantity(ctx.quantity());
        }
        if (ctx.ratio()) {
            return this.visitRatio(ctx.ratio());
        }
        if (ctx.bool()) {
            return this.visitBool(ctx.bool());
        }
    }
    visitCode(ctx) {
        const concept = this.parseCodeLexeme(ctx.CODE().getText(), ctx.CODE())
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        if (ctx.STRING()) {
            concept.display = this.extractString(ctx.STRING());
        }
        return concept;
    }
    visitConcept(ctx) {
        const localCodePath = ctx
            .CODE()
            .map(codeCtx => this.parseCodeLexeme(codeCtx.getText(), codeCtx));
        // the last code in allCodes is the one we are actually defining.
        // the rest are the hierarchy, which may be empty.
        // indentation may also be used to define the hierarchy, which is what the code path with context is for.
        const fullCodePath = this.getArrayPathWithContext(localCodePath.map(localCode => localCode.code), ctx);
        const codePart = localCodePath.slice(-1)[0];
        const availableStrings = ctx.STRING().map(strCtx => this.extractString(strCtx));
        const concept = new rules_1.ConceptRule(codePart.code)
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        concept.hierarchy = fullCodePath.slice(0, -1);
        if (availableStrings.length > 0) {
            concept.display = availableStrings[0];
        }
        if (availableStrings.length > 1) {
            concept.definition = availableStrings[1];
        }
        else if (ctx.MULTILINE_STRING()) {
            concept.definition = this.extractMultilineString(ctx.MULTILINE_STRING());
        }
        if (localCodePath.some(listedConcept => listedConcept.system)) {
            // If this concept is part of a RuleSet and has a system, no definition, and no hierarchy,
            // it might actually represent a ValueSetConceptComponent. We can't know for sure until the RuleSet
            // is inserted somewhere. For now, assume it will be okay, so keep the system for later.
            if (ctx.parentCtx instanceof FSHParser_1.FSHParser.RuleSetRuleContext &&
                codePart.system &&
                !concept.definition &&
                concept.hierarchy.length === 0) {
                concept.system = codePart.system;
            }
            else {
                FSHLogger_1.logger.error('Do not include the system when listing concepts for a code system.', concept.sourceInfo);
            }
        }
        return concept;
    }
    visitQuantity(ctx) {
        const value = parseFloat(ctx.NUMBER().getText());
        let delimitedUnit = ctx.UNIT() ? ctx.UNIT().getText() : ''; // e.g., 'mm'
        // We'll want to assume the UCUM code system unless another system is specified
        let unitSystem = 'http://unitsofmeasure.org';
        // If there's no unit string, then we're using FSHCode syntax
        if (!delimitedUnit) {
            const unitCode = this.parseCodeLexeme(ctx.CODE().getText(), ctx.CODE())
                .withLocation(this.extractStartStop(ctx))
                .withFile(this.currentFile);
            unitSystem = unitCode.system;
            delimitedUnit = unitCode.code;
        }
        else {
            delimitedUnit = delimitedUnit.slice(1, -1);
        }
        let displayUnit;
        if (ctx.STRING()) {
            displayUnit = this.extractString(ctx.STRING());
        }
        const unit = new fshtypes_1.FshCode(delimitedUnit, unitSystem, displayUnit)
            .withLocation(this.extractStartStop(ctx.UNIT() ? ctx.UNIT() : ctx))
            .withFile(this.currentFile);
        const quantity = new fshtypes_1.FshQuantity(value, unit)
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        return quantity;
    }
    visitRatio(ctx) {
        const ratio = new fshtypes_1.FshRatio(this.visitRatioPart(ctx.ratioPart()[0]), this.visitRatioPart(ctx.ratioPart()[1]))
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        return ratio;
    }
    visitRatioPart(ctx) {
        if (ctx.NUMBER()) {
            const quantity = new fshtypes_1.FshQuantity(parseFloat(ctx.NUMBER().getText()))
                .withLocation(this.extractStartStop(ctx.NUMBER()))
                .withFile(this.currentFile);
            return quantity;
        }
        return this.visitQuantity(ctx.quantity());
    }
    // This function is called when fixing a value, and a value can only be set
    // to a specific reference, not a choice of references.
    visitReference(ctx) {
        const parsedReferences = this.parseOrReference(ctx.REFERENCE().getText());
        const ref = new fshtypes_1.FshReference(this.aliasAwareValue(ctx.REFERENCE(), parsedReferences[0]));
        if (parsedReferences.length > 1) {
            FSHLogger_1.logger.error('Multiple choices of references are not allowed when setting a value. Only the first choice will be used.', {
                file: this.currentFile,
                location: this.extractStartStop(ctx)
            });
        }
        ref.withLocation(this.extractStartStop(ctx)).withFile(this.currentFile);
        if (ctx.STRING()) {
            ref.display = this.extractString(ctx.STRING());
        }
        return ref;
    }
    parseOrReference(reference) {
        return reference
            .slice(reference.indexOf('(') + 1, reference.length - 1)
            .split(/\s+or\s+/)
            .map(r => r.trim());
    }
    visitCanonical(ctx) {
        const canonicalText = ctx.CANONICAL().getText();
        const choices = canonicalText
            .slice(canonicalText.indexOf('(') + 1, canonicalText.length - 1)
            .split(/\s+or\s+/)
            .map(r => r.trim());
        return choices.map(c => {
            const [item, version] = c.split(/\s*\|\s*(.+)/).map(str => str.trim());
            const fshCanonical = new fshtypes_1.FshCanonical(item)
                .withLocation(this.extractStartStop(ctx))
                .withFile(this.currentFile);
            if (version) {
                fshCanonical.version = version;
            }
            return fshCanonical;
        });
    }
    visitBool(ctx) {
        return ctx.KW_TRUE() != null;
    }
    visitOnlyRule(ctx) {
        const onlyRule = new rules_1.OnlyRule(this.getPathWithContext(this.visitPath(ctx.path()), ctx))
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        onlyRule.types = this.parseTargetType(ctx);
        return onlyRule;
    }
    parseTargetType(ctx) {
        const orTypes = [];
        ctx.targetType().forEach(t => {
            if (t.referenceType()) {
                const referenceToken = t.referenceType().REFERENCE();
                const references = this.parseOrReference(referenceToken.getText());
                references.forEach(r => orTypes.push({
                    type: this.aliasAwareValue(referenceToken, r),
                    isReference: true
                }));
            }
            else if (t.canonical()) {
                const canonicals = this.visitCanonical(t.canonical());
                canonicals.forEach(c => orTypes.push({
                    type: `${this.aliasAwareValue(t.canonical(), c.entityName)}${c.version ? `|${c.version}` : ''}`,
                    isCanonical: true
                }));
            }
            else {
                orTypes.push({ type: this.aliasAwareValue(t.name()) });
            }
        });
        return orTypes;
    }
    visitContainsRule(ctx) {
        const rules = [];
        const containsRule = new rules_1.ContainsRule(this.getPathWithContext(this.visitPath(ctx.path()), ctx))
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        rules.push(containsRule);
        ctx.item().forEach(i => {
            let item;
            if (i.KW_NAMED()) {
                item = {
                    type: this.aliasAwareValue(i.name()[0], i.name()[0].getText()),
                    name: i.name()[1].getText()
                };
            }
            else {
                item = {
                    name: i.name()[0].getText()
                };
            }
            containsRule.items.push(item);
            const cardRule = new rules_1.CardRule(`${containsRule.path}[${item.name}]`)
                .withLocation(this.extractStartStop(ctx))
                .withFile(this.currentFile);
            const card = this.parseCard(i.CARD().getText(), cardRule);
            cardRule.min = card.min;
            cardRule.max = card.max;
            rules.push(cardRule);
            if (i.flag() && i.flag().length > 0) {
                const flagRule = new rules_1.FlagRule(`${containsRule.path}[${item.name}]`)
                    .withLocation(this.extractStartStop(ctx))
                    .withFile(this.currentFile);
                this.parseFlags(flagRule, i.flag());
                rules.push(flagRule);
            }
        });
        return rules;
    }
    visitCaretValueRule(ctx) {
        var _a;
        const path = this.visitPath(ctx.path());
        const splitPath = path === '.' ? [path] : common_1.splitOnPathPeriods(this.visitPath(ctx.path())).filter(p => p);
        const pathArray = this.getArrayPathWithContext(splitPath, ctx);
        const caretValueRule = new rules_1.CaretValueRule(pathArray.join('.'))
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        // We must save the path in array form, in case this rule is a part
        // of a RuleSet which ends up applied on a CodeSystem
        caretValueRule.pathArray = pathArray;
        // Get the caret path, but slice off the starting ^
        caretValueRule.caretPath = this.visitCaretPath(ctx.caretPath()).slice(1);
        caretValueRule.value = this.visitValue(ctx.value());
        caretValueRule.isInstance =
            ((_a = ctx.value()) === null || _a === void 0 ? void 0 : _a.name()) != null && !this.allAliases.has(ctx.value().name().getText());
        return caretValueRule;
    }
    visitCodeCaretValueRule(ctx) {
        var _a;
        const localCodePath = ctx.CODE()
            ? ctx.CODE().map(code => {
                return this.parseCodeLexeme(code.getText(), ctx).code;
            })
            : [];
        const fullCodePath = this.getArrayPathWithContext(localCodePath, ctx);
        // It's fine to make a CodeCaretValueRule with an empty code path.
        const caretRule = new rules_1.CaretValueRule('')
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        caretRule.pathArray = fullCodePath;
        // Get the caret path, but slice off the starting ^
        caretRule.caretPath = this.visitCaretPath(ctx.caretPath()).slice(1);
        caretRule.value = this.visitValue(ctx.value());
        caretRule.isInstance =
            ((_a = ctx.value()) === null || _a === void 0 ? void 0 : _a.name()) != null && !this.allAliases.has(ctx.value().name().getText());
        return caretRule;
    }
    visitObeysRule(ctx) {
        const rules = [];
        const path = this.getPathWithContext(this.visitPath(ctx.path()), ctx);
        ctx.name().forEach(invariant => {
            const obeysRule = new rules_1.ObeysRule(path)
                .withLocation(this.extractStartStop(ctx))
                .withFile(this.currentFile);
            obeysRule.invariant = invariant.getText();
            rules.push(obeysRule);
        });
        return rules;
    }
    visitPathRule(ctx) {
        this.getPathWithContext(this.visitPath(ctx.path()), ctx);
    }
    visitCodeInsertRule(ctx) {
        const insertRule = new rules_1.InsertRule('')
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        const localCodePath = ctx.CODE().map(code => {
            return this.parseCodeLexeme(code.getText(), ctx).code;
        });
        const fullCodePath = this.getArrayPathWithContext(localCodePath, ctx);
        insertRule.pathArray = fullCodePath;
        return this.applyRuleSetParams(ctx, insertRule);
    }
    visitInsertRule(ctx) {
        const insertRule = new rules_1.InsertRule(this.getPathWithContext(this.visitPath(ctx.path()), ctx))
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        return this.applyRuleSetParams(ctx, insertRule);
    }
    parseRulesetReference(reference) {
        const paramListStart = reference.indexOf('(');
        if (paramListStart === -1) {
            return [reference.trim(), null];
        }
        else {
            return [reference.slice(0, paramListStart).trim(), reference.slice(paramListStart)];
        }
    }
    parseInsertRuleParams(ruleText) {
        // first, trim parentheses
        const ruleNoParens = ruleText.slice(1, ruleText.length - 1);
        // since backslash is the escape character, deal with literal backslash first
        const splitBackslash = ruleNoParens.split(/\\\\/g);
        // then, split the parameters apart with unescaped commas
        const splitComma = splitBackslash.map(substrBackslash => {
            // This workaround is to avoid using the more elegant regex lookbehind when we split (substrBackslash.split(/(?<!\\),/g))
            let subStringToCombine = '';
            return substrBackslash
                .split(/,/g)
                .map(substrComma => {
                // If we had a previous substring that ended in an escape character, combine with current substring
                if (subStringToCombine) {
                    substrComma = `${subStringToCombine},${substrComma}`;
                    subStringToCombine = '';
                }
                // If the current substring ends with an escape character, we should be escaping the comma that this was split on
                // Keep track of this substring to be combined with the next one
                if (substrComma.endsWith('\\')) {
                    subStringToCombine = substrComma;
                    return null;
                }
                // then, make all the replacements: closing parenthesis and comma
                return substrComma.replace(/\\\)/g, ')').replace(/\\,/g, ',');
            })
                .filter(s => s != null); // Filter out any null values from incorrectly split escaped commas
        });
        const paramList = [];
        // if splitComma has more than one list, that means we split on literal backslash
        // so to rejoin all the strings, the last string joins the first string in the next sublist
        splitComma.forEach((list, index) => {
            list.forEach((paramPart, subIndex) => {
                if (index > 0 && subIndex === 0) {
                    // join with \\ on the last param
                    paramList.push(`${paramList.pop()}\\\\${paramPart}`);
                }
                else {
                    // push a new param
                    paramList.push(paramPart);
                }
            });
        });
        // trim whitespace from each parameter, since it may be formatted for readability
        return paramList.map(param => param.trim());
    }
    applyRuleSetParams(ctx, insertRule) {
        var _a, _b, _c, _d;
        const [rulesetName, ruleParams] = this.parseRulesetReference((_d = (_b = (_a = ctx.RULESET_REFERENCE()) === null || _a === void 0 ? void 0 : _a.getText()) !== null && _b !== void 0 ? _b : (_c = ctx.PARAM_RULESET_REFERENCE()) === null || _c === void 0 ? void 0 : _c.getText()) !== null && _d !== void 0 ? _d : '');
        insertRule.ruleSet = rulesetName;
        if (ruleParams) {
            insertRule.params = this.parseInsertRuleParams(ruleParams);
            const ruleSet = this.paramRuleSets.get(insertRule.ruleSet);
            if (ruleSet) {
                const ruleSetIdentifier = JSON.stringify([ruleSet.name, ...insertRule.params]);
                if (ruleSet.parameters.length === insertRule.params.length) {
                    // no need to create the appliedRuleSet again if we already have it
                    if (!this.currentDoc.appliedRuleSets.has(ruleSetIdentifier)) {
                        // create a new document with the substituted parameters
                        const appliedFsh = `RuleSet: ${ruleSet.name}${os_1.EOL}${ruleSet.applyParameters(insertRule.params)}${os_1.EOL}`;
                        const appliedRuleSet = this.parseGeneratedRuleSet(appliedFsh, ruleSet.name, insertRule);
                        if (appliedRuleSet) {
                            // set the source info based on the original source info
                            appliedRuleSet.sourceInfo.file = ruleSet.sourceInfo.file;
                            appliedRuleSet.sourceInfo.location = Object.assign({}, ruleSet.sourceInfo.location);
                            appliedRuleSet.rules.forEach(rule => {
                                rule.sourceInfo.file = appliedRuleSet.sourceInfo.file;
                                rule.sourceInfo.location.startLine +=
                                    appliedRuleSet.sourceInfo.location.startLine - 1;
                                rule.sourceInfo.location.endLine +=
                                    appliedRuleSet.sourceInfo.location.startLine - 1;
                            });
                            this.currentDoc.appliedRuleSets.set(ruleSetIdentifier, appliedRuleSet);
                        }
                        else {
                            FSHLogger_1.logger.error(`Failed to parse RuleSet ${insertRule.ruleSet} with provided parameters (${insertRule.params.join(', ')})`, insertRule.sourceInfo);
                            return;
                        }
                    }
                }
                else {
                    FSHLogger_1.logger.error(`Incorrect number of parameters applied to RuleSet ${insertRule.ruleSet}`, insertRule.sourceInfo);
                    return;
                }
            }
            else {
                FSHLogger_1.logger.error(`Could not find parameterized RuleSet named ${insertRule.ruleSet}`, insertRule.sourceInfo);
                return;
            }
        }
        return insertRule;
    }
    parseGeneratedRuleSet(input, name, insertRule) {
        // define a temporary document that will contain this RuleSet
        const tempDocument = new FSHDocument_1.FSHDocument(this.currentFile);
        // save the currentDoc so it can be restored after parsing this RuleSet
        const parentDocument = this.currentDoc;
        const parentContext = this.pathContext;
        this.currentDoc = tempDocument;
        // errors should be collected, not printed, when parsing generated documents
        // we should only retrieve errors if we are currently in the top-level parse
        let topLevelInfo;
        if (this.topLevelParse) {
            this.topLevelParse = false;
            topLevelInfo = FSHLogger_1.switchToSecretLogger();
        }
        try {
            const subContext = this.parseDoc(input);
            this.visitDoc(subContext);
        }
        finally {
            // be sure to restore parentDocument
            this.currentDoc = parentDocument;
            this.pathContext = parentContext;
        }
        // if tempDocument has appliedRuleSets, merge them in
        tempDocument.appliedRuleSets.forEach((ruleSet, identifier) => this.currentDoc.appliedRuleSets.set(identifier, ruleSet));
        if (topLevelInfo) {
            // exit logger collection mode, write collected errors and warnings
            const collectedMessages = FSHLogger_1.restoreMainLogger(topLevelInfo);
            this.topLevelParse = true;
            if (collectedMessages.errors.length > 0) {
                FSHLogger_1.logger.error([
                    `Error${collectedMessages.errors.length > 1 ? 's' : ''} parsing insert rule with parameterized RuleSet ${name}`,
                    ...collectedMessages.errors.map(log => `- ${log.message}`)
                ].join(os_1.EOL), insertRule.sourceInfo);
            }
            if (collectedMessages.warnings.length > 0) {
                FSHLogger_1.logger.warn([
                    `Warning${collectedMessages.warnings.length > 1 ? 's' : ''} parsing insert rule with parameterized RuleSet ${name}`,
                    ...collectedMessages.warnings.map(log => `- ${log.message}`)
                ].join(os_1.EOL), insertRule.sourceInfo);
            }
        }
        // if the RuleSet parsed successfully, it will be on the document, and we should return it.
        return tempDocument.ruleSets.get(name);
    }
    visitMappingRule(ctx) {
        var _a;
        const mappingRule = new rules_1.MappingRule(this.getPathWithContext(this.visitPath(ctx.path()), ctx))
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        mappingRule.map = this.extractString(ctx.STRING()[0]);
        if (ctx.STRING().length > 1) {
            mappingRule.comment = this.extractString(ctx.STRING()[1]);
        }
        if (ctx.CODE()) {
            mappingRule.language = this.parseCodeLexeme(ctx.CODE().getText(), ctx.CODE())
                .withLocation(this.extractStartStop(ctx.CODE()))
                .withFile(this.currentFile);
            if (((_a = mappingRule.language.system) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                FSHLogger_1.logger.warn('Do not specify a system for mapping language.', mappingRule.language.sourceInfo);
            }
        }
        return mappingRule;
    }
    visitVsComponent(ctx) {
        const inclusion = ctx.KW_EXCLUDE() == null;
        let vsComponent;
        if (ctx.vsConceptComponent()) {
            vsComponent = new rules_1.ValueSetConceptComponentRule(inclusion)
                .withLocation(this.extractStartStop(ctx))
                .withFile(this.currentFile);
            [vsComponent.concepts, vsComponent.from] = this.visitVsConceptComponent(ctx.vsConceptComponent());
        }
        else if (ctx.vsFilterComponent()) {
            vsComponent = new rules_1.ValueSetFilterComponentRule(inclusion)
                .withLocation(this.extractStartStop(ctx))
                .withFile(this.currentFile);
            [vsComponent.filters, vsComponent.from] = this.visitVsFilterComponent(ctx.vsFilterComponent());
        }
        return vsComponent;
    }
    visitVsConceptComponent(ctx) {
        const concepts = [];
        const from = ctx.vsComponentFrom()
            ? this.visitVsComponentFrom(ctx.vsComponentFrom())
            : {};
        if (ctx.code().length === 1) {
            const singleCode = this.visitCode(ctx.code()[0]);
            if (singleCode.system && from.system) {
                FSHLogger_1.logger.error(`Concept ${singleCode.code} specifies system multiple times`, {
                    file: this.currentFile,
                    location: this.extractStartStop(ctx)
                });
            }
            else if (singleCode.system) {
                from.system = singleCode.system;
                concepts.push(singleCode);
            }
            else if (from.system) {
                singleCode.system = from.system;
                concepts.push(singleCode);
            }
            else {
                FSHLogger_1.logger.error(`Concept ${singleCode.code} must include system as "SYSTEM#CONCEPT" or "#CONCEPT from system SYSTEM"`, {
                    file: this.currentFile,
                    location: this.extractStartStop(ctx)
                });
            }
        }
        else if (ctx.code().length > 1) {
            if (from.system) {
                ctx.code().forEach(code => {
                    const newCode = this.visitCode(code);
                    newCode.system = from.system;
                    concepts.push(newCode);
                });
            }
            else {
                FSHLogger_1.logger.error('System is required when listing concepts in a value set component', {
                    file: this.currentFile,
                    location: this.extractStartStop(ctx)
                });
            }
        }
        return [concepts, from];
    }
    visitVsFilterComponent(ctx) {
        const filters = [];
        const from = ctx.vsComponentFrom()
            ? this.visitVsComponentFrom(ctx.vsComponentFrom())
            : {};
        if (ctx.vsFilterList()) {
            if (from.system) {
                ctx
                    .vsFilterList()
                    .vsFilterDefinition()
                    .forEach(filterDefinition => {
                    try {
                        filters.push(this.visitVsFilterDefinition(filterDefinition));
                    }
                    catch (e) {
                        FSHLogger_1.logger.error(e, {
                            location: this.extractStartStop(filterDefinition),
                            file: this.currentFile
                        });
                    }
                });
            }
            else {
                FSHLogger_1.logger.error('System is required when filtering a value set component', {
                    file: this.currentFile,
                    location: this.extractStartStop(ctx)
                });
            }
        }
        return [filters, from];
    }
    visitVsComponentFrom(ctx) {
        const from = {};
        if (ctx.vsFromSystem()) {
            from.system = this.aliasAwareValue(ctx.vsFromSystem().name());
        }
        if (ctx.vsFromValueset()) {
            if (ctx.vsFromValueset().name().length > 0) {
                from.valueSets = ctx
                    .vsFromValueset()
                    .name()
                    .map(name => this.aliasAwareValue(name));
            }
        }
        return from;
    }
    /**
     * The replace makes FSH permissive in regards to the official specifications,
     * which spells operator "descendant-of" as "descendent-of".
     * @see {@link http://hl7.org/fhir/valueset-filter-operator.html}
     */
    visitVsFilterDefinition(ctx) {
        const property = ctx.name().getText();
        const operator = ctx
            .vsFilterOperator()
            .getText()
            .toLocaleLowerCase()
            .replace('descendant', 'descendent');
        if (ctx.vsFilterValue() == null && operator !== fshtypes_1.VsOperator.EXISTS) {
            throw new errors_1.ValueSetFilterMissingValueError(operator);
        }
        const value = ctx.vsFilterValue() ? this.visitVsFilterValue(ctx.vsFilterValue()) : true;
        // NOTE: We support string value for every operator, in addition to the specific typed values
        // for some operators based on the filter value documentation:
        // http://hl7.org/fhir/R4/valueset-definitions.html#ValueSet.compose.include.filter.value
        // and the discussion on https://github.com/FHIR/sushi/issues/936
        switch (operator) {
            case fshtypes_1.VsOperator.EQUALS:
            case fshtypes_1.VsOperator.IN:
            case fshtypes_1.VsOperator.NOT_IN:
            case fshtypes_1.VsOperator.IS_A:
            case fshtypes_1.VsOperator.DESCENDENT_OF:
            case fshtypes_1.VsOperator.IS_NOT_A:
            case fshtypes_1.VsOperator.GENERALIZES:
                if (!(value instanceof fshtypes_1.FshCode) && typeof value !== 'string') {
                    throw new errors_1.ValueSetFilterValueTypeError(operator, ['code', 'string']);
                }
                break;
            case fshtypes_1.VsOperator.REGEX:
                if (!(value instanceof RegExp) && typeof value !== 'string') {
                    throw new errors_1.ValueSetFilterValueTypeError(operator, ['regex', 'string']);
                }
                break;
            case fshtypes_1.VsOperator.EXISTS:
                const allowedStrings = ['true', 'false'];
                if (typeof value !== 'boolean' &&
                    !(typeof value === 'string' && allowedStrings.includes(value))) {
                    throw new errors_1.ValueSetFilterValueTypeError(operator, ['boolean'], allowedStrings);
                }
                break;
            default:
                throw new errors_1.ValueSetFilterOperatorError(ctx.vsFilterOperator().getText());
        }
        return {
            property: property,
            operator: operator,
            value: value
        };
    }
    visitVsFilterValue(ctx) {
        if (ctx.code()) {
            return this.visitCode(ctx.code());
        }
        else if (ctx.REGEX()) {
            return RegExp(ctx.REGEX().getText().slice(1, -1));
        }
        else if (ctx.STRING()) {
            return this.extractString(ctx.STRING());
        }
        else if (ctx.KW_TRUE()) {
            return true;
        }
        else if (ctx.KW_FALSE()) {
            return false;
        }
    }
    validateAliasResolves(parentCtx, value = parentCtx.getText()) {
        const hasAlias = this.allAliases.has(value);
        if (!hasAlias && value.startsWith('$')) {
            FSHLogger_1.logger.error(`Value ${value} does not resolve as alias, values beginning with "$" must resolve`, { location: this.extractStartStop(parentCtx), file: this.currentFile });
        }
    }
    aliasAwareValue(parentCtx, value = parentCtx.getText()) {
        const [valueWithoutVersion, version] = value.split('|');
        this.validateAliasResolves(parentCtx, valueWithoutVersion);
        if (this.allAliases.has(valueWithoutVersion)) {
            return this.allAliases.get(valueWithoutVersion) + (version ? `|${version}` : '');
        }
        else {
            return value;
        }
    }
    /**
     * Given a path and the context containing it, apply the path context indicated by the path's indent
     * @param path - The path to apply context to
     * @param parentCtx - The parent element containing the path
     * @returns {string[]} - The path with context prepended
     */
    prependPathContext(path, parentCtx) {
        const location = this.extractStartStop(parentCtx);
        const currentIndent = location.startColumn - DEFAULT_START_COLUMN;
        const contextIndex = currentIndent / INDENT_WIDTH;
        if (!this.isValidContext(location, currentIndent, this.pathContext)) {
            return path;
        }
        // If the element is not indented, just reset the context
        if (contextIndex === 0) {
            this.pathContext = [path];
            return path;
        }
        if (path.length === 1 && path[0] === '.') {
            FSHLogger_1.logger.error("The special '.' path is only allowed in top-level rules. The rule will be processed as if it is not indented.", {
                location,
                file: this.currentFile
            });
            return path;
        }
        // Otherwise, get the context based on the indent level.
        const currentContext = this.pathContext[contextIndex - 1];
        if (currentContext.length === 0) {
            FSHLogger_1.logger.error('Rule cannot be indented below rule which has no path. The rule will be processed as if it is not indented.', { location, file: this.currentFile });
            return path;
        }
        // Trim out-of-scope contexts
        this.pathContext.splice(contextIndex);
        // Once we have used the existing context, clear it of any [+] so that a rule that is only setting path only applies [+] once
        if (this.pathContext.length > 0) {
            this.pathContext[this.pathContext.length - 1] = this.pathContext[this.pathContext.length - 1].map(c => c.replace(/\[\+\]/g, '[=]'));
        }
        const fullPath = currentContext.concat(path);
        this.pathContext.push(fullPath);
        return fullPath;
    }
    isValidContext(location, currentIndent, existingContext) {
        if (currentIndent > 0 && existingContext.length === 0) {
            FSHLogger_1.logger.error('The first rule of a definition must be left-aligned. The rule will be processed as if it is not indented.', { location, file: this.currentFile });
            return false;
        }
        if (currentIndent % INDENT_WIDTH !== 0 || currentIndent < 0) {
            FSHLogger_1.logger.error(`Unable to determine path context for rule indented ${currentIndent} space(s). Rules must be indented in multiples of ${INDENT_WIDTH} space(s).`, { location, file: this.currentFile });
            return false;
        }
        // And we require that rules are not indented too deeply
        const contextIndex = currentIndent / INDENT_WIDTH;
        if (contextIndex > existingContext.length) {
            FSHLogger_1.logger.error(`Cannot determine path context of rule since it is indented too deeply. Rules must be indented in increments of ${INDENT_WIDTH} space(s).`, { location, file: this.currentFile });
            return false;
        }
        return true;
    }
    extractString(stringCtx) {
        var _a;
        const str = (_a = stringCtx === null || stringCtx === void 0 ? void 0 : stringCtx.getText()) !== null && _a !== void 0 ? _a : '""'; // default to empty string if stringCtx is null
        const strNoQuotes = str.slice(1, str.length - 1); // Strip surrounding quotes
        // Replace escaped characters
        const splitBackslash = strNoQuotes.split(/\\\\/g);
        const replacedBackslash = splitBackslash.map(substrBackslash => {
            // Replace quote, newline, return, tab characters only if they were not preceded by a backslash to escape the escape character
            return substrBackslash
                .replace(/\\"/g, '"')
                .replace(/\\n/g, '\n')
                .replace(/\\r/g, '\r')
                .replace(/\\t/g, '\t');
        });
        return replacedBackslash.join('\\');
    }
    /**
     * Multiline strings receive special handling:
     * - if the first line contains only whitespace (including newline), toss it
     * - if the last line contains only whitespace (including newline), toss it
     * - if another line contains only whitespace, truncate it
     * - for all other non-whitespace lines, detect the shortest number of leading spaces and always trim that off;
     *   this allows authors to indent a whole block of text, but not have it indented in the output.
     */
    extractMultilineString(mlStringCtx) {
        let mlstr = mlStringCtx.getText();
        // remove leading/trailing """
        mlstr = mlstr.slice(3, -3);
        // split into lines so we can process them to determine what leading spaces to trim
        let lines = mlstr.split(/\r?\n/);
        lines = lines.map(l => (l = l.replace(/\\n/g, '\n').replace(/\\r/g, '\r').replace(/\\t/g, '\t')));
        // if the first line is only whitespace, remove it
        if (lines[0].search(/\S/) === -1) {
            lines.shift();
        }
        // if the last line is only whitespace, remove it
        if (lines.length > 0 && lines[lines.length - 1].search(/\S/) === -1) {
            lines.pop();
        }
        lines = lines.map(l => (/^\s*$/.test(l) ? '' : l));
        // find the minimum number of spaces before the first char (ignore zero-length lines)
        const minSpaces = min_1.default(lines.map(line => {
            const firstNonSpace = line.search(/\S|$/);
            const lineIsEmpty = /^$/.test(line);
            if (!lineIsEmpty) {
                return firstNonSpace;
            }
            else {
                return null;
            }
        }));
        // consistently remove the common leading spaces and join the lines back together
        return lines.map(l => (l.length >= minSpaces ? l.slice(minSpaces) : l)).join('\n');
    }
    extractStartStop(ctx) {
        if (pc.isStarContext(ctx)) {
            const location = {
                startLine: ctx.STAR().symbol.line + 1,
                startColumn: this.getStarContextStartColumn(ctx),
                endLine: ctx.stop.line,
                endColumn: ctx.stop.stop - ctx.stop.start + ctx.stop.column + 1
            };
            if (!(pc.containsPathContext(ctx) || pc.containsCodePathContext(ctx)) &&
                location.startColumn - DEFAULT_START_COLUMN > 0) {
                FSHLogger_1.logger.error('A rule that does not use a path cannot be indented to indicate context. The rule will be processed as if it is not indented.', { location, file: this.currentFile });
            }
            return location;
        }
        else if (ctx instanceof Tree_1.TerminalNode) {
            return {
                startLine: ctx.symbol.line,
                startColumn: ctx.symbol.column + 1,
                endLine: ctx.symbol.line,
                endColumn: ctx.symbol.stop - ctx.symbol.start + ctx.symbol.column + 1
            };
        }
        else {
            return {
                startLine: ctx.start.line,
                startColumn: ctx.start.column + 1,
                endLine: ctx.stop.line,
                endColumn: ctx.stop.stop - ctx.stop.start + ctx.stop.column + 1
            };
        }
    }
    getStarContextStartColumn(ctx) {
        return ctx.STAR().getText().length - ctx.STAR().getText().lastIndexOf('\n') - 2;
    }
    // NOTE: Since the ANTLR parser/lexer is JS (not typescript), we need to use some ts-ignore here.
    parseDoc(input, file) {
        const chars = new antlr4_1.InputStream(input);
        const lexer = new FSHLexer_1.FSHLexer(chars);
        const listener = new FSHErrorListener_1.FSHErrorListener(file);
        // @ts-ignore
        lexer.removeErrorListeners();
        // @ts-ignore
        lexer.addErrorListener(listener);
        // @ts-ignore
        const tokens = new antlr4_1.CommonTokenStream(lexer);
        const parser = new FSHParser_1.FSHParser(tokens);
        // @ts-ignore
        parser.removeErrorListeners();
        // @ts-ignore
        parser.addErrorListener(listener);
        // @ts-ignore
        parser.buildParseTrees = true;
        // @ts-ignore
        return parser.doc();
    }
}
exports.FSHImporter = FSHImporter;
//# sourceMappingURL=FSHImporter.js.map