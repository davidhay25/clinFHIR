"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveSoftIndexing = exports.assembleFSHPath = exports.parseFSHPath = void 0;
const common_1 = require("../fhirtypes/common");
const rules_1 = require("../fshtypes/rules");
const FSHLogger_1 = require("./FSHLogger");
/**
 * Parses a FSH Path into a more easily usable form
 * @param {string} fshPath - A syntactically valid path in FSH
 * @returns {PathPart[]} an array of PathParts that is easier to work with
 */
function parseFSHPath(fshPath) {
    const pathParts = [];
    const seenSlices = [];
    const indexRegex = /^[0-9]+$/;
    const splitPath = fshPath === '.' ? [fshPath] : common_1.splitOnPathPeriods(fshPath);
    for (const pathPart of splitPath) {
        const splitPathPart = pathPart.split('[');
        if (splitPathPart.length === 1 || pathPart.endsWith('[x]')) {
            // There are no brackets, or the brackets are for a choice, so just push on the name
            pathParts.push({ base: pathPart });
        }
        else {
            // We have brackets, let's  save the bracket info
            let fhirPathBase = splitPathPart[0];
            // Get the bracket elements and slice off the trailing ']'
            let brackets = splitPathPart.slice(1).map(s => s.slice(0, -1));
            // Get rid of any remaining [x] elements in the brackets
            if (brackets[0] === 'x') {
                fhirPathBase += '[x]';
                brackets = brackets.slice(1);
            }
            brackets.forEach(bracket => {
                if (!indexRegex.test(bracket) && !(bracket === '+' || bracket === '=')) {
                    seenSlices.push(bracket);
                }
            });
            if (seenSlices.length > 0) {
                pathParts.push({
                    base: fhirPathBase,
                    brackets: brackets,
                    slices: [...seenSlices]
                });
            }
            else {
                pathParts.push({ base: fhirPathBase, brackets: brackets });
            }
        }
    }
    return pathParts;
}
exports.parseFSHPath = parseFSHPath;
/**
 * Assembles a PathPart array back to its original form
 * @param {PathPart[]} pathParts - An array of pathParts
 * @returns {string} path - The path corresponding to those pathParts
 */
function assembleFSHPath(pathParts) {
    let path = '';
    pathParts.forEach((pathPart, i) => {
        var _a;
        path += pathPart.base;
        (_a = pathPart.brackets) === null || _a === void 0 ? void 0 : _a.forEach(bracket => (path += `[${bracket}]`));
        if (i < pathParts.length - 1) {
            path += '.';
        }
    });
    return path;
}
exports.assembleFSHPath = assembleFSHPath;
/**
 *
 * @param {PathPart} element - A single element in a rules path
 * @param {Map<string, number} pathMap - A map containing an element's name as the key and that element's updated index as the value
 */
function convertSoftIndexes(element, pathMap) {
    var _a, _b, _c, _d, _e, _f;
    // Must account for a pathPart's base name, prior portions of the path, as well as any slices it's contained in.
    const mapName = `${(_a = element.prefix) !== null && _a !== void 0 ? _a : ''}.${element.base}|${((_b = element.slices) !== null && _b !== void 0 ? _b : []).join('|')}`;
    const indexRegex = /^[0-9]+$/;
    if (!pathMap.has(mapName)) {
        const existingNumericBracket = (_c = element.brackets) === null || _c === void 0 ? void 0 : _c.find(bracket => indexRegex.test(bracket));
        if (existingNumericBracket) {
            pathMap.set(mapName, parseInt(existingNumericBracket));
        }
        else {
            pathMap.set(mapName, 0);
            if ((_d = element.brackets) === null || _d === void 0 ? void 0 : _d.includes('+')) {
                element.brackets[element.brackets.indexOf('+')] = '0';
            }
            else if ((_e = element.brackets) === null || _e === void 0 ? void 0 : _e.includes('=')) {
                // If a sequence begins with a '=', we log an error but assume a value of 0
                element.brackets[element.brackets.indexOf('=')] = '0';
                throw new Error('The first index in a Soft Indexing sequence must be "+", an actual index of "0" has been assumed');
            }
        }
    }
    else {
        (_f = element.brackets) === null || _f === void 0 ? void 0 : _f.forEach((bracket, index) => {
            if (bracket === '+') {
                const newIndex = pathMap.get(mapName) + 1;
                element.brackets[index] = newIndex.toString();
                pathMap.set(mapName, newIndex);
            }
            else if (bracket === '=') {
                const currentIndex = pathMap.get(mapName);
                element.brackets[index] = currentIndex.toString();
            }
            else if (indexRegex.test(bracket)) {
                // If a numeric index is found, we update our pathMap so subsequent soft indexes are converted in that context
                pathMap.set(mapName, parseInt(bracket));
            }
        });
    }
}
/**
 * Replaces soft indexs in rule paths with corresponding numbers
 * @param {Rule[]} rules - An array of Rules
 */
function resolveSoftIndexing(rules) {
    const pathMap = new Map();
    const caretPathMap = new Map();
    // Parsing and separating rules by base name and bracket indexes
    const parsedRules = rules.map(rule => {
        const parsedPath = {
            path: parseFSHPath(rule.path)
        };
        // If we have a CaretValueRule, we'll need a second round of parsing for the caret path
        if (rule instanceof rules_1.CaretValueRule) {
            parsedPath.caretPath = parseFSHPath(rule.caretPath);
        }
        return parsedPath;
    });
    // Replacing Soft indexes with numbers
    parsedRules.forEach((parsedRule, ruleIndex) => {
        var _a;
        const originalRule = rules[ruleIndex];
        parsedRule.path.forEach((element, elementIndex) => {
            // Add a prefix to the current element containing previously parsed rule elements
            element.prefix = assembleFSHPath(parsedRule.path.slice(0, elementIndex));
            try {
                convertSoftIndexes(element, pathMap);
            }
            catch (e) {
                FSHLogger_1.logger.error(e.message, originalRule.sourceInfo);
            }
        });
        originalRule.path = assembleFSHPath(parsedRule.path); // Assembling the separated rule path back into a normal string
        (_a = parsedRule.caretPath) === null || _a === void 0 ? void 0 : _a.forEach((element, elementIndex) => {
            // Caret path indexes should only be resolved in the context of a specific path
            // Each normal path has a separate map to keep track of the caret path indexes
            if (!caretPathMap.has(originalRule.path)) {
                caretPathMap.set(originalRule.path, new Map());
            }
            const elementCaretPathMap = caretPathMap.get(originalRule.path);
            // Add a prefix to the current element containing previously parsed rule elements
            element.prefix = assembleFSHPath(parsedRule.caretPath.slice(0, elementIndex));
            try {
                convertSoftIndexes(element, elementCaretPathMap);
            }
            catch (e) {
                FSHLogger_1.logger.error(e.message, originalRule.sourceInfo);
            }
        });
        // If a rule is a CaretValueRule, we assemble its caretPath as well
        if (originalRule instanceof rules_1.CaretValueRule) {
            originalRule.caretPath = assembleFSHPath(parsedRule.caretPath);
        }
    });
}
exports.resolveSoftIndexing = resolveSoftIndexing;
//# sourceMappingURL=PathUtils.js.map